{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/sanity-image/packages/url-builder/src/parseImageId.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/sanity-image/packages/url-builder/src/urlBuilder.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/sanity-image/packages/url-builder/src/assetId.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/sanity-image/src/ImageWithPreview.tsx","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/sanity-image/src/SanityImage.tsx"],"sourcesContent":["import type { ImageIdParts } from \"./types\"\n\nexport const SANITY_IMAGE_ID_PATTERN = /^image-([\\da-f]+)-(\\d+x\\d+)-(\\w+)$/\n\n/**\n * Parse an image id string into its component parts.\n *\n * @param {string} id The image id string to parse in the format `image-<hash>-<width>x<height>.<ext>`\n * @returns {ImageIdParts} An object containing the asset ID, dimensions, and format\n */\nexport const parseImageId = (id: string): ImageIdParts => {\n  const match = SANITY_IMAGE_ID_PATTERN.exec(id)\n  const [, assetId, dimensions, format] = match ?? []\n\n  if (!match || !assetId || !dimensions || !format) {\n    throw new Error(`Could not parse image ID \"${id}\"`)\n  }\n\n  const [width, height] = dimensions\n    .split(\"x\")\n    .map((value: string): number => Number.parseInt(value, 10))\n\n  if (Number.isNaN(width) || Number.isNaN(height) || !width || !height) {\n    throw new Error(`Invalid dimensions \"${dimensions}\"`)\n  }\n\n  return {\n    assetId,\n    dimensions: { height, width, aspectRatio: width / height },\n    format,\n  }\n}\n\n/**\n * Convert an image id to a URL path segment for the Sanity Image API. Input is\n * not validated.\n *\n * @example\n * imageIdToUrlPath(\"image-<hash>-<width>x<height>-<ext>\")\n * //                  => \"<hash>-<width>x<height>.<ext>\"\n */\nexport const imageIdToUrlPath = (id: string): string => {\n  // This can be implemented with `parseImageId` but it's more computationally expensive\n  // than this more naive implementation.\n\n  const formatSeparatorIndex = id.lastIndexOf(\"-\")\n\n  return (\n    id.slice(6, formatSeparatorIndex) + \".\" + id.slice(formatSeparatorIndex + 1)\n  )\n}\n","import { imageIdToUrlPath, parseImageId } from \"./parseImageId\"\nimport type {\n  ComputedImageData,\n  CropData,\n  ImageIdParts,\n  ImageQueryInputs,\n  ImageQueryParams,\n  ImageSrcInputs,\n} from \"./types\"\n\n/**\n * Convert ImageSrcInputs into a full image URL and computed output dimensions.\n */\nexport const buildSrc = ({\n  baseUrl,\n  ...inputParams\n}: ImageSrcInputs): ComputedImageData => {\n  const { metadata, ...queryParams } = buildQueryParams({\n    ...inputParams,\n    options: { includeMetadata: true },\n  })\n\n  // Narrowing for TS\n  if (!metadata) {\n    throw new Error(\"Missing image output metadata\")\n  }\n\n  const imageUrl = `${baseUrl}${imageIdToUrlPath(inputParams.id)}`\n\n  return {\n    src: `${imageUrl}?${buildQueryString(queryParams)}`,\n    width: metadata.outputDimensions.width,\n    height: metadata.outputDimensions.height,\n  }\n}\n\nexport const buildSrcSet = ({\n  id,\n  mode = \"contain\",\n  width,\n  height,\n  hotspot,\n  crop,\n  baseUrl,\n  ...inputParams\n}: ImageSrcInputs): string[] => {\n  // Determine base computed width\n  const { w, h } = buildQueryParams({ id, mode, width, height, hotspot, crop })\n\n  // URL of the image without any query parameters\n  const imageUrl = `${baseUrl}${imageIdToUrlPath(id)}`\n\n  // Build srcset\n  const srcSetEntries: string[] = dynamicMultipliers(w)\n    .map((multiple) => {\n      const computedWidth = Math.round(w * multiple)\n      const computedHeight = h && Math.round(h * multiple)\n\n      // Ignore tiny entries; the extra data in the HTML is almost never worth it\n      if (multiple < 1 && computedWidth < 50) return null\n\n      const params: Omit<ImageQueryParams, \"metadata\"> = buildQueryParams({\n        id,\n        mode,\n        width: computedWidth,\n        height: computedHeight,\n        hotspot,\n        crop,\n        ...inputParams,\n      })\n\n      return `${imageUrl}?${buildQueryString(params)} ${params.w}w`\n    })\n    .filter((entry): entry is string => Boolean(entry))\n\n  return Array.from(new Set(srcSetEntries))\n}\n\nexport const buildSvgAttributes = ({ id, baseUrl }: ImageSrcInputs) => {\n  const { assetId, dimensions, format } = parseImageId(id)\n\n  return {\n    src: `${baseUrl}${assetId}-${dimensions.width}x${dimensions.height}.${format}`,\n    width: dimensions.width,\n    height: dimensions.height,\n  }\n}\n\nconst dynamicMultipliers = (width: number): number[] => {\n  // For really small images, use larger steps\n  if (width < 160) {\n    return [0.5, 1, 2]\n  }\n\n  // For typical width images, use standard steps\n  if (width < 750) {\n    return [0.5, 1, 1.5, 2]\n  }\n\n  // For larger images, include 0.25x and 0.75x steps\n  if (width < 1400) {\n    return [0.25, 0.5, 0.75, 1, 1.5, 2]\n  }\n\n  // For really large images, use a wider range of steps at the low end, and smaller steps at the high end\n  return [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2]\n}\n\n/**\n * Constructs a query parameters object for the Sanity image URL based on the inputs provided.\n */\nexport const buildQueryParams = ({\n  id,\n  mode = \"contain\",\n  width,\n  height,\n  hotspot,\n  crop,\n  queryParams,\n  options: { includeMetadata = false } = {},\n}: ImageQueryInputs & {\n  options?: {\n    /** Include data about the image in the response */\n    includeMetadata?: boolean\n  }\n}): ImageQueryParams => {\n  const sourceDimensions = parseImageId(id).dimensions\n\n  // If crop is provided, compute post-crop dimensions\n  const {\n    width: maxWidth,\n    height: maxHeight,\n    aspectRatio: sourceAspectRatio,\n  } = crop ? croppedImageSize(sourceDimensions, crop) : sourceDimensions\n\n  // Determine width if not provided\n  if (!width) {\n    if (height) {\n      // Compute width based on height and default ratio\n      width = Math.round(height * sourceAspectRatio)\n\n      // Discard `height` since we have to be in `contain` mode and we've converted it into `width`\n      height = undefined\n    } else {\n      // Use 1/2 of the max image width by default to allow for 2x scale-up\n      width = Math.round(maxWidth / 2)\n    }\n  }\n\n  // Override `cover` mode if both width and height haven't been provided, or if\n  // the requested aspect ratio matches the source aspect ratio. In these cases\n  // the result will be the same as `contain` mode anyways, and `contain` mode\n  // is simpler and saves a few bytes in the URL.\n  if (\n    mode === \"cover\" &&\n    (!width || !height || width / height === sourceAspectRatio)\n  ) {\n    mode = \"contain\"\n  } else if (mode === \"contain\" && height) {\n    // Similarly, if `contain` mode is used and a height is provided, we can\n    // convert it into a width by adjusting the width such that the\n    // aspect-ratio\u2013constrained result will respect the height provided.\n    width = Math.min(width, Math.round(height * sourceAspectRatio))\n    height = undefined\n  }\n\n  // Clamp min and max dimensions while preserving requested aspect ratio\n  if (width > maxWidth || (height && height > maxHeight)) {\n    const requestedAspectRatio = height ? width / height : sourceAspectRatio\n\n    if (requestedAspectRatio >= sourceAspectRatio) {\n      // Clamp width\n      width = maxWidth\n      height = height && Math.round(width / requestedAspectRatio)\n    } else {\n      // Clamp height\n      height = maxHeight\n      width = Math.round(height * requestedAspectRatio)\n    }\n  }\n\n  // Note: when converting params to a query string initially, we need to\n  // use an object or map instead of URLSearchParams, since the latter will\n  // allow multiple params with the same name, which is not supported by the\n  // Sanity Image API.\n  const params: ImageQueryParams = {\n    w: width,\n    q: 75,\n    // Default fit mode; overriden for `mode=cover` below\n    fit: \"max\",\n    ...queryParams,\n  }\n\n  // If an explicit format has not been requested, use auto format\n  if (!params.fm) params.auto = \"format\"\n\n  if (crop) {\n    // Convert crop to rect param)\n    params.rect = buildRect(sourceDimensions, crop)\n  }\n\n  if (mode === \"cover\") {\n    params.fit = \"crop\"\n\n    if (height) {\n      params.h = height\n    }\n\n    if (hotspot) {\n      // Hotspot is relative to post-`rect` dimensions; if `crop` is present,\n      // the hotspot inputs need to be adjusted accordingly\n      const x = crop\n        ? (hotspot.x - crop.left) / (1 - crop.left - crop.right)\n        : hotspot.x\n      const y = crop\n        ? (hotspot.y - crop.top) / (1 - crop.top - crop.bottom)\n        : hotspot.y\n\n      params[\"fp-x\"] = roundWithPrecision(clamp(x, 0, 1), 3)\n      params[\"fp-y\"] = roundWithPrecision(clamp(y, 0, 1), 3)\n    } else {\n      // If no hotspot is provided, use Sanity\u2019s `entropy` crop mode\n      params.crop = \"entropy\"\n    }\n  }\n\n  if (includeMetadata) {\n    // Height will be set if the aspect ratio varies from `sourceAspectRatio`\n    const outputHeight = height ?? Math.round(width / sourceAspectRatio)\n\n    params.metadata = {\n      sourceDimensions,\n      outputDimensions: {\n        width,\n        height: outputHeight,\n        aspectRatio: width / outputHeight,\n      },\n    }\n  }\n\n  return params\n}\n\nconst clamp = (value: number, min: number, max: number): number =>\n  Math.max(min, Math.min(max, value))\n\nconst roundWithPrecision = (value: number, precision: number): number =>\n  Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision)\n\nexport const croppedImageSize = (\n  /** Source/original image dimensions */\n  dimensions: { width: number; height: number },\n  crop: CropData\n): ImageIdParts[\"dimensions\"] => {\n  if (crop.left + crop.right >= 1 || crop.top + crop.bottom >= 1) {\n    throw new Error(\n      `Invalid crop: ${JSON.stringify(crop)}; crop values must be less than 1`\n    )\n  }\n\n  const width = Math.round(dimensions.width * (1 - crop.left - crop.right))\n  const height = Math.round(dimensions.height * (1 - crop.top - crop.bottom))\n  const aspectRatio = width / height\n\n  return { width, height, aspectRatio }\n}\n\n/**\n * Build a `rect` value to crop the image.\n */\nexport const buildRect = (\n  /** Source/original image dimensions */\n  dimensions: { width: number; height: number },\n  crop: CropData\n): string => {\n  const { width, height } = croppedImageSize(dimensions, crop)\n\n  return [\n    Math.round(crop.left * dimensions.width),\n    Math.round(crop.top * dimensions.height),\n    width,\n    height,\n  ].join(\",\")\n}\n\n/**\n * Converts an object of query params into a query string. The keys are sorted\n * alphabetically to maximize cache-hit rates. Commas are not URL-encoded since\n * doing so is unnecessary, adds extra data, and makes it harder to read.\n */\nexport const buildQueryString = (\n  params: Partial<{\n    [K in keyof Omit<ImageQueryParams, \"metadata\">]: ImageQueryParams[K]\n  }>\n): string => {\n  const searchParams = new URLSearchParams(\n    Object.entries(params)\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(([key, value]) => [key, String(value)])\n  )\n\n  return searchParams.toString().replace(/%2C/g, \",\") // don't urlencode commas\n}\n","type AssetLike = { _id: string } | { _ref: string }\n\n/**\n * Get the asset ID of a Sanity image asset whether it has an `_id` or `_ref`\n * field.\n */\nexport const assetId = (asset: AssetLike) =>\n  \"_id\" in asset ? asset._id : asset._ref\n\n/**\n * Normalize an asset object to have an `_id` field. This is useful when you\n * have an asset object with a `_ref` field and you need to convert it to an\n * `_id` field. Or if you don't know which you have and you want to ensure you\n * have an `_id` field.\n */\nexport const normalizeAssetId = <T extends Record<string, unknown>>(\n  asset: AssetLike & T\n): Omit<T, \"_ref\"> & { _id: string } => {\n  const { _ref, ...rest } = asset\n  return { ...rest, _id: assetId(asset) }\n}\n","import { useEffect, useRef, useState } from \"react\"\nimport type { SanityImageWithPreviewProps } from \"./types\"\n\n/**\n * Renders two image tags, one with the preview image and one with the full\n * image. When the full image is loaded, the preview image is removed, revealing\n * the full image.\n */\nexport const ImageWithPreview = <T extends React.ElementType = \"img\">({\n  as,\n  preview,\n  style,\n  alt,\n  ...props\n}: SanityImageWithPreviewProps<T>) => {\n  const [loaded, setLoaded] = useState(false)\n  const ref = useRef<HTMLImageElement>(null)\n\n  const onLoad = () => {\n    setLoaded(true)\n  }\n\n  useEffect(() => {\n    // If the image is already loaded when mounted, call onLoad\n    if (ref.current?.complete) {\n      onLoad()\n    }\n  }, [])\n\n  const Img = as ?? \"img\"\n\n  return (\n    <>\n      {!loaded && (\n        <Img\n          src={preview}\n          alt={loaded ? \"\" : alt}\n          id={props.id}\n          className={props.className}\n          width={props.width}\n          height={props.height}\n          style={{\n            // Set the aspect ratio to match the full image\n            aspectRatio: `${props.width} / ${props.height}`,\n            ...style,\n          }}\n          data-lqip\n        />\n      )}\n      <Img\n        data-loading={loaded ? null : true}\n        alt={loaded ? alt : \"\"}\n        onLoad={onLoad}\n        ref={ref}\n        style={\n          loaded\n            ? style\n            : {\n                ...baseStyles,\n                ...style,\n              }\n        }\n        {...props}\n      />\n    </>\n  )\n}\n\nconst baseStyles: React.CSSProperties = {\n  // must be > 4px to be lazy loaded\n  height: \"10px\",\n\n  // must be > 4px to be lazy loaded\n  width: \"10px\",\n\n  // Cannot use negative x or y values, visibility: hidden, or display: none\n  // to hide or the image might not get loaded.\n  position: \"absolute\",\n  zIndex: -10,\n  opacity: 0,\n\n  // Disable pointer events and user select to prevent the image\n  // from interfering with UI while it's loading/hidden.\n  pointerEvents: \"none\",\n  userSelect: \"none\",\n}\n","import {\n  buildSrc,\n  buildSrcSet,\n  buildSvgAttributes,\n} from \"@sanity-image/url-builder\"\nimport type { SanityImageProps } from \"./types\"\nimport { ImageWithPreview } from \"./ImageWithPreview\"\n\nexport const SanityImage = <T extends React.ElementType = \"img\">({\n  as: component,\n\n  // Sanity url\n  baseUrl,\n  projectId,\n  dataset,\n\n  // Image definition data\n  id,\n  hotspot,\n  crop,\n  width,\n  height,\n  mode = \"contain\",\n\n  // Data for LQIP (preview image)\n  preview,\n\n  // Native-behavior overrides\n  htmlWidth,\n  htmlHeight,\n  htmlId,\n\n  // Image query string params\n  queryParams,\n\n  // Any remaining props are passed through to the rendered component\n  ...rest\n}: SanityImageProps<T>) => {\n  if (!id) throw new Error(\"Missing required `id` prop for <SanityImage>.\")\n  if (!baseUrl && (!projectId || !dataset))\n    throw new Error(\n      \"Missing required `baseUrl` or `projectId` and `dataset` props for <SanityImage>.\"\n    )\n\n  baseUrl = baseUrl ?? `https://cdn.sanity.io/images/${projectId}/${dataset}/`\n\n  const isSvg = id.endsWith(\"-svg\")\n\n  const ImageComponent =\n    preview && !isSvg ? ImageWithPreview : (component ?? \"img\")\n\n  const componentProps: Record<string, unknown> = {\n    alt: rest.alt ?? \"\",\n    loading: rest.loading ?? \"lazy\",\n    id: htmlId,\n    ...rest,\n  }\n\n  if (isSvg) {\n    // Sanity ignores all transformations for SVGs, so we can just render the\n    // component without passing a query string and without doing anything for\n    // the preview.\n    const baseAttributes: Record<string, unknown> = buildSvgAttributes({\n      id,\n      baseUrl,\n    })\n\n    // If this is a <source> element, we need to set the `srcSet` attribute and not\n    // the `src` attribute, otherwise it will be ignored in <picture> elements.\n    if (component === \"source\") {\n      baseAttributes.srcSet = baseAttributes.src\n      delete baseAttributes.src\n    }\n\n    return <ImageComponent {...baseAttributes} {...componentProps} />\n  }\n\n  // Create default src and build srcSet\n  const srcParams = {\n    baseUrl,\n    id,\n    crop,\n    hotspot,\n    width,\n    height,\n    mode,\n    queryParams,\n  }\n\n  const { src, ...outputDimensions } = buildSrc(srcParams)\n  componentProps.srcSet = buildSrcSet(srcParams).join(\", \")\n  componentProps.src = src\n  componentProps.width = htmlWidth ?? outputDimensions.width\n  componentProps.height = htmlHeight ?? outputDimensions.height\n\n  if (preview) {\n    componentProps.as = component ?? \"img\"\n    componentProps.preview = preview\n  }\n\n  return <ImageComponent {...componentProps} />\n}\n"],"names":["SANITY_IMAGE_ID_PATTERN", "parseImageId", "id", "match", "assetId", "dimensions", "format", "width", "height", "value", "imageIdToUrlPath", "formatSeparatorIndex", "buildSrc", "baseUrl", "inputParams", "metadata", "queryParams", "buildQueryParams", "buildQueryString", "buildSrcSet", "mode", "hotspot", "crop", "w", "h", "imageUrl", "srcSetEntries", "dynamicMultipliers", "multiple", "computedWidth", "computedHeight", "params", "entry", "buildSvgAttributes", "includeMetadata", "sourceDimensions", "maxWidth", "maxHeight", "sourceAspectRatio", "croppedImageSize", "requestedAspectRatio", "buildRect", "x", "y", "roundWithPrecision", "clamp", "outputHeight", "min", "max", "precision", "aspectRatio", "a", "b", "key", "asset", "normalizeAssetId", "_ref", "rest", "useEffect", "useRef", "useState", "Fragment", "jsx", "jsxs", "ImageWithPreview", "as", "preview", "style", "alt", "props", "loaded", "setLoaded", "ref", "onLoad", "Img", "baseStyles", "jsx", "SanityImage", "component", "baseUrl", "projectId", "dataset", "id", "hotspot", "crop", "width", "height", "mode", "preview", "htmlWidth", "htmlHeight", "htmlId", "queryParams", "rest", "isSvg", "ImageComponent", "ImageWithPreview", "componentProps", "baseAttributes", "A", "srcParams", "src", "outputDimensions", "w", "D"],"mappings":"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"}},
    {"offset": {"line": 249, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/toolkit/dist/index.js","sources":["file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/toolkit/src/asserters.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/toolkit/src/sortMarksByOccurences.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/toolkit/src/buildMarksTree.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/toolkit/src/nestLists.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/toolkit/src/spanToPlainText.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/toolkit/src/toPlainText.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/toolkit/src/types.ts"],"sourcesContent":["import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan,\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject,\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      !node.markDefs ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject,\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList,\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan,\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode,\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n","import type {PortableTextSpan, TypedObject} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[],\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U,\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>,\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children} = block\n  const markDefs = block.markDefs ?? []\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs?.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text})),\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n","import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct',\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html',\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html',\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode,\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList,\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // oxlint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode,\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>,\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n","import {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\nimport type {ToolkitNestedPortableTextSpan} from './types'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n","import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\n\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\n\nconst leadingSpace = /^\\s/\nconst trailingSpace = /\\s$/\n\n/**\n * Takes a Portable Text block (or an array of them) and returns the text value\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\n * non-span nodes to ensure text flow is optimal.\n *\n * Note that this only accounts for regular Portable Text blocks - any text inside\n * custom content types are not included in the output.\n *\n * @param block - Single block or an array of blocks to extract text from\n * @returns The plain-text content of the blocks\n */\nexport function toPlainText(\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[],\n): string {\n  const blocks = Array.isArray(block) ? block : [block]\n  let text = ''\n\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return\n    }\n\n    let pad = false\n    current.children.forEach((span) => {\n      if (isPortableTextSpan(span)) {\n        // If the previous element was a non-span, and we have no natural whitespace\n        // between the previous and the next span, insert it to give the spans some\n        // room to breathe. However, don't do so if this is the first span.\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\n        text += span.text\n        pad = false\n      } else {\n        pad = true\n      }\n    })\n\n    if (index !== blocks.length - 1) {\n      text += '\\n\\n'\n    }\n  })\n\n  return text\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem\n  extends PortableTextListItemBlock<\n    PortableTextMarkDefinition,\n    PortableTextSpan | ToolkitPortableTextList\n  > {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition,\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (ToolkitTextNode | ToolkitNestedPortableTextSpan | ArbitraryTypedObject)[]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 487, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@portabletext/react/dist/index.js","sources":["file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/react/src/components/list.tsx","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/react/src/components/marks.tsx","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/react/src/warnings.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/react/src/components/unknown.tsx","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/react/src/components/defaults.tsx","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/react/src/components/merge.ts","file:///C:/Users/quinc/OneDrive/Desktop/Websites/Digicampus/digicampus-next.js-sanity/node_modules/%40portabletext/react/src/react-portable-text.tsx"],"sourcesContent":["import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => <ol>{children}</ol>,\n  bullet: ({children}) => <ul>{children}</ul>,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => <li>{children}</li>\n","import type {TypedObject} from '@portabletext/types'\n\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => (\n  <a href={value?.href}>{children}</a>\n)\n\nconst underlineStyle = {textDecoration: 'underline'}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  em: ({children}) => <em>{children}</em>,\n  strong: ({children}) => <strong>{children}</strong>,\n  code: ({children}) => <code>{children}</code>,\n  underline: ({children}) => <span style={underlineStyle}>{children}</span>,\n  'strike-through': ({children}) => <del>{children}</del>,\n  link,\n}\n","const getTemplate = (type: string, prop: string): string =>\n  `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  // oxlint-disable-next-line no-console\n  console.warn(message)\n}\n","import type {PortableTextReactComponents} from '../types'\nimport {unknownTypeWarning} from '../warnings'\n\nconst hidden = {display: 'none'}\n\nexport const DefaultUnknownType: PortableTextReactComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline ? <span style={hidden}>{warning}</span> : <div style={hidden}>{warning}</div>\n}\n\nexport const DefaultUnknownMark: PortableTextReactComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return <span className={`unknown__pt__mark__${markType}`}>{children}</span>\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextReactComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return <p>{children}</p>\n}\n\nexport const DefaultUnknownList: PortableTextReactComponents['unknownList'] = ({children}) => {\n  return <ul>{children}</ul>\n}\n\nexport const DefaultUnknownListItem: PortableTextReactComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return <li>{children}</li>\n}\n","import type {PortableTextBlockStyle} from '@portabletext/types'\nimport type {JSX} from 'react'\n\nimport type {PortableTextBlockComponent, PortableTextReactComponents} from '../types'\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): JSX.Element => <br />\n\nexport const defaultBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => <p>{children}</p>,\n  blockquote: ({children}) => <blockquote>{children}</blockquote>,\n  h1: ({children}) => <h1>{children}</h1>,\n  h2: ({children}) => <h2>{children}</h2>,\n  h3: ({children}) => <h3>{children}</h3>,\n  h4: ({children}) => <h4>{children}</h4>,\n  h5: ({children}) => <h5>{children}</h5>,\n  h6: ({children}) => <h6>{children}</h6>,\n}\n\nexport const defaultComponents: PortableTextReactComponents = {\n  types: {},\n\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n","import type {PortableTextComponents, PortableTextReactComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n): PortableTextReactComponents {\n  const {\n    block: _block,\n    list: _list,\n    listItem: _listItem,\n    marks: _marks,\n    types: _types,\n    ...rest\n  } = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextReactComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextReactComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextReactComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextReactComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextReactComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextReactComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextReactComponents[typeof key]\n  }\n\n  return parentVal\n}\n","import type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from '@portabletext/toolkit'\nimport {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  LIST_NEST_MODE_HTML,\n  nestLists,\n  spanToPlainText,\n} from '@portabletext/toolkit'\nimport type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\nimport {type JSX, type ReactNode, useMemo} from 'react'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport type {\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextProps,\n  PortableTextReactComponents,\n  ReactPortableTextList,\n  Serializable,\n  SerializedBlock,\n} from './types'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function PortableText<B extends TypedObject = PortableTextBlock>({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning,\n}: PortableTextProps<B>): JSX.Element {\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(input) ? input : [input]\n  const nested = nestLists(blocks, listNestingMode || LIST_NEST_MODE_HTML)\n\n  const components = useMemo(() => {\n    return componentOverrides\n      ? mergeComponents(defaultComponents, componentOverrides)\n      : defaultComponents\n  }, [componentOverrides])\n\n  const renderNode = useMemo(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent],\n  )\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return <>{rendered}</>\n}\n\nconst getNodeRenderer = (\n  components: PortableTextReactComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): ReactNode {\n    const {node, index, isInline} = options\n    const key = node._key || `node-${index}`\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index, key)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index, key)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node, index, key)\n    }\n\n    if (hasCustomComponentForNode(node)) {\n      return renderCustomBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node, key)\n    }\n\n    return renderUnknownType(node, index, key, isInline)\n  }\n\n  function hasCustomComponentForNode(node: TypedObject): boolean {\n    return node._type in components.types\n  }\n\n  function renderListItem(node: PortableTextListItemBlock, index: number, key: string) {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const Li = handler || components.unknownListItem\n\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block serializer says to use\n      const {listItem: _listItem, ...blockNode} = node\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: false,\n        renderNode,\n      })\n    }\n\n    return (\n      <Li key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </Li>\n    )\n  }\n\n  function renderList(node: ReactPortableTextList, index: number, key: string) {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const List = handler || components.unknownList\n\n    if (List === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: 'listStyle',\n        type: style,\n      })\n    }\n\n    return (\n      <List key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </List>\n    )\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan, _index: number, key: string) {\n    const {markDef, markType, markKey} = node\n    const Span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child,\n        index: childIndex,\n        isInline: true,\n        renderNode,\n      }),\n    )\n\n    if (Span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {\n        nodeType: 'mark',\n        type: markType,\n      })\n    }\n\n    return (\n      <Span\n        key={key}\n        text={spanToPlainText(node)}\n        value={markDef}\n        markType={markType}\n        markKey={markKey}\n        renderNode={renderNode}\n      >\n        {children}\n      </Span>\n    )\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, key: string, isInline: boolean) {\n    const {_key, ...props} = serializeBlock({\n      node,\n      index,\n      isInline,\n      renderNode,\n    })\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const Block = handler || components.unknownBlockStyle\n\n    if (Block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return <Block key={key} {...props} value={props.node} renderNode={renderNode} />\n  }\n\n  function renderText(node: ToolkitTextNode, key: string) {\n    if (node.text === '\\n') {\n      const HardBreak = components.hardBreak\n      return HardBreak ? <HardBreak key={key} /> : '\\n'\n    }\n\n    return node.text\n  }\n\n  function renderUnknownType(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: 'block',\n      type: node._type,\n    })\n\n    const UnknownType = components.unknownType\n    return <UnknownType key={key} {...nodeOptions} />\n  }\n\n  function renderCustomBlock(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    const Node = components.types[node._type]\n    return Node ? <Node key={key} {...nodeOptions} /> : null\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n"],"names":[],"mappings":"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"}}]
}