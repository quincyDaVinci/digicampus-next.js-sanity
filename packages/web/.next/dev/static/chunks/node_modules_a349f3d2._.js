(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    assign: null,
    searchParamsToUrlQuery: null,
    urlQueryToSearchParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    assign: function() {
        return assign;
    },
    searchParamsToUrlQuery: function() {
        return searchParamsToUrlQuery;
    },
    urlQueryToSearchParams: function() {
        return urlQueryToSearchParams;
    }
});
function searchParamsToUrlQuery(searchParams) {
    const query = {};
    for (const [key, value] of searchParams.entries()){
        const existing = query[key];
        if (typeof existing === 'undefined') {
            query[key] = value;
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            query[key] = [
                existing,
                value
            ];
        }
    }
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
        return String(param);
    } else {
        return '';
    }
}
function urlQueryToSearchParams(query) {
    const searchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query)){
        if (Array.isArray(value)) {
            for (const item of value){
                searchParams.append(key, stringifyUrlQueryParam(item));
            }
        } else {
            searchParams.set(key, stringifyUrlQueryParam(value));
        }
    }
    return searchParams;
}
function assign(target, ...searchParamsList) {
    for (const searchParams of searchParamsList){
        for (const key of searchParams.keys()){
            target.delete(key);
        }
        for (const [key, value] of searchParams.entries()){
            target.append(key, value);
        }
    }
    return target;
} //# sourceMappingURL=querystring.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatUrl: null,
    formatWithValidation: null,
    urlObjectKeys: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatUrl: function() {
        return formatUrl;
    },
    formatWithValidation: function() {
        return formatWithValidation;
    },
    urlObjectKeys: function() {
        return urlObjectKeys;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _querystring = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)"));
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    let { auth, hostname } = urlObj;
    let protocol = urlObj.protocol || '';
    let pathname = urlObj.pathname || '';
    let hash = urlObj.hash || '';
    let query = urlObj.query || '';
    let host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);
        if (urlObj.port) {
            host += ':' + urlObj.port;
        }
    }
    if (query && typeof query === 'object') {
        query = String(_querystring.urlQueryToSearchParams(query));
    }
    let search = urlObj.search || query && `?${query}` || '';
    if (protocol && !protocol.endsWith(':')) protocol += ':';
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }
    if (hash && hash[0] !== '#') hash = '#' + hash;
    if (search && search[0] !== '?') search = '?' + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace('#', '%23');
    return `${protocol}${host}${pathname}${search}${hash}`;
}
const urlObjectKeys = [
    'auth',
    'hash',
    'host',
    'hostname',
    'href',
    'path',
    'pathname',
    'port',
    'protocol',
    'query',
    'search',
    'slashes'
];
function formatWithValidation(url) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (url !== null && typeof url === 'object') {
            Object.keys(url).forEach((key)=>{
                if (!urlObjectKeys.includes(key)) {
                    console.warn(`Unknown key passed via urlObject into url.format: ${key}`);
                }
            });
        }
    }
    return formatUrl(url);
} //# sourceMappingURL=format-url.js.map
}),
"[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(null);
    const cleanupB = (0, _react.useRef)(null);
    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.
    // (this happens often if the user doesn't pass a ref to Link/Form/Image)
    // But this can cause us to leak a cleanup-ref into user code (previously via `<Link legacyBehavior>`),
    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs
    // (because it hasn't been updated for React 19)
    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.
    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.
    return (0, _react.useCallback)((current)=>{
        if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
                cleanupA.current = null;
                cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
                cleanupB.current = null;
                cleanupFnB();
            }
        } else {
            if (refA) {
                cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
                cleanupB.current = applyRef(refB, current);
            }
        }
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}),
"[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DecodeError: null,
    MiddlewareNotFoundError: null,
    MissingStaticPage: null,
    NormalizeError: null,
    PageNotFoundError: null,
    SP: null,
    ST: null,
    WEB_VITALS: null,
    execOnce: null,
    getDisplayName: null,
    getLocationOrigin: null,
    getURL: null,
    isAbsoluteUrl: null,
    isResSent: null,
    loadGetInitialProps: null,
    normalizeRepeatedSlashes: null,
    stringifyError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DecodeError: function() {
        return DecodeError;
    },
    MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
    },
    MissingStaticPage: function() {
        return MissingStaticPage;
    },
    NormalizeError: function() {
        return NormalizeError;
    },
    PageNotFoundError: function() {
        return PageNotFoundError;
    },
    SP: function() {
        return SP;
    },
    ST: function() {
        return ST;
    },
    WEB_VITALS: function() {
        return WEB_VITALS;
    },
    execOnce: function() {
        return execOnce;
    },
    getDisplayName: function() {
        return getDisplayName;
    },
    getLocationOrigin: function() {
        return getLocationOrigin;
    },
    getURL: function() {
        return getURL;
    },
    isAbsoluteUrl: function() {
        return isAbsoluteUrl;
    },
    isResSent: function() {
        return isResSent;
    },
    loadGetInitialProps: function() {
        return loadGetInitialProps;
    },
    normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
    },
    stringifyError: function() {
        return stringifyError;
    }
});
const WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
function execOnce(fn) {
    let used = false;
    let result;
    return (...args)=>{
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol, hostname, port } = window.location;
    return `${protocol}//${hostname}${port ? ':' + port : ''}`;
}
function getURL() {
    const { href } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split('?');
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '');
}
async function loadGetInitialProps(App, ctx) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (App.prototype?.getInitialProps) {
            const message = `"${getDisplayName(App)}.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;
            throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            });
        }
    }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = `"${getDisplayName(App)}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn(`${getDisplayName(App)} returned an empty object from \`getInitialProps\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);
        }
    }
    return props;
}
const SP = typeof performance !== 'undefined';
const ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every((method)=>typeof performance[method] === 'function');
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = 'ENOENT';
        this.name = 'PageNotFoundError';
        this.message = `Cannot find module for page: ${page}`;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = `Failed to load static file for page: ${page} ${message}`;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = 'ENOENT';
        this.message = `Cannot find the middleware module`;
    }
}
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isLocalURL", {
    enumerable: true,
    get: function() {
        return isLocalURL;
    }
});
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)");
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)");
function isLocalURL(url) {
    // prevent a hydration mismatch on href for url with anchor refs
    if (!(0, _utils.isAbsoluteUrl)(url)) return true;
    try {
        // absolute urls can be local if they are on the same origin
        const locationOrigin = (0, _utils.getLocationOrigin)();
        const resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);
    } catch (_) {
        return false;
    }
} //# sourceMappingURL=is-local-url.js.map
}),
"[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "errorOnce", {
    enumerable: true,
    get: function() {
        return errorOnce;
    }
});
let errorOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const errors = new Set();
    errorOnce = (msg)=>{
        if (!errors.has(msg)) {
            console.error(msg);
        }
        errors.add(msg);
    };
} //# sourceMappingURL=error-once.js.map
}),
"[project]/node_modules/next/dist/client/app-dir/link.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    useLinkStatus: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    /**
 * A React component that extends the HTML `<a>` element to provide
 * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)
 * and client-side navigation. This is the primary way to navigate between routes in Next.js.
 *
 * @remarks
 * - Prefetching is only enabled in production.
 *
 * @see https://nextjs.org/docs/app/api-reference/components/link
 */ default: function() {
        return LinkComponent;
    },
    useLinkStatus: function() {
        return useLinkStatus;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _formaturl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)");
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)");
const _islocalurl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-client] (ecmascript)");
const _types = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)");
const _erroronce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-client] (ecmascript)");
function isModifiedEvent(event) {
    const eventTarget = event.currentTarget;
    const target = eventTarget.getAttribute('target');
    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
    event.nativeEvent && event.nativeEvent.which === 2;
}
function linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {
    if (typeof window !== 'undefined') {
        const { nodeName } = e.currentTarget;
        // anchors inside an svg have a lowercase nodeName
        const isAnchorNodeName = nodeName.toUpperCase() === 'A';
        if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {
            // ignore click for browser’s default behavior
            return;
        }
        if (!(0, _islocalurl.isLocalURL)(href)) {
            if (replace) {
                // browser default behavior does not replace the history state
                // so we need to do it manually
                e.preventDefault();
                location.replace(href);
            }
            // ignore click for browser’s default behavior
            return;
        }
        e.preventDefault();
        if (onNavigate) {
            let isDefaultPrevented = false;
            onNavigate({
                preventDefault: ()=>{
                    isDefaultPrevented = true;
                }
            });
            if (isDefaultPrevented) {
                return;
            }
        }
        const { dispatchNavigateAction } = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)");
        _react.default.startTransition(()=>{
            dispatchNavigateAction(as || href, replace ? 'replace' : 'push', scroll ?? true, linkInstanceRef.current);
        });
    }
}
function formatStringOrUrl(urlObjOrString) {
    if (typeof urlObjOrString === 'string') {
        return urlObjOrString;
    }
    return (0, _formaturl.formatUrl)(urlObjOrString);
}
function LinkComponent(props) {
    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);
    let children;
    const linkInstanceRef = (0, _react.useRef)(null);
    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;
    children = childrenProp;
    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {
        children = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            children: children
        });
    }
    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);
    const prefetchEnabled = prefetchProp !== false;
    const fetchStrategy = prefetchProp !== false ? getFetchStrategyFromPrefetchProp(prefetchProp) : _types.FetchStrategy.PPR;
    if ("TURBOPACK compile-time truthy", 1) {
        function createPropError(args) {
            return Object.defineProperty(new Error(`Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.` + (typeof window !== 'undefined' ? "\nOpen your browser's console to view the Component stack trace." : '')), "__NEXT_ERROR_CODE", {
                value: "E319",
                enumerable: false,
                configurable: true
            });
        }
        // TypeScript trick for type-guarding:
        const requiredPropsGuard = {
            href: true
        };
        const requiredProps = Object.keys(requiredPropsGuard);
        requiredProps.forEach((key)=>{
            if (key === 'href') {
                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: props[key] === null ? 'null' : typeof props[key]
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                const _ = key;
            }
        });
        // TypeScript trick for type-guarding:
        const optionalPropsGuard = {
            as: true,
            replace: true,
            scroll: true,
            shallow: true,
            passHref: true,
            prefetch: true,
            unstable_dynamicOnHover: true,
            onClick: true,
            onMouseEnter: true,
            onTouchStart: true,
            legacyBehavior: true,
            onNavigate: true
        };
        const optionalProps = Object.keys(optionalPropsGuard);
        optionalProps.forEach((key)=>{
            const valType = typeof props[key];
            if (key === 'as') {
                if (props[key] && valType !== 'string' && valType !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: valType
                    });
                }
            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {
                if (props[key] && valType !== 'function') {
                    throw createPropError({
                        key,
                        expected: '`function`',
                        actual: valType
                    });
                }
            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {
                if (props[key] != null && valType !== 'boolean') {
                    throw createPropError({
                        key,
                        expected: '`boolean`',
                        actual: valType
                    });
                }
            } else if (key === 'prefetch') {
                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto') {
                    throw createPropError({
                        key,
                        expected: '`boolean | "auto"`',
                        actual: valType
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                const _ = key;
            }
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (props.locale) {
            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');
        }
        if (!asProp) {
            let href;
            if (typeof hrefProp === 'string') {
                href = hrefProp;
            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {
                href = hrefProp.pathname;
            }
            if (href) {
                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));
                if (hasDynamicSegment) {
                    throw Object.defineProperty(new Error(`Dynamic href \`${href}\` found in <Link> while using the \`/app\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`), "__NEXT_ERROR_CODE", {
                        value: "E267",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
    const { href, as } = _react.default.useMemo({
        "LinkComponent.useMemo": ()=>{
            const resolvedHref = formatStringOrUrl(hrefProp);
            return {
                href: resolvedHref,
                as: asProp ? formatStringOrUrl(asProp) : resolvedHref
            };
        }
    }["LinkComponent.useMemo"], [
        hrefProp,
        asProp
    ]);
    // This will return the first child, if multiple are provided it will throw an error
    let child;
    if (legacyBehavior) {
        if (children?.$$typeof === Symbol.for('react.lazy')) {
            throw Object.defineProperty(new Error(`\`<Link legacyBehavior>\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \`<a>\` tag.`), "__NEXT_ERROR_CODE", {
                value: "E863",
                enumerable: false,
                configurable: true
            });
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (onClick) {
                console.warn(`"onClick" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onClick be set on the child of next/link`);
            }
            if (onMouseEnterProp) {
                console.warn(`"onMouseEnter" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`);
            }
            try {
                child = _react.default.Children.only(children);
            } catch (err) {
                if (!children) {
                    throw Object.defineProperty(new Error(`No children were passed to <Link> with \`href\` of \`${hrefProp}\` but one child is required https://nextjs.org/docs/messages/link-no-children`), "__NEXT_ERROR_CODE", {
                        value: "E320",
                        enumerable: false,
                        configurable: true
                    });
                }
                throw Object.defineProperty(new Error(`Multiple children were passed to <Link> with \`href\` of \`${hrefProp}\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + (typeof window !== 'undefined' ? " \nOpen your browser's console to view the Component stack trace." : '')), "__NEXT_ERROR_CODE", {
                    value: "E266",
                    enumerable: false,
                    configurable: true
                });
            }
        } else //TURBOPACK unreachable
        ;
    } else {
        if ("TURBOPACK compile-time truthy", 1) {
            if (children?.type === 'a') {
                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), "__NEXT_ERROR_CODE", {
                    value: "E209",
                    enumerable: false,
                    configurable: true
                });
            }
        }
    }
    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;
    // Use a callback ref to attach an IntersectionObserver to the anchor tag on
    // mount. In the future we will also use this to keep track of all the
    // currently mounted <Link> instances, e.g. so we can re-prefetch them after
    // a revalidation or refresh.
    const observeLinkVisibilityOnMount = _react.default.useCallback({
        "LinkComponent.useCallback[observeLinkVisibilityOnMount]": (element)=>{
            if (router !== null) {
                linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus);
            }
            return ({
                "LinkComponent.useCallback[observeLinkVisibilityOnMount]": ()=>{
                    if (linkInstanceRef.current) {
                        (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);
                        linkInstanceRef.current = null;
                    }
                    (0, _links.unmountPrefetchableInstance)(element);
                }
            })["LinkComponent.useCallback[observeLinkVisibilityOnMount]"];
        }
    }["LinkComponent.useCallback[observeLinkVisibilityOnMount]"], [
        prefetchEnabled,
        href,
        router,
        fetchStrategy,
        setOptimisticLinkStatus
    ]);
    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);
    const childProps = {
        ref: mergedRef,
        onClick (e) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (!e) {
                    throw Object.defineProperty(new Error(`Component rendered inside next/link has to pass click event to "onClick" prop.`), "__NEXT_ERROR_CODE", {
                        value: "E312",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
            if (!legacyBehavior && typeof onClick === 'function') {
                onClick(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {
                child.props.onClick(e);
            }
            if (!router) {
                return;
            }
            if (e.defaultPrevented) {
                return;
            }
            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);
        },
        onMouseEnter (e) {
            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {
                onMouseEnterProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {
                child.props.onMouseEnter(e);
            }
            if (!router) {
                return;
            }
            if ("TURBOPACK compile-time truthy", 1) {
                return;
            }
            //TURBOPACK unreachable
            ;
            const upgradeToDynamicPrefetch = undefined;
        },
        onTouchStart: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : function onTouchStart(e) {
            if (!legacyBehavior && typeof onTouchStartProp === 'function') {
                onTouchStartProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {
                child.props.onTouchStart(e);
            }
            if (!router) {
                return;
            }
            if (!prefetchEnabled) {
                return;
            }
            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;
            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);
        }
    };
    // If the url is absolute, we can bypass the logic to prepend the basePath.
    if ((0, _utils.isAbsoluteUrl)(as)) {
        childProps.href = as;
    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {
        childProps.href = (0, _addbasepath.addBasePath)(as);
    }
    let link;
    if (legacyBehavior) {
        if ("TURBOPACK compile-time truthy", 1) {
            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\n\n' + 'npx @next/codemod@latest new-link .\n\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');
        }
        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);
    } else {
        link = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            ...restProps,
            ...childProps,
            children: children
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {
        value: linkStatus,
        children: link
    });
}
const LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);
const useLinkStatus = ()=>{
    return (0, _react.useContext)(LinkStatusContext);
};
function getFetchStrategyFromPrefetchProp(prefetchProp) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return prefetchProp === null || prefetchProp === 'auto' ? _types.FetchStrategy.PPR : // (although invalid values should've been filtered out by prop validation in dev)
        _types.FetchStrategy.Full;
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=link.js.map
}),
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
            case REACT_VIEW_TRANSITION_TYPE:
                return "ViewTransition";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
        isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        if (trackActualOwner) {
            var previousStackTraceLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = 10;
            var debugStackDEV = Error("react-stack-top-frame");
            Error.stackTraceLimit = previousStackTraceLimit;
        } else debugStackDEV = unknownOwnerDebugStack;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStackDEV, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/next/dist/shared/lib/image-blur-svg.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A shared function, used on both client and server, to generate a SVG blur placeholder.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImageBlurSvg", {
    enumerable: true,
    get: function() {
        return getImageBlurSvg;
    }
});
function getImageBlurSvg({ widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit }) {
    const std = 20;
    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;
    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;
    const viewBox = svgWidth && svgHeight ? `viewBox='0 0 ${svgWidth} ${svgHeight}'` : '';
    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';
    return `%3Csvg xmlns='http://www.w3.org/2000/svg' ${viewBox}%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='${std}'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='${std}'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='${preserveAspectRatio}' style='filter: url(%23b);' href='${blurDataURL}'/%3E%3C/svg%3E`;
} //# sourceMappingURL=image-blur-svg.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    VALID_LOADERS: null,
    imageConfigDefault: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    VALID_LOADERS: function() {
        return VALID_LOADERS;
    },
    imageConfigDefault: function() {
        return imageConfigDefault;
    }
});
const VALID_LOADERS = [
    'default',
    'imgix',
    'cloudinary',
    'akamai',
    'custom'
];
const imageConfigDefault = {
    deviceSizes: [
        640,
        750,
        828,
        1080,
        1200,
        1920,
        2048,
        3840
    ],
    imageSizes: [
        32,
        48,
        64,
        96,
        128,
        256,
        384
    ],
    path: '/_next/image',
    loader: 'default',
    loaderFile: '',
    /**
   * @deprecated Use `remotePatterns` instead to protect your application from malicious users.
   */ domains: [],
    disableStaticImages: false,
    minimumCacheTTL: 14400,
    formats: [
        'image/webp'
    ],
    maximumRedirects: 3,
    dangerouslyAllowLocalIP: false,
    dangerouslyAllowSVG: false,
    contentSecurityPolicy: `script-src 'none'; frame-src 'none'; sandbox;`,
    contentDispositionType: 'attachment',
    localPatterns: undefined,
    remotePatterns: [],
    qualities: [
        75
    ],
    unoptimized: false
}; //# sourceMappingURL=image-config.js.map
}),
"[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImgProps", {
    enumerable: true,
    get: function() {
        return getImgProps;
    }
});
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _imageblursvg = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-blur-svg.js [app-client] (ecmascript)");
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const VALID_LOADING_VALUES = [
    'lazy',
    'eager',
    undefined
];
// Object-fit values that are not valid background-size values
const INVALID_BACKGROUND_SIZE_VALUES = [
    '-moz-initial',
    'fill',
    'none',
    'scale-down',
    undefined
];
function isStaticRequire(src) {
    return src.default !== undefined;
}
function isStaticImageData(src) {
    return src.src !== undefined;
}
function isStaticImport(src) {
    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));
}
const allImgs = new Map();
let perfObserver;
function getInt(x) {
    if (typeof x === 'undefined') {
        return x;
    }
    if (typeof x === 'number') {
        return Number.isFinite(x) ? x : NaN;
    }
    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {
        return parseInt(x, 10);
    }
    return NaN;
}
function getWidths({ deviceSizes, allSizes }, width, sizes) {
    if (sizes) {
        // Find all the "vw" percent sizes used in the sizes prop
        const viewportWidthRe = /(^|\s)(1?\d?\d)vw/g;
        const percentSizes = [];
        for(let match; match = viewportWidthRe.exec(sizes); match){
            percentSizes.push(parseInt(match[2]));
        }
        if (percentSizes.length) {
            const smallestRatio = Math.min(...percentSizes) * 0.01;
            return {
                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),
                kind: 'w'
            };
        }
        return {
            widths: allSizes,
            kind: 'w'
        };
    }
    if (typeof width !== 'number') {
        return {
            widths: deviceSizes,
            kind: 'w'
        };
    }
    const widths = [
        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and
        // > blue colors. Showing a 3x resolution image in the app vs a 2x
        // > resolution image will be visually the same, though the 3x image
        // > takes significantly more data. Even true 3x resolution screens are
        // > wasteful as the human eye cannot see that level of detail without
        // > something like a magnifying glass.
        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
        [
            width,
            width * 2 /*, width * 3*/ 
        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))
    ];
    return {
        widths,
        kind: 'x'
    };
}
function generateImgAttrs({ config, src, unoptimized, width, quality, sizes, loader }) {
    if (unoptimized) {
        return {
            src,
            srcSet: undefined,
            sizes: undefined
        };
    }
    const { widths, kind } = getWidths(config, width, sizes);
    const last = widths.length - 1;
    return {
        sizes: !sizes && kind === 'w' ? '100vw' : sizes,
        srcSet: widths.map((w, i)=>`${loader({
                config,
                src,
                quality,
                width: w
            })} ${kind === 'w' ? w : i + 1}${kind}`).join(', '),
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        src: loader({
            config,
            src,
            quality,
            width: widths[last]
        })
    };
}
function getImgProps({ src, sizes, unoptimized = false, priority = false, preload = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest }, _state) {
    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;
    let config;
    let c = imgConf || _imageconfig.imageConfigDefault;
    if ('allSizes' in c) {
        config = c;
    } else {
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = c.qualities?.sort((a, b)=>a - b);
        config = {
            ...c,
            allSizes,
            deviceSizes,
            qualities
        };
    }
    if (typeof defaultLoader === 'undefined') {
        throw Object.defineProperty(new Error('images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config'), "__NEXT_ERROR_CODE", {
            value: "E163",
            enumerable: false,
            configurable: true
        });
    }
    let loader = rest.loader || defaultLoader;
    // Remove property so it's not spread on <img> element
    delete rest.loader;
    delete rest.srcSet;
    // This special value indicates that the user
    // didn't define a "loader" prop or "loader" config.
    const isDefaultLoader = '__next_img_default' in loader;
    if (isDefaultLoader) {
        if (config.loader === 'custom') {
            throw Object.defineProperty(new Error(`Image with src "${src}" is missing "loader" prop.` + `\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader`), "__NEXT_ERROR_CODE", {
                value: "E252",
                enumerable: false,
                configurable: true
            });
        }
    } else {
        // The user defined a "loader" prop or config.
        // Since the config object is internal only, we
        // must not pass it to the user-defined "loader".
        const customImageLoader = loader;
        loader = (obj)=>{
            const { config: _, ...opts } = obj;
            return customImageLoader(opts);
        };
    }
    if (layout) {
        if (layout === 'fill') {
            fill = true;
        }
        const layoutToStyle = {
            intrinsic: {
                maxWidth: '100%',
                height: 'auto'
            },
            responsive: {
                width: '100%',
                height: 'auto'
            }
        };
        const layoutToSizes = {
            responsive: '100vw',
            fill: '100vw'
        };
        const layoutStyle = layoutToStyle[layout];
        if (layoutStyle) {
            style = {
                ...style,
                ...layoutStyle
            };
        }
        const layoutSizes = layoutToSizes[layout];
        if (layoutSizes && !sizes) {
            sizes = layoutSizes;
        }
    }
    let staticSrc = '';
    let widthInt = getInt(width);
    let heightInt = getInt(height);
    let blurWidth;
    let blurHeight;
    if (isStaticImport(src)) {
        const staticImageData = isStaticRequire(src) ? src.default : src;
        if (!staticImageData.src) {
            throw Object.defineProperty(new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received ${JSON.stringify(staticImageData)}`), "__NEXT_ERROR_CODE", {
                value: "E460",
                enumerable: false,
                configurable: true
            });
        }
        if (!staticImageData.height || !staticImageData.width) {
            throw Object.defineProperty(new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received ${JSON.stringify(staticImageData)}`), "__NEXT_ERROR_CODE", {
                value: "E48",
                enumerable: false,
                configurable: true
            });
        }
        blurWidth = staticImageData.blurWidth;
        blurHeight = staticImageData.blurHeight;
        blurDataURL = blurDataURL || staticImageData.blurDataURL;
        staticSrc = staticImageData.src;
        if (!fill) {
            if (!widthInt && !heightInt) {
                widthInt = staticImageData.width;
                heightInt = staticImageData.height;
            } else if (widthInt && !heightInt) {
                const ratio = widthInt / staticImageData.width;
                heightInt = Math.round(staticImageData.height * ratio);
            } else if (!widthInt && heightInt) {
                const ratio = heightInt / staticImageData.height;
                widthInt = Math.round(staticImageData.width * ratio);
            }
        }
    }
    src = typeof src === 'string' ? src : staticSrc;
    let isLazy = !priority && !preload && (loading === 'lazy' || typeof loading === 'undefined');
    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {
        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
        unoptimized = true;
        isLazy = false;
    }
    if (config.unoptimized) {
        unoptimized = true;
    }
    if (isDefaultLoader && !config.dangerouslyAllowSVG && src.split('?', 1)[0].endsWith('.svg')) {
        // Special case to make svg serve as-is to avoid proxying
        // through the built-in Image Optimization API.
        unoptimized = true;
    }
    const qualityInt = getInt(quality);
    if ("TURBOPACK compile-time truthy", 1) {
        if (config.output === 'export' && isDefaultLoader && !unoptimized) {
            throw Object.defineProperty(new Error(`Image Optimization using the default loader is not compatible with \`{ output: 'export' }\`.
  Possible solutions:
    - Remove \`{ output: 'export' }\` and run "next start" to run server mode including the Image Optimization API.
    - Configure \`{ images: { unoptimized: true } }\` in \`next.config.js\` to disable the Image Optimization API.
  Read more: https://nextjs.org/docs/messages/export-image-api`), "__NEXT_ERROR_CODE", {
                value: "E500",
                enumerable: false,
                configurable: true
            });
        }
        if (!src) {
            // React doesn't show the stack trace and there's
            // no `src` to help identify which image, so we
            // instead console.error(ref) during mount.
            unoptimized = true;
        } else {
            if (fill) {
                if (width) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "width" and "fill" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                        value: "E96",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (height) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "height" and "fill" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                        value: "E115",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (style?.position && style.position !== 'absolute') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "fill" and "style.position" properties. Images with "fill" always use position absolute - it cannot be modified.`), "__NEXT_ERROR_CODE", {
                        value: "E216",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (style?.width && style.width !== '100%') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "fill" and "style.width" properties. Images with "fill" always use width 100% - it cannot be modified.`), "__NEXT_ERROR_CODE", {
                        value: "E73",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (style?.height && style.height !== '100%') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "fill" and "style.height" properties. Images with "fill" always use height 100% - it cannot be modified.`), "__NEXT_ERROR_CODE", {
                        value: "E404",
                        enumerable: false,
                        configurable: true
                    });
                }
            } else {
                if (typeof widthInt === 'undefined') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" is missing required "width" property.`), "__NEXT_ERROR_CODE", {
                        value: "E451",
                        enumerable: false,
                        configurable: true
                    });
                } else if (isNaN(widthInt)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "width" property. Expected a numeric value in pixels but received "${width}".`), "__NEXT_ERROR_CODE", {
                        value: "E66",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (typeof heightInt === 'undefined') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" is missing required "height" property.`), "__NEXT_ERROR_CODE", {
                        value: "E397",
                        enumerable: false,
                        configurable: true
                    });
                } else if (isNaN(heightInt)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "height" property. Expected a numeric value in pixels but received "${height}".`), "__NEXT_ERROR_CODE", {
                        value: "E444",
                        enumerable: false,
                        configurable: true
                    });
                }
                // eslint-disable-next-line no-control-regex
                if (/^[\x00-\x20]/.test(src)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.`), "__NEXT_ERROR_CODE", {
                        value: "E176",
                        enumerable: false,
                        configurable: true
                    });
                }
                // eslint-disable-next-line no-control-regex
                if (/[\x00-\x20]$/.test(src)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.`), "__NEXT_ERROR_CODE", {
                        value: "E21",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
        if (!VALID_LOADING_VALUES.includes(loading)) {
            throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "loading" property. Provided "${loading}" should be one of ${VALID_LOADING_VALUES.map(String).join(',')}.`), "__NEXT_ERROR_CODE", {
                value: "E357",
                enumerable: false,
                configurable: true
            });
        }
        if (priority && loading === 'lazy') {
            throw Object.defineProperty(new Error(`Image with src "${src}" has both "priority" and "loading='lazy'" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                value: "E218",
                enumerable: false,
                configurable: true
            });
        }
        if (preload && loading === 'lazy') {
            throw Object.defineProperty(new Error(`Image with src "${src}" has both "preload" and "loading='lazy'" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                value: "E803",
                enumerable: false,
                configurable: true
            });
        }
        if (preload && priority) {
            throw Object.defineProperty(new Error(`Image with src "${src}" has both "preload" and "priority" properties. Only "preload" should be used.`), "__NEXT_ERROR_CODE", {
                value: "E802",
                enumerable: false,
                configurable: true
            });
        }
        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {
            throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "placeholder" property "${placeholder}".`), "__NEXT_ERROR_CODE", {
                value: "E431",
                enumerable: false,
                configurable: true
            });
        }
        if (placeholder !== 'empty') {
            if (widthInt && heightInt && widthInt * heightInt < 1600) {
                (0, _warnonce.warnOnce)(`Image with src "${src}" is smaller than 40x40. Consider removing the "placeholder" property to improve performance.`);
            }
        }
        if (qualityInt && config.qualities && !config.qualities.includes(qualityInt)) {
            (0, _warnonce.warnOnce)(`Image with src "${src}" is using quality "${qualityInt}" which is not configured in images.qualities [${config.qualities.join(', ')}]. Please update your config to [${[
                ...config.qualities,
                qualityInt
            ].sort().join(', ')}].` + `\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-qualities`);
        }
        if (placeholder === 'blur' && !blurDataURL) {
            const VALID_BLUR_EXT = [
                'jpeg',
                'png',
                'webp',
                'avif'
            ] // should match next-image-loader
            ;
            throw Object.defineProperty(new Error(`Image with src "${src}" has "placeholder='blur'" property but is missing the "blurDataURL" property.
        Possible solutions:
          - Add a "blurDataURL" property, the contents should be a small Data URL to represent the image
          - Change the "src" property to a static import with one of the supported file types: ${VALID_BLUR_EXT.join(',')} (animated images not supported)
          - Remove the "placeholder" property, effectively no blur effect
        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url`), "__NEXT_ERROR_CODE", {
                value: "E371",
                enumerable: false,
                configurable: true
            });
        }
        if ('ref' in rest) {
            (0, _warnonce.warnOnce)(`Image with src "${src}" is using unsupported "ref" property. Consider using the "onLoad" property instead.`);
        }
        if (!unoptimized && !isDefaultLoader) {
            const urlStr = loader({
                config,
                src,
                width: widthInt || 400,
                quality: qualityInt || 75
            });
            let url;
            try {
                url = new URL(urlStr);
            } catch (err) {}
            if (urlStr === src || url && url.pathname === src && !url.search) {
                (0, _warnonce.warnOnce)(`Image with src "${src}" has a "loader" property that does not implement width. Please implement it or use the "unoptimized" property instead.` + `\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width`);
            }
        }
        if (onLoadingComplete) {
            (0, _warnonce.warnOnce)(`Image with src "${src}" is using deprecated "onLoadingComplete" property. Please use the "onLoad" property instead.`);
        }
        for (const [legacyKey, legacyValue] of Object.entries({
            layout,
            objectFit,
            objectPosition,
            lazyBoundary,
            lazyRoot
        })){
            if (legacyValue) {
                (0, _warnonce.warnOnce)(`Image with src "${src}" has legacy prop "${legacyKey}". Did you forget to run the codemod?` + `\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13`);
            }
        }
        if (typeof window !== 'undefined' && !perfObserver && window.PerformanceObserver) {
            perfObserver = new PerformanceObserver((entryList)=>{
                for (const entry of entryList.getEntries()){
                    // @ts-ignore - missing "LargestContentfulPaint" class with "element" prop
                    const imgSrc = entry?.element?.src || '';
                    const lcpImage = allImgs.get(imgSrc);
                    if (lcpImage && lcpImage.loading === 'lazy' && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {
                        // https://web.dev/lcp/#measure-lcp-in-javascript
                        (0, _warnonce.warnOnce)(`Image with src "${lcpImage.src}" was detected as the Largest Contentful Paint (LCP). Please add the \`loading="eager"\` property if this image is above the fold.` + `\nRead more: https://nextjs.org/docs/app/api-reference/components/image#loading`);
                    }
                }
            });
            try {
                perfObserver.observe({
                    type: 'largest-contentful-paint',
                    buffered: true
                });
            } catch (err) {
                // Log error but don't crash the app
                console.error(err);
            }
        }
    }
    const imgStyle = Object.assign(fill ? {
        position: 'absolute',
        height: '100%',
        width: '100%',
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        objectFit,
        objectPosition
    } : {}, showAltText ? {} : {
        color: 'transparent'
    }, style);
    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? `url("data:image/svg+xml;charset=utf-8,${(0, _imageblursvg.getImageBlurSvg)({
        widthInt,
        heightInt,
        blurWidth,
        blurHeight,
        blurDataURL: blurDataURL || '',
        objectFit: imgStyle.objectFit
    })}")` : `url("${placeholder}")` // assume `data:image/`
     : null;
    const backgroundSize = !INVALID_BACKGROUND_SIZE_VALUES.includes(imgStyle.objectFit) ? imgStyle.objectFit : imgStyle.objectFit === 'fill' ? '100% 100%' // the background-size equivalent of `fill`
     : 'cover';
    let placeholderStyle = backgroundImage ? {
        backgroundSize,
        backgroundPosition: imgStyle.objectPosition || '50% 50%',
        backgroundRepeat: 'no-repeat',
        backgroundImage
    } : {};
    if ("TURBOPACK compile-time truthy", 1) {
        if (placeholderStyle.backgroundImage && placeholder === 'blur' && blurDataURL?.startsWith('/')) {
            // During `next dev`, we don't want to generate blur placeholders with webpack
            // because it can delay starting the dev server. Instead, `next-image-loader.js`
            // will inline a special url to lazily generate the blur placeholder at request time.
            placeholderStyle.backgroundImage = `url("${blurDataURL}")`;
        }
    }
    const imgAttributes = generateImgAttrs({
        config,
        src,
        unoptimized,
        width: widthInt,
        quality: qualityInt,
        sizes,
        loader
    });
    const loadingFinal = isLazy ? 'lazy' : loading;
    if ("TURBOPACK compile-time truthy", 1) {
        if (typeof window !== 'undefined') {
            let fullUrl;
            try {
                fullUrl = new URL(imgAttributes.src);
            } catch (e) {
                fullUrl = new URL(imgAttributes.src, window.location.href);
            }
            allImgs.set(fullUrl.href, {
                src,
                loading: loadingFinal,
                placeholder
            });
        }
    }
    const props = {
        ...rest,
        loading: loadingFinal,
        fetchPriority,
        width: widthInt,
        height: heightInt,
        decoding,
        className,
        style: {
            ...imgStyle,
            ...placeholderStyle
        },
        sizes: imgAttributes.sizes,
        srcSet: imgAttributes.srcSet,
        src: overrideSrc || imgAttributes.src
    };
    const meta = {
        unoptimized,
        preload: preload || priority,
        placeholder,
        fill
    };
    return {
        props,
        meta
    };
} //# sourceMappingURL=get-img-props.js.map
}),
"[project]/node_modules/next/dist/shared/lib/side-effect.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return SideEffect;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const isServer = typeof window === 'undefined';
const useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;
const useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;
function SideEffect(props) {
    const { headManager, reduceComponentsToState } = props;
    function emitChange() {
        if (headManager && headManager.mountedInstances) {
            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));
            headManager.updateHead(reduceComponentsToState(headElements));
        }
    }
    if (isServer) {
        headManager?.mountedInstances?.add(props.children);
        emitChange();
    }
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": ()=>{
            headManager?.mountedInstances?.add(props.children);
            return ({
                "SideEffect.useClientOnlyLayoutEffect": ()=>{
                    headManager?.mountedInstances?.delete(props.children);
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all
    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s
    // being rendered, we only trigger the method from the last one.
    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`
    // singleton in the layout effect pass, and actually trigger it in the effect pass.
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": ()=>{
            if (headManager) {
                headManager._pendingUpdate = emitChange;
            }
            return ({
                "SideEffect.useClientOnlyLayoutEffect": ()=>{
                    if (headManager) {
                        headManager._pendingUpdate = emitChange;
                    }
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    useClientOnlyEffect({
        "SideEffect.useClientOnlyEffect": ()=>{
            if (headManager && headManager._pendingUpdate) {
                headManager._pendingUpdate();
                headManager._pendingUpdate = null;
            }
            return ({
                "SideEffect.useClientOnlyEffect": ()=>{
                    if (headManager && headManager._pendingUpdate) {
                        headManager._pendingUpdate();
                        headManager._pendingUpdate = null;
                    }
                }
            })["SideEffect.useClientOnlyEffect"];
        }
    }["SideEffect.useClientOnlyEffect"]);
    return null;
} //# sourceMappingURL=side-effect.js.map
}),
"[project]/node_modules/next/dist/shared/lib/head.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    defaultHead: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    defaultHead: function() {
        return defaultHead;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _sideeffect = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/side-effect.js [app-client] (ecmascript)"));
const _headmanagercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js [app-client] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
function defaultHead() {
    const head = [
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            charSet: "utf-8"
        }, "charset"),
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            name: "viewport",
            content: "width=device-width"
        }, "viewport")
    ];
    return head;
}
function onlyReactElement(list, child) {
    // React children can be "string" or "number" in this case we ignore them for backwards compat
    if (typeof child === 'string' || typeof child === 'number') {
        return list;
    }
    // Adds support for React.Fragment
    if (child.type === _react.default.Fragment) {
        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{
            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
                return fragmentList;
            }
            return fragmentList.concat(fragmentChild);
        }, []));
    }
    return list.concat(child);
}
const METATYPES = [
    'name',
    'httpEquiv',
    'charSet',
    'itemProp'
];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/ function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (h)=>{
        let isUnique = true;
        let hasKey = false;
        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
            hasKey = true;
            const key = h.key.slice(h.key.indexOf('$') + 1);
            if (keys.has(key)) {
                isUnique = false;
            } else {
                keys.add(key);
            }
        }
        // eslint-disable-next-line default-case
        switch(h.type){
            case 'title':
            case 'base':
                if (tags.has(h.type)) {
                    isUnique = false;
                } else {
                    tags.add(h.type);
                }
                break;
            case 'meta':
                for(let i = 0, len = METATYPES.length; i < len; i++){
                    const metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype)) continue;
                    if (metatype === 'charSet') {
                        if (metaTypes.has(metatype)) {
                            isUnique = false;
                        } else {
                            metaTypes.add(metatype);
                        }
                    } else {
                        const category = h.props[metatype];
                        const categories = metaCategories[metatype] || new Set();
                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
                            isUnique = false;
                        } else {
                            categories.add(category);
                            metaCategories[metatype] = categories;
                        }
                    }
                }
                break;
        }
        return isUnique;
    };
}
/**
 *
 * @param headChildrenElements List of children of <Head>
 */ function reduceComponents(headChildrenElements) {
    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead().reverse()).filter(unique()).reverse().map((c, i)=>{
        const key = c.key || i;
        if ("TURBOPACK compile-time truthy", 1) {
            // omit JSON-LD structured data snippets from the warning
            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {
                const srcMessage = c.props['src'] ? `<script> tag with src="${c.props['src']}"` : `inline <script>`;
                (0, _warnonce.warnOnce)(`Do not add <script> tags using next/head (see ${srcMessage}). Use next/script instead. \nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component`);
            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {
                (0, _warnonce.warnOnce)(`Do not add stylesheets using next/head (see <link rel="stylesheet"> tag with href="${c.props['href']}"). Use Document instead. \nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component`);
            }
        }
        return /*#__PURE__*/ _react.default.cloneElement(c, {
            key
        });
    });
}
/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */ function Head({ children }) {
    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {
        reduceComponentsToState: reduceComponents,
        headManager: headManager,
        children: children
    });
}
const _default = Head;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=head.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ImageConfigContext", {
    enumerable: true,
    get: function() {
        return ImageConfigContext;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);
if ("TURBOPACK compile-time truthy", 1) {
    ImageConfigContext.displayName = 'ImageConfigContext';
} //# sourceMappingURL=image-config-context.shared-runtime.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router-context.shared-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RouterContext", {
    enumerable: true,
    get: function() {
        return RouterContext;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const RouterContext = _react.default.createContext(null);
if ("TURBOPACK compile-time truthy", 1) {
    RouterContext.displayName = 'RouterContext';
} //# sourceMappingURL=router-context.shared-runtime.js.map
}),
"[project]/node_modules/next/dist/shared/lib/find-closest-quality.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "findClosestQuality", {
    enumerable: true,
    get: function() {
        return findClosestQuality;
    }
});
function findClosestQuality(quality, config) {
    const q = quality || 75;
    if (!config?.qualities?.length) {
        return q;
    }
    return config.qualities.reduce((prev, cur)=>Math.abs(cur - q) < Math.abs(prev - q) ? cur : prev, 0);
} //# sourceMappingURL=find-closest-quality.js.map
}),
"[project]/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
(()=>{
    "use strict";
    var t = {
        170: (t, e, u)=>{
            const n = u(510);
            const isWindows = ()=>{
                if (typeof navigator !== "undefined" && navigator.platform) {
                    const t = navigator.platform.toLowerCase();
                    return t === "win32" || t === "windows";
                }
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform) {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === "win32";
                }
                return false;
            };
            function picomatch(t, e, u = false) {
                if (e && (e.windows === null || e.windows === undefined)) {
                    e = {
                        ...e,
                        windows: isWindows()
                    };
                }
                return n(t, e, u);
            }
            Object.assign(picomatch, n);
            t.exports = picomatch;
        },
        154: (t)=>{
            const e = "\\\\/";
            const u = `[^${e}]`;
            const n = "\\.";
            const o = "\\+";
            const s = "\\?";
            const r = "\\/";
            const a = "(?=.)";
            const i = "[^/]";
            const c = `(?:${r}|$)`;
            const p = `(?:^|${r})`;
            const l = `${n}{1,2}${c}`;
            const f = `(?!${n})`;
            const A = `(?!${p}${l})`;
            const _ = `(?!${n}{0,1}${c})`;
            const R = `(?!${l})`;
            const E = `[^.${r}]`;
            const h = `${i}*?`;
            const g = "/";
            const b = {
                DOT_LITERAL: n,
                PLUS_LITERAL: o,
                QMARK_LITERAL: s,
                SLASH_LITERAL: r,
                ONE_CHAR: a,
                QMARK: i,
                END_ANCHOR: c,
                DOTS_SLASH: l,
                NO_DOT: f,
                NO_DOTS: A,
                NO_DOT_SLASH: _,
                NO_DOTS_SLASH: R,
                QMARK_NO_DOT: E,
                STAR: h,
                START_ANCHOR: p,
                SEP: g
            };
            const C = {
                ...b,
                SLASH_LITERAL: `[${e}]`,
                QMARK: u,
                STAR: `${u}*?`,
                DOTS_SLASH: `${n}{1,2}(?:[${e}]|$)`,
                NO_DOT: `(?!${n})`,
                NO_DOTS: `(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,
                NO_DOT_SLASH: `(?!${n}{0,1}(?:[${e}]|$))`,
                NO_DOTS_SLASH: `(?!${n}{1,2}(?:[${e}]|$))`,
                QMARK_NO_DOT: `[^.${e}]`,
                START_ANCHOR: `(?:^|[${e}])`,
                END_ANCHOR: `(?:[${e}]|$)`,
                SEP: "\\"
            };
            const y = {
                alnum: "a-zA-Z0-9",
                alpha: "a-zA-Z",
                ascii: "\\x00-\\x7F",
                blank: " \\t",
                cntrl: "\\x00-\\x1F\\x7F",
                digit: "0-9",
                graph: "\\x21-\\x7E",
                lower: "a-z",
                print: "\\x20-\\x7E ",
                punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
                space: " \\t\\r\\n\\v\\f",
                upper: "A-Z",
                word: "A-Za-z0-9_",
                xdigit: "A-Fa-f0-9"
            };
            t.exports = {
                MAX_LENGTH: 1024 * 64,
                POSIX_REGEX_SOURCE: y,
                REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
                REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
                REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
                REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
                REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
                REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
                REPLACEMENTS: {
                    "***": "*",
                    "**/**": "**",
                    "**/**/**": "**"
                },
                CHAR_0: 48,
                CHAR_9: 57,
                CHAR_UPPERCASE_A: 65,
                CHAR_LOWERCASE_A: 97,
                CHAR_UPPERCASE_Z: 90,
                CHAR_LOWERCASE_Z: 122,
                CHAR_LEFT_PARENTHESES: 40,
                CHAR_RIGHT_PARENTHESES: 41,
                CHAR_ASTERISK: 42,
                CHAR_AMPERSAND: 38,
                CHAR_AT: 64,
                CHAR_BACKWARD_SLASH: 92,
                CHAR_CARRIAGE_RETURN: 13,
                CHAR_CIRCUMFLEX_ACCENT: 94,
                CHAR_COLON: 58,
                CHAR_COMMA: 44,
                CHAR_DOT: 46,
                CHAR_DOUBLE_QUOTE: 34,
                CHAR_EQUAL: 61,
                CHAR_EXCLAMATION_MARK: 33,
                CHAR_FORM_FEED: 12,
                CHAR_FORWARD_SLASH: 47,
                CHAR_GRAVE_ACCENT: 96,
                CHAR_HASH: 35,
                CHAR_HYPHEN_MINUS: 45,
                CHAR_LEFT_ANGLE_BRACKET: 60,
                CHAR_LEFT_CURLY_BRACE: 123,
                CHAR_LEFT_SQUARE_BRACKET: 91,
                CHAR_LINE_FEED: 10,
                CHAR_NO_BREAK_SPACE: 160,
                CHAR_PERCENT: 37,
                CHAR_PLUS: 43,
                CHAR_QUESTION_MARK: 63,
                CHAR_RIGHT_ANGLE_BRACKET: 62,
                CHAR_RIGHT_CURLY_BRACE: 125,
                CHAR_RIGHT_SQUARE_BRACKET: 93,
                CHAR_SEMICOLON: 59,
                CHAR_SINGLE_QUOTE: 39,
                CHAR_SPACE: 32,
                CHAR_TAB: 9,
                CHAR_UNDERSCORE: 95,
                CHAR_VERTICAL_LINE: 124,
                CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
                extglobChars (t) {
                    return {
                        "!": {
                            type: "negate",
                            open: "(?:(?!(?:",
                            close: `))${t.STAR})`
                        },
                        "?": {
                            type: "qmark",
                            open: "(?:",
                            close: ")?"
                        },
                        "+": {
                            type: "plus",
                            open: "(?:",
                            close: ")+"
                        },
                        "*": {
                            type: "star",
                            open: "(?:",
                            close: ")*"
                        },
                        "@": {
                            type: "at",
                            open: "(?:",
                            close: ")"
                        }
                    };
                },
                globChars (t) {
                    return t === true ? C : b;
                }
            };
        },
        697: (t, e, u)=>{
            const n = u(154);
            const o = u(96);
            const { MAX_LENGTH: s, POSIX_REGEX_SOURCE: r, REGEX_NON_SPECIAL_CHARS: a, REGEX_SPECIAL_CHARS_BACKREF: i, REPLACEMENTS: c } = n;
            const expandRange = (t, e)=>{
                if (typeof e.expandRange === "function") {
                    return e.expandRange(...t, e);
                }
                t.sort();
                const u = `[${t.join("-")}]`;
                try {
                    new RegExp(u);
                } catch (e) {
                    return t.map((t)=>o.escapeRegex(t)).join("..");
                }
                return u;
            };
            const syntaxError = (t, e)=>`Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`;
            const parse = (t, e)=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected a string");
                }
                t = c[t] || t;
                const u = {
                    ...e
                };
                const p = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                let l = t.length;
                if (l > p) {
                    throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`);
                }
                const f = {
                    type: "bos",
                    value: "",
                    output: u.prepend || ""
                };
                const A = [
                    f
                ];
                const _ = u.capture ? "" : "?:";
                const R = n.globChars(u.windows);
                const E = n.extglobChars(R);
                const { DOT_LITERAL: h, PLUS_LITERAL: g, SLASH_LITERAL: b, ONE_CHAR: C, DOTS_SLASH: y, NO_DOT: $, NO_DOT_SLASH: x, NO_DOTS_SLASH: S, QMARK: H, QMARK_NO_DOT: v, STAR: d, START_ANCHOR: L } = R;
                const globstar = (t)=>`(${_}(?:(?!${L}${t.dot ? y : h}).)*?)`;
                const T = u.dot ? "" : $;
                const O = u.dot ? H : v;
                let k = u.bash === true ? globstar(u) : d;
                if (u.capture) {
                    k = `(${k})`;
                }
                if (typeof u.noext === "boolean") {
                    u.noextglob = u.noext;
                }
                const m = {
                    input: t,
                    index: -1,
                    start: 0,
                    dot: u.dot === true,
                    consumed: "",
                    output: "",
                    prefix: "",
                    backtrack: false,
                    negated: false,
                    brackets: 0,
                    braces: 0,
                    parens: 0,
                    quotes: 0,
                    globstar: false,
                    tokens: A
                };
                t = o.removePrefix(t, m);
                l = t.length;
                const w = [];
                const N = [];
                const I = [];
                let B = f;
                let G;
                const eos = ()=>m.index === l - 1;
                const D = m.peek = (e = 1)=>t[m.index + e];
                const M = m.advance = ()=>t[++m.index] || "";
                const remaining = ()=>t.slice(m.index + 1);
                const consume = (t = "", e = 0)=>{
                    m.consumed += t;
                    m.index += e;
                };
                const append = (t)=>{
                    m.output += t.output != null ? t.output : t.value;
                    consume(t.value);
                };
                const negate = ()=>{
                    let t = 1;
                    while(D() === "!" && (D(2) !== "(" || D(3) === "?")){
                        M();
                        m.start++;
                        t++;
                    }
                    if (t % 2 === 0) {
                        return false;
                    }
                    m.negated = true;
                    m.start++;
                    return true;
                };
                const increment = (t)=>{
                    m[t]++;
                    I.push(t);
                };
                const decrement = (t)=>{
                    m[t]--;
                    I.pop();
                };
                const push = (t)=>{
                    if (B.type === "globstar") {
                        const e = m.braces > 0 && (t.type === "comma" || t.type === "brace");
                        const u = t.extglob === true || w.length && (t.type === "pipe" || t.type === "paren");
                        if (t.type !== "slash" && t.type !== "paren" && !e && !u) {
                            m.output = m.output.slice(0, -B.output.length);
                            B.type = "star";
                            B.value = "*";
                            B.output = k;
                            m.output += B.output;
                        }
                    }
                    if (w.length && t.type !== "paren") {
                        w[w.length - 1].inner += t.value;
                    }
                    if (t.value || t.output) append(t);
                    if (B && B.type === "text" && t.type === "text") {
                        B.output = (B.output || B.value) + t.value;
                        B.value += t.value;
                        return;
                    }
                    t.prev = B;
                    A.push(t);
                    B = t;
                };
                const extglobOpen = (t, e)=>{
                    const n = {
                        ...E[e],
                        conditions: 1,
                        inner: ""
                    };
                    n.prev = B;
                    n.parens = m.parens;
                    n.output = m.output;
                    const o = (u.capture ? "(" : "") + n.open;
                    increment("parens");
                    push({
                        type: t,
                        value: e,
                        output: m.output ? "" : C
                    });
                    push({
                        type: "paren",
                        extglob: true,
                        value: M(),
                        output: o
                    });
                    w.push(n);
                };
                const extglobClose = (t)=>{
                    let n = t.close + (u.capture ? ")" : "");
                    let o;
                    if (t.type === "negate") {
                        let s = k;
                        if (t.inner && t.inner.length > 1 && t.inner.includes("/")) {
                            s = globstar(u);
                        }
                        if (s !== k || eos() || /^\)+$/.test(remaining())) {
                            n = t.close = `)$))${s}`;
                        }
                        if (t.inner.includes("*") && (o = remaining()) && /^\.[^\\/.]+$/.test(o)) {
                            const u = parse(o, {
                                ...e,
                                fastpaths: false
                            }).output;
                            n = t.close = `)${u})${s})`;
                        }
                        if (t.prev.type === "bos") {
                            m.negatedExtglob = true;
                        }
                    }
                    push({
                        type: "paren",
                        extglob: true,
                        value: G,
                        output: n
                    });
                    decrement("parens");
                };
                if (u.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(t)) {
                    let n = false;
                    let s = t.replace(i, (t, e, u, o, s, r)=>{
                        if (o === "\\") {
                            n = true;
                            return t;
                        }
                        if (o === "?") {
                            if (e) {
                                return e + o + (s ? H.repeat(s.length) : "");
                            }
                            if (r === 0) {
                                return O + (s ? H.repeat(s.length) : "");
                            }
                            return H.repeat(u.length);
                        }
                        if (o === ".") {
                            return h.repeat(u.length);
                        }
                        if (o === "*") {
                            if (e) {
                                return e + o + (s ? k : "");
                            }
                            return k;
                        }
                        return e ? t : `\\${t}`;
                    });
                    if (n === true) {
                        if (u.unescape === true) {
                            s = s.replace(/\\/g, "");
                        } else {
                            s = s.replace(/\\+/g, (t)=>t.length % 2 === 0 ? "\\\\" : t ? "\\" : "");
                        }
                    }
                    if (s === t && u.contains === true) {
                        m.output = t;
                        return m;
                    }
                    m.output = o.wrapOutput(s, m, e);
                    return m;
                }
                while(!eos()){
                    G = M();
                    if (G === "\0") {
                        continue;
                    }
                    if (G === "\\") {
                        const t = D();
                        if (t === "/" && u.bash !== true) {
                            continue;
                        }
                        if (t === "." || t === ";") {
                            continue;
                        }
                        if (!t) {
                            G += "\\";
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                        const e = /^\\+/.exec(remaining());
                        let n = 0;
                        if (e && e[0].length > 2) {
                            n = e[0].length;
                            m.index += n;
                            if (n % 2 !== 0) {
                                G += "\\";
                            }
                        }
                        if (u.unescape === true) {
                            G = M();
                        } else {
                            G += M();
                        }
                        if (m.brackets === 0) {
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                    }
                    if (m.brackets > 0 && (G !== "]" || B.value === "[" || B.value === "[^")) {
                        if (u.posix !== false && G === ":") {
                            const t = B.value.slice(1);
                            if (t.includes("[")) {
                                B.posix = true;
                                if (t.includes(":")) {
                                    const t = B.value.lastIndexOf("[");
                                    const e = B.value.slice(0, t);
                                    const u = B.value.slice(t + 2);
                                    const n = r[u];
                                    if (n) {
                                        B.value = e + n;
                                        m.backtrack = true;
                                        M();
                                        if (!f.output && A.indexOf(B) === 1) {
                                            f.output = C;
                                        }
                                        continue;
                                    }
                                }
                            }
                        }
                        if (G === "[" && D() !== ":" || G === "-" && D() === "]") {
                            G = `\\${G}`;
                        }
                        if (G === "]" && (B.value === "[" || B.value === "[^")) {
                            G = `\\${G}`;
                        }
                        if (u.posix === true && G === "!" && B.value === "[") {
                            G = "^";
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (m.quotes === 1 && G !== '"') {
                        G = o.escapeRegex(G);
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (G === '"') {
                        m.quotes = m.quotes === 1 ? 0 : 1;
                        if (u.keepQuotes === true) {
                            push({
                                type: "text",
                                value: G
                            });
                        }
                        continue;
                    }
                    if (G === "(") {
                        increment("parens");
                        push({
                            type: "paren",
                            value: G
                        });
                        continue;
                    }
                    if (G === ")") {
                        if (m.parens === 0 && u.strictBrackets === true) {
                            throw new SyntaxError(syntaxError("opening", "("));
                        }
                        const t = w[w.length - 1];
                        if (t && m.parens === t.parens + 1) {
                            extglobClose(w.pop());
                            continue;
                        }
                        push({
                            type: "paren",
                            value: G,
                            output: m.parens ? ")" : "\\)"
                        });
                        decrement("parens");
                        continue;
                    }
                    if (G === "[") {
                        if (u.nobracket === true || !remaining().includes("]")) {
                            if (u.nobracket !== true && u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("closing", "]"));
                            }
                            G = `\\${G}`;
                        } else {
                            increment("brackets");
                        }
                        push({
                            type: "bracket",
                            value: G
                        });
                        continue;
                    }
                    if (G === "]") {
                        if (u.nobracket === true || B && B.type === "bracket" && B.value.length === 1) {
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        if (m.brackets === 0) {
                            if (u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("opening", "["));
                            }
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        decrement("brackets");
                        const t = B.value.slice(1);
                        if (B.posix !== true && t[0] === "^" && !t.includes("/")) {
                            G = `/${G}`;
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        if (u.literalBrackets === false || o.hasRegexChars(t)) {
                            continue;
                        }
                        const e = o.escapeRegex(B.value);
                        m.output = m.output.slice(0, -B.value.length);
                        if (u.literalBrackets === true) {
                            m.output += e;
                            B.value = e;
                            continue;
                        }
                        B.value = `(${_}${e}|${B.value})`;
                        m.output += B.value;
                        continue;
                    }
                    if (G === "{" && u.nobrace !== true) {
                        increment("braces");
                        const t = {
                            type: "brace",
                            value: G,
                            output: "(",
                            outputIndex: m.output.length,
                            tokensIndex: m.tokens.length
                        };
                        N.push(t);
                        push(t);
                        continue;
                    }
                    if (G === "}") {
                        const t = N[N.length - 1];
                        if (u.nobrace === true || !t) {
                            push({
                                type: "text",
                                value: G,
                                output: G
                            });
                            continue;
                        }
                        let e = ")";
                        if (t.dots === true) {
                            const t = A.slice();
                            const n = [];
                            for(let e = t.length - 1; e >= 0; e--){
                                A.pop();
                                if (t[e].type === "brace") {
                                    break;
                                }
                                if (t[e].type !== "dots") {
                                    n.unshift(t[e].value);
                                }
                            }
                            e = expandRange(n, u);
                            m.backtrack = true;
                        }
                        if (t.comma !== true && t.dots !== true) {
                            const u = m.output.slice(0, t.outputIndex);
                            const n = m.tokens.slice(t.tokensIndex);
                            t.value = t.output = "\\{";
                            G = e = "\\}";
                            m.output = u;
                            for (const t of n){
                                m.output += t.output || t.value;
                            }
                        }
                        push({
                            type: "brace",
                            value: G,
                            output: e
                        });
                        decrement("braces");
                        N.pop();
                        continue;
                    }
                    if (G === "|") {
                        if (w.length > 0) {
                            w[w.length - 1].conditions++;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G === ",") {
                        let t = G;
                        const e = N[N.length - 1];
                        if (e && I[I.length - 1] === "braces") {
                            e.comma = true;
                            t = "|";
                        }
                        push({
                            type: "comma",
                            value: G,
                            output: t
                        });
                        continue;
                    }
                    if (G === "/") {
                        if (B.type === "dot" && m.index === m.start + 1) {
                            m.start = m.index + 1;
                            m.consumed = "";
                            m.output = "";
                            A.pop();
                            B = f;
                            continue;
                        }
                        push({
                            type: "slash",
                            value: G,
                            output: b
                        });
                        continue;
                    }
                    if (G === ".") {
                        if (m.braces > 0 && B.type === "dot") {
                            if (B.value === ".") B.output = h;
                            const t = N[N.length - 1];
                            B.type = "dots";
                            B.output += G;
                            B.value += G;
                            t.dots = true;
                            continue;
                        }
                        if (m.braces + m.parens === 0 && B.type !== "bos" && B.type !== "slash") {
                            push({
                                type: "text",
                                value: G,
                                output: h
                            });
                            continue;
                        }
                        push({
                            type: "dot",
                            value: G,
                            output: h
                        });
                        continue;
                    }
                    if (G === "?") {
                        const t = B && B.value === "(";
                        if (!t && u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("qmark", G);
                            continue;
                        }
                        if (B && B.type === "paren") {
                            const t = D();
                            let e = G;
                            if (B.value === "(" && !/[!=<:]/.test(t) || t === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                                e = `\\${G}`;
                            }
                            push({
                                type: "text",
                                value: G,
                                output: e
                            });
                            continue;
                        }
                        if (u.dot !== true && (B.type === "slash" || B.type === "bos")) {
                            push({
                                type: "qmark",
                                value: G,
                                output: v
                            });
                            continue;
                        }
                        push({
                            type: "qmark",
                            value: G,
                            output: H
                        });
                        continue;
                    }
                    if (G === "!") {
                        if (u.noextglob !== true && D() === "(") {
                            if (D(2) !== "?" || !/[!=<:]/.test(D(3))) {
                                extglobOpen("negate", G);
                                continue;
                            }
                        }
                        if (u.nonegate !== true && m.index === 0) {
                            negate();
                            continue;
                        }
                    }
                    if (G === "+") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("plus", G);
                            continue;
                        }
                        if (B && B.value === "(" || u.regex === false) {
                            push({
                                type: "plus",
                                value: G,
                                output: g
                            });
                            continue;
                        }
                        if (B && (B.type === "bracket" || B.type === "paren" || B.type === "brace") || m.parens > 0) {
                            push({
                                type: "plus",
                                value: G
                            });
                            continue;
                        }
                        push({
                            type: "plus",
                            value: g
                        });
                        continue;
                    }
                    if (G === "@") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            push({
                                type: "at",
                                extglob: true,
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G !== "*") {
                        if (G === "$" || G === "^") {
                            G = `\\${G}`;
                        }
                        const t = a.exec(remaining());
                        if (t) {
                            G += t[0];
                            m.index += t[0].length;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (B && (B.type === "globstar" || B.star === true)) {
                        B.type = "star";
                        B.star = true;
                        B.value += G;
                        B.output = k;
                        m.backtrack = true;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    let e = remaining();
                    if (u.noextglob !== true && /^\([^?]/.test(e)) {
                        extglobOpen("star", G);
                        continue;
                    }
                    if (B.type === "star") {
                        if (u.noglobstar === true) {
                            consume(G);
                            continue;
                        }
                        const n = B.prev;
                        const o = n.prev;
                        const s = n.type === "slash" || n.type === "bos";
                        const r = o && (o.type === "star" || o.type === "globstar");
                        if (u.bash === true && (!s || e[0] && e[0] !== "/")) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        const a = m.braces > 0 && (n.type === "comma" || n.type === "brace");
                        const i = w.length && (n.type === "pipe" || n.type === "paren");
                        if (!s && n.type !== "paren" && !a && !i) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        while(e.slice(0, 3) === "/**"){
                            const u = t[m.index + 4];
                            if (u && u !== "/") {
                                break;
                            }
                            e = e.slice(3);
                            consume("/**", 3);
                        }
                        if (n.type === "bos" && eos()) {
                            B.type = "globstar";
                            B.value += G;
                            B.output = globstar(u);
                            m.output = B.output;
                            m.globstar = true;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && !r && eos()) {
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = globstar(u) + (u.strictSlashes ? ")" : "|$)");
                            B.value += G;
                            m.globstar = true;
                            m.output += n.output + B.output;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && e[0] === "/") {
                            const t = e[1] !== void 0 ? "|$" : "";
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = `${globstar(u)}${b}|${b}${t})`;
                            B.value += G;
                            m.output += n.output + B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        if (n.type === "bos" && e[0] === "/") {
                            B.type = "globstar";
                            B.value += G;
                            B.output = `(?:^|${b}|${globstar(u)}${b})`;
                            m.output = B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        m.output = m.output.slice(0, -B.output.length);
                        B.type = "globstar";
                        B.output = globstar(u);
                        B.value += G;
                        m.output += B.output;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    const n = {
                        type: "star",
                        value: G,
                        output: k
                    };
                    if (u.bash === true) {
                        n.output = ".*?";
                        if (B.type === "bos" || B.type === "slash") {
                            n.output = T + n.output;
                        }
                        push(n);
                        continue;
                    }
                    if (B && (B.type === "bracket" || B.type === "paren") && u.regex === true) {
                        n.output = G;
                        push(n);
                        continue;
                    }
                    if (m.index === m.start || B.type === "slash" || B.type === "dot") {
                        if (B.type === "dot") {
                            m.output += x;
                            B.output += x;
                        } else if (u.dot === true) {
                            m.output += S;
                            B.output += S;
                        } else {
                            m.output += T;
                            B.output += T;
                        }
                        if (D() !== "*") {
                            m.output += C;
                            B.output += C;
                        }
                    }
                    push(n);
                }
                while(m.brackets > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
                    m.output = o.escapeLast(m.output, "[");
                    decrement("brackets");
                }
                while(m.parens > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
                    m.output = o.escapeLast(m.output, "(");
                    decrement("parens");
                }
                while(m.braces > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
                    m.output = o.escapeLast(m.output, "{");
                    decrement("braces");
                }
                if (u.strictSlashes !== true && (B.type === "star" || B.type === "bracket")) {
                    push({
                        type: "maybe_slash",
                        value: "",
                        output: `${b}?`
                    });
                }
                if (m.backtrack === true) {
                    m.output = "";
                    for (const t of m.tokens){
                        m.output += t.output != null ? t.output : t.value;
                        if (t.suffix) {
                            m.output += t.suffix;
                        }
                    }
                }
                return m;
            };
            parse.fastpaths = (t, e)=>{
                const u = {
                    ...e
                };
                const r = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                const a = t.length;
                if (a > r) {
                    throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`);
                }
                t = c[t] || t;
                const { DOT_LITERAL: i, SLASH_LITERAL: p, ONE_CHAR: l, DOTS_SLASH: f, NO_DOT: A, NO_DOTS: _, NO_DOTS_SLASH: R, STAR: E, START_ANCHOR: h } = n.globChars(u.windows);
                const g = u.dot ? _ : A;
                const b = u.dot ? R : A;
                const C = u.capture ? "" : "?:";
                const y = {
                    negated: false,
                    prefix: ""
                };
                let $ = u.bash === true ? ".*?" : E;
                if (u.capture) {
                    $ = `(${$})`;
                }
                const globstar = (t)=>{
                    if (t.noglobstar === true) return $;
                    return `(${C}(?:(?!${h}${t.dot ? f : i}).)*?)`;
                };
                const create = (t)=>{
                    switch(t){
                        case "*":
                            return `${g}${l}${$}`;
                        case ".*":
                            return `${i}${l}${$}`;
                        case "*.*":
                            return `${g}${$}${i}${l}${$}`;
                        case "*/*":
                            return `${g}${$}${p}${l}${b}${$}`;
                        case "**":
                            return g + globstar(u);
                        case "**/*":
                            return `(?:${g}${globstar(u)}${p})?${b}${l}${$}`;
                        case "**/*.*":
                            return `(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;
                        case "**/.*":
                            return `(?:${g}${globstar(u)}${p})?${i}${l}${$}`;
                        default:
                            {
                                const e = /^(.*?)\.(\w+)$/.exec(t);
                                if (!e) return;
                                const u = create(e[1]);
                                if (!u) return;
                                return u + i + e[2];
                            }
                    }
                };
                const x = o.removePrefix(t, y);
                let S = create(x);
                if (S && u.strictSlashes !== true) {
                    S += `${p}?`;
                }
                return S;
            };
            t.exports = parse;
        },
        510: (t, e, u)=>{
            const n = u(716);
            const o = u(697);
            const s = u(96);
            const r = u(154);
            const isObject = (t)=>t && typeof t === "object" && !Array.isArray(t);
            const picomatch = (t, e, u = false)=>{
                if (Array.isArray(t)) {
                    const n = t.map((t)=>picomatch(t, e, u));
                    const arrayMatcher = (t)=>{
                        for (const e of n){
                            const u = e(t);
                            if (u) return u;
                        }
                        return false;
                    };
                    return arrayMatcher;
                }
                const n = isObject(t) && t.tokens && t.input;
                if (t === "" || typeof t !== "string" && !n) {
                    throw new TypeError("Expected pattern to be a non-empty string");
                }
                const o = e || {};
                const s = o.windows;
                const r = n ? picomatch.compileRe(t, e) : picomatch.makeRe(t, e, false, true);
                const a = r.state;
                delete r.state;
                let isIgnored = ()=>false;
                if (o.ignore) {
                    const t = {
                        ...e,
                        ignore: null,
                        onMatch: null,
                        onResult: null
                    };
                    isIgnored = picomatch(o.ignore, t, u);
                }
                const matcher = (u, n = false)=>{
                    const { isMatch: i, match: c, output: p } = picomatch.test(u, r, e, {
                        glob: t,
                        posix: s
                    });
                    const l = {
                        glob: t,
                        state: a,
                        regex: r,
                        posix: s,
                        input: u,
                        output: p,
                        match: c,
                        isMatch: i
                    };
                    if (typeof o.onResult === "function") {
                        o.onResult(l);
                    }
                    if (i === false) {
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (isIgnored(u)) {
                        if (typeof o.onIgnore === "function") {
                            o.onIgnore(l);
                        }
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (typeof o.onMatch === "function") {
                        o.onMatch(l);
                    }
                    return n ? l : true;
                };
                if (u) {
                    matcher.state = a;
                }
                return matcher;
            };
            picomatch.test = (t, e, u, { glob: n, posix: o } = {})=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected input to be a string");
                }
                if (t === "") {
                    return {
                        isMatch: false,
                        output: ""
                    };
                }
                const r = u || {};
                const a = r.format || (o ? s.toPosixSlashes : null);
                let i = t === n;
                let c = i && a ? a(t) : t;
                if (i === false) {
                    c = a ? a(t) : t;
                    i = c === n;
                }
                if (i === false || r.capture === true) {
                    if (r.matchBase === true || r.basename === true) {
                        i = picomatch.matchBase(t, e, u, o);
                    } else {
                        i = e.exec(c);
                    }
                }
                return {
                    isMatch: Boolean(i),
                    match: i,
                    output: c
                };
            };
            picomatch.matchBase = (t, e, u)=>{
                const n = e instanceof RegExp ? e : picomatch.makeRe(e, u);
                return n.test(s.basename(t));
            };
            picomatch.isMatch = (t, e, u)=>picomatch(e, u)(t);
            picomatch.parse = (t, e)=>{
                if (Array.isArray(t)) return t.map((t)=>picomatch.parse(t, e));
                return o(t, {
                    ...e,
                    fastpaths: false
                });
            };
            picomatch.scan = (t, e)=>n(t, e);
            picomatch.compileRe = (t, e, u = false, n = false)=>{
                if (u === true) {
                    return t.output;
                }
                const o = e || {};
                const s = o.contains ? "" : "^";
                const r = o.contains ? "" : "$";
                let a = `${s}(?:${t.output})${r}`;
                if (t && t.negated === true) {
                    a = `^(?!${a}).*$`;
                }
                const i = picomatch.toRegex(a, e);
                if (n === true) {
                    i.state = t;
                }
                return i;
            };
            picomatch.makeRe = (t, e = {}, u = false, n = false)=>{
                if (!t || typeof t !== "string") {
                    throw new TypeError("Expected a non-empty string");
                }
                let s = {
                    negated: false,
                    fastpaths: true
                };
                if (e.fastpaths !== false && (t[0] === "." || t[0] === "*")) {
                    s.output = o.fastpaths(t, e);
                }
                if (!s.output) {
                    s = o(t, e);
                }
                return picomatch.compileRe(s, e, u, n);
            };
            picomatch.toRegex = (t, e)=>{
                try {
                    const u = e || {};
                    return new RegExp(t, u.flags || (u.nocase ? "i" : ""));
                } catch (t) {
                    if (e && e.debug === true) throw t;
                    return /$^/;
                }
            };
            picomatch.constants = r;
            t.exports = picomatch;
        },
        716: (t, e, u)=>{
            const n = u(96);
            const { CHAR_ASTERISK: o, CHAR_AT: s, CHAR_BACKWARD_SLASH: r, CHAR_COMMA: a, CHAR_DOT: i, CHAR_EXCLAMATION_MARK: c, CHAR_FORWARD_SLASH: p, CHAR_LEFT_CURLY_BRACE: l, CHAR_LEFT_PARENTHESES: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_PLUS: _, CHAR_QUESTION_MARK: R, CHAR_RIGHT_CURLY_BRACE: E, CHAR_RIGHT_PARENTHESES: h, CHAR_RIGHT_SQUARE_BRACKET: g } = u(154);
            const isPathSeparator = (t)=>t === p || t === r;
            const depth = (t)=>{
                if (t.isPrefix !== true) {
                    t.depth = t.isGlobstar ? Infinity : 1;
                }
            };
            const scan = (t, e)=>{
                const u = e || {};
                const b = t.length - 1;
                const C = u.parts === true || u.scanToEnd === true;
                const y = [];
                const $ = [];
                const x = [];
                let S = t;
                let H = -1;
                let v = 0;
                let d = 0;
                let L = false;
                let T = false;
                let O = false;
                let k = false;
                let m = false;
                let w = false;
                let N = false;
                let I = false;
                let B = false;
                let G = false;
                let D = 0;
                let M;
                let P;
                let K = {
                    value: "",
                    depth: 0,
                    isGlob: false
                };
                const eos = ()=>H >= b;
                const peek = ()=>S.charCodeAt(H + 1);
                const advance = ()=>{
                    M = P;
                    return S.charCodeAt(++H);
                };
                while(H < b){
                    P = advance();
                    let t;
                    if (P === r) {
                        N = K.backslashes = true;
                        P = advance();
                        if (P === l) {
                            w = true;
                        }
                        continue;
                    }
                    if (w === true || P === l) {
                        D++;
                        while(eos() !== true && (P = advance())){
                            if (P === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (P === l) {
                                D++;
                                continue;
                            }
                            if (w !== true && P === i && (P = advance()) === i) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (w !== true && P === a) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (P === E) {
                                D--;
                                if (D === 0) {
                                    w = false;
                                    L = K.isBrace = true;
                                    G = true;
                                    break;
                                }
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === p) {
                        y.push(H);
                        $.push(K);
                        K = {
                            value: "",
                            depth: 0,
                            isGlob: false
                        };
                        if (G === true) continue;
                        if (M === i && H === v + 1) {
                            v += 2;
                            continue;
                        }
                        d = H + 1;
                        continue;
                    }
                    if (u.noext !== true) {
                        const t = P === _ || P === s || P === o || P === R || P === c;
                        if (t === true && peek() === f) {
                            O = K.isGlob = true;
                            k = K.isExtglob = true;
                            G = true;
                            if (P === c && H === v) {
                                B = true;
                            }
                            if (C === true) {
                                while(eos() !== true && (P = advance())){
                                    if (P === r) {
                                        N = K.backslashes = true;
                                        P = advance();
                                        continue;
                                    }
                                    if (P === h) {
                                        O = K.isGlob = true;
                                        G = true;
                                        break;
                                    }
                                }
                                continue;
                            }
                            break;
                        }
                    }
                    if (P === o) {
                        if (M === o) m = K.isGlobstar = true;
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === R) {
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === A) {
                        while(eos() !== true && (t = advance())){
                            if (t === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (t === g) {
                                T = K.isBracket = true;
                                O = K.isGlob = true;
                                G = true;
                                break;
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (u.nonegate !== true && P === c && H === v) {
                        I = K.negated = true;
                        v++;
                        continue;
                    }
                    if (u.noparen !== true && P === f) {
                        O = K.isGlob = true;
                        if (C === true) {
                            while(eos() !== true && (P = advance())){
                                if (P === f) {
                                    N = K.backslashes = true;
                                    P = advance();
                                    continue;
                                }
                                if (P === h) {
                                    G = true;
                                    break;
                                }
                            }
                            continue;
                        }
                        break;
                    }
                    if (O === true) {
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                }
                if (u.noext === true) {
                    k = false;
                    O = false;
                }
                let U = S;
                let X = "";
                let F = "";
                if (v > 0) {
                    X = S.slice(0, v);
                    S = S.slice(v);
                    d -= v;
                }
                if (U && O === true && d > 0) {
                    U = S.slice(0, d);
                    F = S.slice(d);
                } else if (O === true) {
                    U = "";
                    F = S;
                } else {
                    U = S;
                }
                if (U && U !== "" && U !== "/" && U !== S) {
                    if (isPathSeparator(U.charCodeAt(U.length - 1))) {
                        U = U.slice(0, -1);
                    }
                }
                if (u.unescape === true) {
                    if (F) F = n.removeBackslashes(F);
                    if (U && N === true) {
                        U = n.removeBackslashes(U);
                    }
                }
                const Q = {
                    prefix: X,
                    input: t,
                    start: v,
                    base: U,
                    glob: F,
                    isBrace: L,
                    isBracket: T,
                    isGlob: O,
                    isExtglob: k,
                    isGlobstar: m,
                    negated: I,
                    negatedExtglob: B
                };
                if (u.tokens === true) {
                    Q.maxDepth = 0;
                    if (!isPathSeparator(P)) {
                        $.push(K);
                    }
                    Q.tokens = $;
                }
                if (u.parts === true || u.tokens === true) {
                    let e;
                    for(let n = 0; n < y.length; n++){
                        const o = e ? e + 1 : v;
                        const s = y[n];
                        const r = t.slice(o, s);
                        if (u.tokens) {
                            if (n === 0 && v !== 0) {
                                $[n].isPrefix = true;
                                $[n].value = X;
                            } else {
                                $[n].value = r;
                            }
                            depth($[n]);
                            Q.maxDepth += $[n].depth;
                        }
                        if (n !== 0 || r !== "") {
                            x.push(r);
                        }
                        e = s;
                    }
                    if (e && e + 1 < t.length) {
                        const n = t.slice(e + 1);
                        x.push(n);
                        if (u.tokens) {
                            $[$.length - 1].value = n;
                            depth($[$.length - 1]);
                            Q.maxDepth += $[$.length - 1].depth;
                        }
                    }
                    Q.slashes = y;
                    Q.parts = x;
                }
                return Q;
            };
            t.exports = scan;
        },
        96: (t, e, u)=>{
            const { REGEX_BACKSLASH: n, REGEX_REMOVE_BACKSLASH: o, REGEX_SPECIAL_CHARS: s, REGEX_SPECIAL_CHARS_GLOBAL: r } = u(154);
            e.isObject = (t)=>t !== null && typeof t === "object" && !Array.isArray(t);
            e.hasRegexChars = (t)=>s.test(t);
            e.isRegexChar = (t)=>t.length === 1 && e.hasRegexChars(t);
            e.escapeRegex = (t)=>t.replace(r, "\\$1");
            e.toPosixSlashes = (t)=>t.replace(n, "/");
            e.removeBackslashes = (t)=>t.replace(o, (t)=>t === "\\" ? "" : t);
            e.escapeLast = (t, u, n)=>{
                const o = t.lastIndexOf(u, n);
                if (o === -1) return t;
                if (t[o - 1] === "\\") return e.escapeLast(t, u, o - 1);
                return `${t.slice(0, o)}\\${t.slice(o)}`;
            };
            e.removePrefix = (t, e = {})=>{
                let u = t;
                if (u.startsWith("./")) {
                    u = u.slice(2);
                    e.prefix = "./";
                }
                return u;
            };
            e.wrapOutput = (t, e = {}, u = {})=>{
                const n = u.contains ? "" : "^";
                const o = u.contains ? "" : "$";
                let s = `${n}(?:${t})${o}`;
                if (e.negated === true) {
                    s = `(?:^(?!${s}).*$)`;
                }
                return s;
            };
            e.basename = (t, { windows: e } = {})=>{
                const u = t.split(e ? /[\\/]/ : "/");
                const n = u[u.length - 1];
                if (n === "") {
                    return u[u.length - 2];
                }
                return n;
            };
        }
    };
    var e = {};
    function __nccwpck_require__(u) {
        var n = e[u];
        if (n !== undefined) {
            return n.exports;
        }
        var o = e[u] = {
            exports: {}
        };
        var s = true;
        try {
            t[u](o, o.exports, __nccwpck_require__);
            s = false;
        } finally{
            if (s) delete e[u];
        }
        return o.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/picomatch") + "/";
    var u = __nccwpck_require__(170);
    module.exports = u;
})();
}),
"[project]/node_modules/next/dist/shared/lib/match-local-pattern.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasLocalMatch: null,
    matchLocalPattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasLocalMatch: function() {
        return hasLocalMatch;
    },
    matchLocalPattern: function() {
        return matchLocalPattern;
    }
});
const _picomatch = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)");
function matchLocalPattern(pattern, url) {
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    if (!(0, _picomatch.makeRe)(pattern.pathname ?? '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasLocalMatch(localPatterns, urlPathAndQuery) {
    if (!localPatterns) {
        // if the user didn't define "localPatterns", we allow all local images
        return true;
    }
    const url = new URL(urlPathAndQuery, 'http://n');
    return localPatterns.some((p)=>matchLocalPattern(p, url));
} //# sourceMappingURL=match-local-pattern.js.map
}),
"[project]/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasRemoteMatch: null,
    matchRemotePattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasRemoteMatch: function() {
        return hasRemoteMatch;
    },
    matchRemotePattern: function() {
        return matchRemotePattern;
    }
});
const _picomatch = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)");
function matchRemotePattern(pattern, url) {
    if (pattern.protocol !== undefined) {
        if (pattern.protocol.replace(/:$/, '') !== url.protocol.replace(/:$/, '')) {
            return false;
        }
    }
    if (pattern.port !== undefined) {
        if (pattern.port !== url.port) {
            return false;
        }
    }
    if (pattern.hostname === undefined) {
        throw Object.defineProperty(new Error(`Pattern should define hostname but found\n${JSON.stringify(pattern)}`), "__NEXT_ERROR_CODE", {
            value: "E410",
            enumerable: false,
            configurable: true
        });
    } else {
        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {
            return false;
        }
    }
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    // Should be the same as writeImagesManifest()
    if (!(0, _picomatch.makeRe)(pattern.pathname ?? '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasRemoteMatch(domains, remotePatterns, url) {
    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));
} //# sourceMappingURL=match-remote-pattern.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _findclosestquality = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/find-closest-quality.js [app-client] (ecmascript)");
function defaultLoader({ config, src, width, quality }) {
    if (src.startsWith('/') && src.includes('?') && config.localPatterns?.length === 1 && config.localPatterns[0].pathname === '**' && config.localPatterns[0].search === '') {
        throw Object.defineProperty(new Error(`Image with src "${src}" is using a query string which is not configured in images.localPatterns.` + `\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns`), "__NEXT_ERROR_CODE", {
            value: "E871",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        const missingValues = [];
        // these should always be provided but make sure they are
        if (!src) missingValues.push('src');
        if (!width) missingValues.push('width');
        if (missingValues.length > 0) {
            throw Object.defineProperty(new Error(`Next Image Optimization requires ${missingValues.join(', ')} to be provided. Make sure you pass them as props to the \`next/image\` component. Received: ${JSON.stringify({
                src,
                width,
                quality
            })}`), "__NEXT_ERROR_CODE", {
                value: "E188",
                enumerable: false,
                configurable: true
            });
        }
        if (src.startsWith('//')) {
            throw Object.defineProperty(new Error(`Failed to parse src "${src}" on \`next/image\`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)`), "__NEXT_ERROR_CODE", {
                value: "E360",
                enumerable: false,
                configurable: true
            });
        }
        if (src.startsWith('/') && config.localPatterns) {
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasLocalMatch } = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/match-local-pattern.js [app-client] (ecmascript)");
                if (!hasLocalMatch(config.localPatterns, src)) {
                    throw Object.defineProperty(new Error(`Invalid src prop (${src}) on \`next/image\` does not match \`images.localPatterns\` configured in your \`next.config.js\`\n` + `See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns`), "__NEXT_ERROR_CODE", {
                        value: "E426",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {
            let parsedSrc;
            try {
                parsedSrc = new URL(src);
            } catch (err) {
                console.error(err);
                throw Object.defineProperty(new Error(`Failed to parse src "${src}" on \`next/image\`, if using relative image it must start with a leading slash "/" or be an absolute URL (http:// or https://)`), "__NEXT_ERROR_CODE", {
                    value: "E63",
                    enumerable: false,
                    configurable: true
                });
            }
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasRemoteMatch } = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-client] (ecmascript)");
                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {
                    throw Object.defineProperty(new Error(`Invalid src prop (${src}) on \`next/image\`, hostname "${parsedSrc.hostname}" is not configured under images in your \`next.config.js\`\n` + `See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host`), "__NEXT_ERROR_CODE", {
                        value: "E231",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
    const q = (0, _findclosestquality.findClosestQuality)(quality, config);
    return `${config.path}?url=${encodeURIComponent(src)}&w=${width}&q=${q}${src.startsWith('/_next/static/media/') && ("TURBOPACK compile-time value", false) ? "TURBOPACK unreachable" : ''}`;
}
// We use this to determine if the import is the default loader
// or a custom loader defined by the user in next.config.js
defaultLoader.__next_img_default = true;
const _default = defaultLoader; //# sourceMappingURL=image-loader.js.map
}),
"[project]/node_modules/next/dist/client/image-component.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function() {
        return Image;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _reactdom = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)"));
const _head = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head.js [app-client] (ecmascript)"));
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)");
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const _imageconfigcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js [app-client] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _routercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router-context.shared-runtime.js [app-client] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)"));
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)");
// This is replaced by webpack define plugin
const configEnv = ("TURBOPACK compile-time value", {
    "deviceSizes": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", 640),
        ("TURBOPACK compile-time value", 750),
        ("TURBOPACK compile-time value", 828),
        ("TURBOPACK compile-time value", 1080),
        ("TURBOPACK compile-time value", 1200),
        ("TURBOPACK compile-time value", 1920),
        ("TURBOPACK compile-time value", 2048),
        ("TURBOPACK compile-time value", 3840)
    ]),
    "imageSizes": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", 32),
        ("TURBOPACK compile-time value", 48),
        ("TURBOPACK compile-time value", 64),
        ("TURBOPACK compile-time value", 96),
        ("TURBOPACK compile-time value", 128),
        ("TURBOPACK compile-time value", 256),
        ("TURBOPACK compile-time value", 384)
    ]),
    "qualities": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", 75)
    ]),
    "path": ("TURBOPACK compile-time value", "/_next/image"),
    "loader": ("TURBOPACK compile-time value", "default"),
    "dangerouslyAllowSVG": ("TURBOPACK compile-time value", false),
    "unoptimized": ("TURBOPACK compile-time value", false),
    "domains": ("TURBOPACK compile-time value", []),
    "remotePatterns": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", {
            "protocol": ("TURBOPACK compile-time value", "https"),
            "hostname": ("TURBOPACK compile-time value", "cdn.sanity.io")
        })
    ]),
    "localPatterns": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", {
            "pathname": ("TURBOPACK compile-time value", "**"),
            "search": ("TURBOPACK compile-time value", "")
        })
    ])
});
if (typeof window === 'undefined') {
    ;
    globalThis.__NEXT_IMAGE_IMPORTED = true;
}
// See https://stackoverflow.com/q/39777833/266535 for why we use this ref
// handler instead of the img's onLoad attribute.
function handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {
    const src = img?.src;
    if (!img || img['data-loaded-src'] === src) {
        return;
    }
    img['data-loaded-src'] = src;
    const p = 'decode' in img ? img.decode() : Promise.resolve();
    p.catch(()=>{}).then(()=>{
        if (!img.parentElement || !img.isConnected) {
            // Exit early in case of race condition:
            // - onload() is called
            // - decode() is called but incomplete
            // - unmount is called
            // - decode() completes
            return;
        }
        if (placeholder !== 'empty') {
            setBlurComplete(true);
        }
        if (onLoadRef?.current) {
            // Since we don't have the SyntheticEvent here,
            // we must create one with the same shape.
            // See https://reactjs.org/docs/events.html
            const event = new Event('load');
            Object.defineProperty(event, 'target', {
                writable: false,
                value: img
            });
            let prevented = false;
            let stopped = false;
            onLoadRef.current({
                ...event,
                nativeEvent: event,
                currentTarget: img,
                target: img,
                isDefaultPrevented: ()=>prevented,
                isPropagationStopped: ()=>stopped,
                persist: ()=>{},
                preventDefault: ()=>{
                    prevented = true;
                    event.preventDefault();
                },
                stopPropagation: ()=>{
                    stopped = true;
                    event.stopPropagation();
                }
            });
        }
        if (onLoadingCompleteRef?.current) {
            onLoadingCompleteRef.current(img);
        }
        if ("TURBOPACK compile-time truthy", 1) {
            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;
            if (img.getAttribute('data-nimg') === 'fill') {
                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {
                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;
                    if (widthViewportRatio < 0.6) {
                        if (sizesInput === '100vw') {
                            (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" prop and "sizes" prop of "100vw", but image is not rendered at full viewport width. Please adjust "sizes" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`);
                        } else {
                            (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" but is missing "sizes" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`);
                        }
                    }
                }
                if (img.parentElement) {
                    const { position } = window.getComputedStyle(img.parentElement);
                    const valid = [
                        'absolute',
                        'fixed',
                        'relative'
                    ];
                    if (!valid.includes(position)) {
                        (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" and parent element with invalid "position". Provided "${position}" should be one of ${valid.map(String).join(',')}.`);
                    }
                }
                if (img.height === 0) {
                    (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.`);
                }
            }
            const heightModified = img.height.toString() !== img.getAttribute('height');
            const widthModified = img.width.toString() !== img.getAttribute('width');
            if (heightModified && !widthModified || !heightModified && widthModified) {
                (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: "auto"' or 'height: "auto"' to maintain the aspect ratio.`);
            }
        }
    });
}
function getDynamicProps(fetchPriority) {
    if (Boolean(_react.use)) {
        // In React 19.0.0 or newer, we must use camelCase
        // prop to avoid "Warning: Invalid DOM property".
        // See https://github.com/facebook/react/pull/25927
        return {
            fetchPriority
        };
    }
    // In React 18.2.0 or older, we must use lowercase prop
    // to avoid "Warning: Invalid DOM property".
    return {
        fetchpriority: fetchPriority
    };
}
const ImageElement = /*#__PURE__*/ (0, _react.forwardRef)(({ src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest }, forwardedRef)=>{
    const ownRef = (0, _react.useCallback)((img)=>{
        if (!img) {
            return;
        }
        if (onError) {
            // If the image has an error before react hydrates, then the error is lost.
            // The workaround is to wait until the image is mounted which is after hydration,
            // then we set the src again to trigger the error handler (if there was an error).
            // eslint-disable-next-line no-self-assign
            img.src = img.src;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (!src) {
                console.error(`Image is missing required "src" property:`, img);
            }
            if (img.getAttribute('alt') === null) {
                console.error(`Image is missing required "alt" property. Please add Alternative Text to describe the image for screen readers and search engines.`);
            }
        }
        if (img.complete) {
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        }
    }, [
        src,
        placeholder,
        onLoadRef,
        onLoadingCompleteRef,
        setBlurComplete,
        onError,
        unoptimized,
        sizesInput
    ]);
    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
        ...rest,
        ...getDynamicProps(fetchPriority),
        // It's intended to keep `loading` before `src` because React updates
        // props in order which causes Safari/Firefox to not lazy load properly.
        // See https://github.com/facebook/react/issues/25883
        loading: loading,
        width: width,
        height: height,
        decoding: decoding,
        "data-nimg": fill ? 'fill' : '1',
        className: className,
        style: style,
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        sizes: sizes,
        srcSet: srcSet,
        src: src,
        ref: ref,
        onLoad: (event)=>{
            const img = event.currentTarget;
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        },
        onError: (event)=>{
            // if the real image fails to load, this will ensure "alt" is visible
            setShowAltText(true);
            if (placeholder !== 'empty') {
                // If the real image fails to load, this will still remove the placeholder.
                setBlurComplete(true);
            }
            if (onError) {
                onError(event);
            }
        }
    });
});
function ImagePreload({ isAppRouter, imgAttributes }) {
    const opts = {
        as: 'image',
        imageSrcSet: imgAttributes.srcSet,
        imageSizes: imgAttributes.sizes,
        crossOrigin: imgAttributes.crossOrigin,
        referrerPolicy: imgAttributes.referrerPolicy,
        ...getDynamicProps(imgAttributes.fetchPriority)
    };
    if (isAppRouter && _reactdom.default.preload) {
        _reactdom.default.preload(imgAttributes.src, opts);
        return null;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("link", {
            rel: "preload",
            // Note how we omit the `href` attribute, as it would only be relevant
            // for browsers that do not support `imagesrcset`, and in those cases
            // it would cause the incorrect image to be preloaded.
            //
            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset
            href: imgAttributes.srcSet ? undefined : imgAttributes.src,
            ...opts
        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)
    });
}
const Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{
    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);
    // We're in the app directory if there is no pages router.
    const isAppRouter = !pagesRouter;
    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);
    const config = (0, _react.useMemo)(()=>{
        const c = configEnv || configContext || _imageconfig.imageConfigDefault;
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = c.qualities?.sort((a, b)=>a - b);
        return {
            ...c,
            allSizes,
            deviceSizes,
            qualities,
            // During the SSR, configEnv (__NEXT_IMAGE_OPTS) does not include
            // security sensitive configs like `localPatterns`, which is needed
            // during the server render to ensure it's validated. Therefore use
            // configContext, which holds the config from the server for validation.
            localPatterns: typeof window === 'undefined' ? configContext?.localPatterns : c.localPatterns
        };
    }, [
        configContext
    ]);
    const { onLoad, onLoadingComplete } = props;
    const onLoadRef = (0, _react.useRef)(onLoad);
    (0, _react.useEffect)(()=>{
        onLoadRef.current = onLoad;
    }, [
        onLoad
    ]);
    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);
    (0, _react.useEffect)(()=>{
        onLoadingCompleteRef.current = onLoadingComplete;
    }, [
        onLoadingComplete
    ]);
    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);
    const [showAltText, setShowAltText] = (0, _react.useState)(false);
    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {
        defaultLoader: _imageloader.default,
        imgConf: config,
        blurComplete,
        showAltText
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {
                ...imgAttributes,
                unoptimized: imgMeta.unoptimized,
                placeholder: imgMeta.placeholder,
                fill: imgMeta.fill,
                onLoadRef: onLoadRef,
                onLoadingCompleteRef: onLoadingCompleteRef,
                setBlurComplete: setBlurComplete,
                setShowAltText: setShowAltText,
                sizesInput: props.sizes,
                ref: forwardedRef
            }),
            imgMeta.preload ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {
                isAppRouter: isAppRouter,
                imgAttributes: imgAttributes
            }) : null
        ]
    });
});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=image-component.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-external.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getImageProps: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getImageProps: function() {
        return getImageProps;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)");
const _imagecomponent = __turbopack_context__.r("[project]/node_modules/next/dist/client/image-component.js [app-client] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)"));
function getImageProps(imgProps) {
    const { props } = (0, _getimgprops.getImgProps)(imgProps, {
        defaultLoader: _imageloader.default,
        // This is replaced by webpack define plugin
        imgConf: ("TURBOPACK compile-time value", {
            "deviceSizes": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", 640),
                ("TURBOPACK compile-time value", 750),
                ("TURBOPACK compile-time value", 828),
                ("TURBOPACK compile-time value", 1080),
                ("TURBOPACK compile-time value", 1200),
                ("TURBOPACK compile-time value", 1920),
                ("TURBOPACK compile-time value", 2048),
                ("TURBOPACK compile-time value", 3840)
            ]),
            "imageSizes": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", 32),
                ("TURBOPACK compile-time value", 48),
                ("TURBOPACK compile-time value", 64),
                ("TURBOPACK compile-time value", 96),
                ("TURBOPACK compile-time value", 128),
                ("TURBOPACK compile-time value", 256),
                ("TURBOPACK compile-time value", 384)
            ]),
            "qualities": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", 75)
            ]),
            "path": ("TURBOPACK compile-time value", "/_next/image"),
            "loader": ("TURBOPACK compile-time value", "default"),
            "dangerouslyAllowSVG": ("TURBOPACK compile-time value", false),
            "unoptimized": ("TURBOPACK compile-time value", false),
            "domains": ("TURBOPACK compile-time value", []),
            "remotePatterns": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", {
                    "protocol": ("TURBOPACK compile-time value", "https"),
                    "hostname": ("TURBOPACK compile-time value", "cdn.sanity.io")
                })
            ]),
            "localPatterns": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", {
                    "pathname": ("TURBOPACK compile-time value", "**"),
                    "search": ("TURBOPACK compile-time value", "")
                })
            ])
        })
    });
    // Normally we don't care about undefined props because we pass to JSX,
    // but this exported function could be used by the end user for anything
    // so we delete undefined props to clean it up a little.
    for (const [key, value] of Object.entries(props)){
        if (value === undefined) {
            delete props[key];
        }
    }
    return {
        props
    };
}
const _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map
}),
"[project]/node_modules/next/image.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-external.js [app-client] (ecmascript)");
}),
"[project]/node_modules/next/navigation.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@sanity/core-loader/dist/_chunks-es/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "atom",
    ()=>atom,
    "createQueryStore",
    ()=>createQueryStore,
    "runtime",
    ()=>runtime
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var cache = {}, symbol, hasRequiredSymbol;
function requireSymbol() {
    if (hasRequiredSymbol) return symbol;
    hasRequiredSymbol = 1;
    const kValues = Symbol("values"), kStorage = Symbol("kStorage"), kStorages = Symbol("kStorages"), kTransfromer = Symbol("kTransformer"), kTTL = Symbol("kTTL"), kOnDedupe = Symbol("kOnDedupe"), kOnError = Symbol("kOnError"), kOnHit = Symbol("kOnHit"), kOnMiss = Symbol("kOnMiss"), kStale = Symbol("kStale");
    return symbol = {
        kValues,
        kStorage,
        kStorages,
        kTransfromer,
        kTTL,
        kOnDedupe,
        kOnError,
        kOnHit,
        kOnMiss,
        kStale
    }, symbol;
}
var safeStableStringify = {
    exports: {}
}, hasRequiredSafeStableStringify;
function requireSafeStableStringify() {
    return hasRequiredSafeStableStringify || (hasRequiredSafeStableStringify = 1, function(module, exports) {
        const { hasOwnProperty } = Object.prototype, stringify = configure();
        stringify.configure = configure, stringify.stringify = stringify, stringify.default = stringify, exports.stringify = stringify, exports.configure = configure, module.exports = stringify;
        const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
        function strEscape(str) {
            return str.length < 5e3 && !strEscapeSequencesRegExp.test(str) ? `"${str}"` : JSON.stringify(str);
        }
        function sort(array, comparator) {
            if (array.length > 200 || comparator) return array.sort(comparator);
            for(let i = 1; i < array.length; i++){
                const currentValue = array[i];
                let position = i;
                for(; position !== 0 && array[position - 1] > currentValue;)array[position] = array[position - 1], position--;
                array[position] = currentValue;
            }
            return array;
        }
        const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;
        function isTypedArrayWithEntries(value) {
            return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
        }
        function stringifyTypedArray(array, separator, maximumBreadth) {
            array.length < maximumBreadth && (maximumBreadth = array.length);
            const whitespace = separator === "," ? "" : " ";
            let res = `"0":${whitespace}${array[0]}`;
            for(let i = 1; i < maximumBreadth; i++)res += `${separator}"${i}":${whitespace}${array[i]}`;
            return res;
        }
        function getCircularValueOption(options) {
            if (hasOwnProperty.call(options, "circularValue")) {
                const circularValue = options.circularValue;
                if (typeof circularValue == "string") return `"${circularValue}"`;
                if (circularValue == null) return circularValue;
                if (circularValue === Error || circularValue === TypeError) return {
                    toString () {
                        throw new TypeError("Converting circular structure to JSON");
                    }
                };
                throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
            }
            return '"[Circular]"';
        }
        function getDeterministicOption(options) {
            let value;
            if (hasOwnProperty.call(options, "deterministic") && (value = options.deterministic, typeof value != "boolean" && typeof value != "function")) throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
            return value === void 0 ? !0 : value;
        }
        function getBooleanOption(options, key) {
            let value;
            if (hasOwnProperty.call(options, key) && (value = options[key], typeof value != "boolean")) throw new TypeError(`The "${key}" argument must be of type boolean`);
            return value === void 0 ? !0 : value;
        }
        function getPositiveIntegerOption(options, key) {
            let value;
            if (hasOwnProperty.call(options, key)) {
                if (value = options[key], typeof value != "number") throw new TypeError(`The "${key}" argument must be of type number`);
                if (!Number.isInteger(value)) throw new TypeError(`The "${key}" argument must be an integer`);
                if (value < 1) throw new RangeError(`The "${key}" argument must be >= 1`);
            }
            return value === void 0 ? 1 / 0 : value;
        }
        function getItemCount(number) {
            return number === 1 ? "1 item" : `${number} items`;
        }
        function getUniqueReplacerSet(replacerArray) {
            const replacerSet = /* @__PURE__ */ new Set();
            for (const value of replacerArray)(typeof value == "string" || typeof value == "number") && replacerSet.add(String(value));
            return replacerSet;
        }
        function getStrictOption(options) {
            if (hasOwnProperty.call(options, "strict")) {
                const value = options.strict;
                if (typeof value != "boolean") throw new TypeError('The "strict" argument must be of type boolean');
                if (value) return (value2)=>{
                    let message = `Object can not safely be stringified. Received type ${typeof value2}`;
                    throw typeof value2 != "function" && (message += ` (${value2.toString()})`), new Error(message);
                };
            }
        }
        function configure(options) {
            options = {
                ...options
            };
            const fail = getStrictOption(options);
            fail && (options.bigint === void 0 && (options.bigint = !1), "circularValue" in options || (options.circularValue = Error));
            const circularValue = getCircularValueOption(options), bigint = getBooleanOption(options, "bigint"), deterministic = getDeterministicOption(options), comparator = typeof deterministic == "function" ? deterministic : void 0, maximumDepth = getPositiveIntegerOption(options, "maximumDepth"), maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
            function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
                let value = parent[key];
                switch(typeof value == "object" && value !== null && typeof value.toJSON == "function" && (value = value.toJSON(key)), value = replacer.call(parent, key, value), typeof value){
                    case "string":
                        return strEscape(value);
                    case "object":
                        {
                            if (value === null) return "null";
                            if (stack.indexOf(value) !== -1) return circularValue;
                            let res = "", join = ",";
                            const originalIndentation = indentation;
                            if (Array.isArray(value)) {
                                if (value.length === 0) return "[]";
                                if (maximumDepth < stack.length + 1) return '"[Array]"';
                                stack.push(value), spacer !== "" && (indentation += spacer, res += `
${indentation}`, join = `,
${indentation}`);
                                const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                                let i = 0;
                                for(; i < maximumValuesToStringify - 1; i++){
                                    const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                                    res += tmp2 !== void 0 ? tmp2 : "null", res += join;
                                }
                                const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                                if (res += tmp !== void 0 ? tmp : "null", value.length - 1 > maximumBreadth) {
                                    const removedKeys = value.length - maximumBreadth - 1;
                                    res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                                }
                                return spacer !== "" && (res += `
${originalIndentation}`), stack.pop(), `[${res}]`;
                            }
                            let keys = Object.keys(value);
                            const keyLength = keys.length;
                            if (keyLength === 0) return "{}";
                            if (maximumDepth < stack.length + 1) return '"[Object]"';
                            let whitespace = "", separator = "";
                            spacer !== "" && (indentation += spacer, join = `,
${indentation}`, whitespace = " ");
                            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                            deterministic && !isTypedArrayWithEntries(value) && (keys = sort(keys, comparator)), stack.push(value);
                            for(let i = 0; i < maximumPropertiesToStringify; i++){
                                const key2 = keys[i], tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
                                tmp !== void 0 && (res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`, separator = join);
                            }
                            if (keyLength > maximumBreadth) {
                                const removedKeys = keyLength - maximumBreadth;
                                res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`, separator = join;
                            }
                            return spacer !== "" && separator.length > 1 && (res = `
${indentation}${res}
${originalIndentation}`), stack.pop(), `{${res}}`;
                        }
                    case "number":
                        return isFinite(value) ? String(value) : fail ? fail(value) : "null";
                    case "boolean":
                        return value === !0 ? "true" : "false";
                    case "undefined":
                        return;
                    case "bigint":
                        if (bigint) return String(value);
                    // fallthrough
                    default:
                        return fail ? fail(value) : void 0;
                }
            }
            function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
                switch(typeof value == "object" && value !== null && typeof value.toJSON == "function" && (value = value.toJSON(key)), typeof value){
                    case "string":
                        return strEscape(value);
                    case "object":
                        {
                            if (value === null) return "null";
                            if (stack.indexOf(value) !== -1) return circularValue;
                            const originalIndentation = indentation;
                            let res = "", join = ",";
                            if (Array.isArray(value)) {
                                if (value.length === 0) return "[]";
                                if (maximumDepth < stack.length + 1) return '"[Array]"';
                                stack.push(value), spacer !== "" && (indentation += spacer, res += `
${indentation}`, join = `,
${indentation}`);
                                const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                                let i = 0;
                                for(; i < maximumValuesToStringify - 1; i++){
                                    const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                                    res += tmp2 !== void 0 ? tmp2 : "null", res += join;
                                }
                                const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                                if (res += tmp !== void 0 ? tmp : "null", value.length - 1 > maximumBreadth) {
                                    const removedKeys = value.length - maximumBreadth - 1;
                                    res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                                }
                                return spacer !== "" && (res += `
${originalIndentation}`), stack.pop(), `[${res}]`;
                            }
                            stack.push(value);
                            let whitespace = "";
                            spacer !== "" && (indentation += spacer, join = `,
${indentation}`, whitespace = " ");
                            let separator = "";
                            for (const key2 of replacer){
                                const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
                                tmp !== void 0 && (res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`, separator = join);
                            }
                            return spacer !== "" && separator.length > 1 && (res = `
${indentation}${res}
${originalIndentation}`), stack.pop(), `{${res}}`;
                        }
                    case "number":
                        return isFinite(value) ? String(value) : fail ? fail(value) : "null";
                    case "boolean":
                        return value === !0 ? "true" : "false";
                    case "undefined":
                        return;
                    case "bigint":
                        if (bigint) return String(value);
                    // fallthrough
                    default:
                        return fail ? fail(value) : void 0;
                }
            }
            function stringifyIndent(key, value, stack, spacer, indentation) {
                switch(typeof value){
                    case "string":
                        return strEscape(value);
                    case "object":
                        {
                            if (value === null) return "null";
                            if (typeof value.toJSON == "function") {
                                if (value = value.toJSON(key), typeof value != "object") return stringifyIndent(key, value, stack, spacer, indentation);
                                if (value === null) return "null";
                            }
                            if (stack.indexOf(value) !== -1) return circularValue;
                            const originalIndentation = indentation;
                            if (Array.isArray(value)) {
                                if (value.length === 0) return "[]";
                                if (maximumDepth < stack.length + 1) return '"[Array]"';
                                stack.push(value), indentation += spacer;
                                let res2 = `
${indentation}`;
                                const join2 = `,
${indentation}`, maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                                let i = 0;
                                for(; i < maximumValuesToStringify - 1; i++){
                                    const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                                    res2 += tmp2 !== void 0 ? tmp2 : "null", res2 += join2;
                                }
                                const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                                if (res2 += tmp !== void 0 ? tmp : "null", value.length - 1 > maximumBreadth) {
                                    const removedKeys = value.length - maximumBreadth - 1;
                                    res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
                                }
                                return res2 += `
${originalIndentation}`, stack.pop(), `[${res2}]`;
                            }
                            let keys = Object.keys(value);
                            const keyLength = keys.length;
                            if (keyLength === 0) return "{}";
                            if (maximumDepth < stack.length + 1) return '"[Object]"';
                            indentation += spacer;
                            const join = `,
${indentation}`;
                            let res = "", separator = "", maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                            isTypedArrayWithEntries(value) && (res += stringifyTypedArray(value, join, maximumBreadth), keys = keys.slice(value.length), maximumPropertiesToStringify -= value.length, separator = join), deterministic && (keys = sort(keys, comparator)), stack.push(value);
                            for(let i = 0; i < maximumPropertiesToStringify; i++){
                                const key2 = keys[i], tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
                                tmp !== void 0 && (res += `${separator}${strEscape(key2)}: ${tmp}`, separator = join);
                            }
                            if (keyLength > maximumBreadth) {
                                const removedKeys = keyLength - maximumBreadth;
                                res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`, separator = join;
                            }
                            return separator !== "" && (res = `
${indentation}${res}
${originalIndentation}`), stack.pop(), `{${res}}`;
                        }
                    case "number":
                        return isFinite(value) ? String(value) : fail ? fail(value) : "null";
                    case "boolean":
                        return value === !0 ? "true" : "false";
                    case "undefined":
                        return;
                    case "bigint":
                        if (bigint) return String(value);
                    // fallthrough
                    default:
                        return fail ? fail(value) : void 0;
                }
            }
            function stringifySimple(key, value, stack) {
                switch(typeof value){
                    case "string":
                        return strEscape(value);
                    case "object":
                        {
                            if (value === null) return "null";
                            if (typeof value.toJSON == "function") {
                                if (value = value.toJSON(key), typeof value != "object") return stringifySimple(key, value, stack);
                                if (value === null) return "null";
                            }
                            if (stack.indexOf(value) !== -1) return circularValue;
                            let res = "";
                            const hasLength = value.length !== void 0;
                            if (hasLength && Array.isArray(value)) {
                                if (value.length === 0) return "[]";
                                if (maximumDepth < stack.length + 1) return '"[Array]"';
                                stack.push(value);
                                const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                                let i = 0;
                                for(; i < maximumValuesToStringify - 1; i++){
                                    const tmp2 = stringifySimple(String(i), value[i], stack);
                                    res += tmp2 !== void 0 ? tmp2 : "null", res += ",";
                                }
                                const tmp = stringifySimple(String(i), value[i], stack);
                                if (res += tmp !== void 0 ? tmp : "null", value.length - 1 > maximumBreadth) {
                                    const removedKeys = value.length - maximumBreadth - 1;
                                    res += `,"... ${getItemCount(removedKeys)} not stringified"`;
                                }
                                return stack.pop(), `[${res}]`;
                            }
                            let keys = Object.keys(value);
                            const keyLength = keys.length;
                            if (keyLength === 0) return "{}";
                            if (maximumDepth < stack.length + 1) return '"[Object]"';
                            let separator = "", maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                            hasLength && isTypedArrayWithEntries(value) && (res += stringifyTypedArray(value, ",", maximumBreadth), keys = keys.slice(value.length), maximumPropertiesToStringify -= value.length, separator = ","), deterministic && (keys = sort(keys, comparator)), stack.push(value);
                            for(let i = 0; i < maximumPropertiesToStringify; i++){
                                const key2 = keys[i], tmp = stringifySimple(key2, value[key2], stack);
                                tmp !== void 0 && (res += `${separator}${strEscape(key2)}:${tmp}`, separator = ",");
                            }
                            if (keyLength > maximumBreadth) {
                                const removedKeys = keyLength - maximumBreadth;
                                res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
                            }
                            return stack.pop(), `{${res}}`;
                        }
                    case "number":
                        return isFinite(value) ? String(value) : fail ? fail(value) : "null";
                    case "boolean":
                        return value === !0 ? "true" : "false";
                    case "undefined":
                        return;
                    case "bigint":
                        if (bigint) return String(value);
                    // fallthrough
                    default:
                        return fail ? fail(value) : void 0;
                }
            }
            function stringify2(value, replacer, space) {
                if (arguments.length > 1) {
                    let spacer = "";
                    if (typeof space == "number" ? spacer = " ".repeat(Math.min(space, 10)) : typeof space == "string" && (spacer = space.slice(0, 10)), replacer != null) {
                        if (typeof replacer == "function") return stringifyFnReplacer("", {
                            "": value
                        }, [], replacer, spacer, "");
                        if (Array.isArray(replacer)) return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
                    }
                    if (spacer.length !== 0) return stringifyIndent("", value, [], spacer, "");
                }
                return stringifySimple("", value, []);
            }
            return stringify2;
        }
    }(safeStableStringify, safeStableStringify.exports)), safeStableStringify.exports;
}
var util, hasRequiredUtil;
function requireUtil() {
    if (hasRequiredUtil) return util;
    hasRequiredUtil = 1;
    function findMatchingIndexes(arrayA, arrayB) {
        const found = [];
        let lastIndexB = 0;
        for(let indexA = 0; indexA < arrayA.length; indexA++)for(let indexB = lastIndexB; indexB < arrayB.length; indexB++)arrayA[indexA] === arrayB[indexB] && (found.push(indexB), lastIndexB = indexB + 1);
        return found;
    }
    function findNotMatching(arrayA, arrayB) {
        const found = [];
        let lastIndexB = 0;
        for(let indexA = 0; indexA < arrayA.length; indexA++)for(let indexB = lastIndexB; indexB < arrayB.length; indexB++)arrayA[indexA] !== arrayB[indexB] && (found.push(arrayB[indexB]), lastIndexB = indexB + 1);
        return found;
    }
    function bsearchIndex(array, value) {
        let start = 0, end = array.length - 1;
        for(; start <= end;){
            const index = (start + end) / 2 | 0;
            if (array[index] === value) return index;
            array[index] < value ? start = index + 1 : end = index - 1;
        }
        return -1;
    }
    function randomNumber(max) {
        return max * Math.random() | 0;
    }
    function randomInRange(min, max) {
        return min = Math.floor(min), max = Math.floor(max), min + randomNumber(1 + max - min);
    }
    function randomSubset(array, size) {
        if (array.length < 1 || size < 1) return [];
        const limit = Math.min(array.length, size), n = randomInRange(1, limit), indexes = /* @__PURE__ */ new Set();
        for(let i = 0; i < n; i++)indexes.add(randomNumber(array.length));
        const result = [];
        for (const i of indexes)result.push(array[i]);
        return result;
    }
    function wildcardMatch(value, content) {
        if (value === "*" || value.length === content.length && value === content) return !0;
        let i = 0, j = 0;
        for(; i < value.length && j < content.length;){
            if (value[i] === content[j]) {
                i++, j++;
                continue;
            }
            if (value[i] === "*") {
                if (value[i + 1] === content[j]) {
                    i++;
                    continue;
                }
                j++;
                continue;
            }
            return !1;
        }
        return i >= value.length - 1;
    }
    function abstractLogging() {
        const noop = ()=>{};
        return {
            fatal: noop,
            error: noop,
            warn: noop,
            info: noop,
            debug: noop,
            trace: noop
        };
    }
    return util = {
        findNotMatching,
        findMatchingIndexes,
        bsearchIndex,
        wildcardMatch,
        randomSubset,
        abstractLogging,
        isServerSide: typeof window > "u"
    }, util;
}
var _interface, hasRequired_interface;
function require_interface() {
    if (hasRequired_interface) return _interface;
    hasRequired_interface = 1;
    class StorageInterface {
        constructor(options){
            this.options = options;
        }
        /**
     * @param {string} key
     * @returns {undefined|*} undefined if key not found
     */ async get(key) {
            throw new Error("storage get method not implemented");
        }
        /**
     * @param {string} key
     * @param {*} value
     * @param {number} ttl - ttl in seconds; zero means key will not be stored
     * @param {?string[]} references
     */ async set(key, value, ttl, references) {
            throw new Error("storage set method not implemented");
        }
        /**
     * @param {string} key
     */ async remove(key) {
            throw new Error("storage remove method not implemented");
        }
        /**
     * @param {string[]} references
     */ async invalidate(references) {
            throw new Error("storage invalidate method not implemented");
        }
        /**
     * @param {string} name
     */ async clear(name) {
            throw new Error("storage clear method not implemented");
        }
        async refresh() {
            throw new Error("storage refresh method not implemented");
        }
    }
    return _interface = StorageInterface, _interface;
}
var redis, hasRequiredRedis;
function requireRedis() {
    if (hasRequiredRedis) return redis;
    hasRequiredRedis = 1;
    const stringify = requireSafeStableStringify(), StorageInterface = require_interface(), { findNotMatching, randomSubset, abstractLogging } = requireUtil(), GC_DEFAULT_CHUNK = 64, GC_DEFAULT_LAZY_CHUNK = 64, REFERENCES_DEFAULT_TTL = 60;
    class StorageRedis extends StorageInterface {
        /**
     * @param {?StorageRedisOptions} options
     */ constructor(options = {}){
            if (!options.client || typeof options.client != "object") throw new Error("Redis client is required");
            if (super(options), options.invalidation && options.invalidation.referencesTTL && (typeof options.invalidation.referencesTTL != "number" || options.invalidation.referencesTTL < 1)) throw new Error("invalidation.referencesTTL must be a positive integer greater than 1");
            this.log = options.log || abstractLogging(), this.store = options.client, this.invalidation = !!options.invalidation, this.referencesTTL = options.invalidation && options.invalidation.referencesTTL || REFERENCES_DEFAULT_TTL;
        }
        getReferenceKeyLabel(reference) {
            return `r:${reference}`;
        }
        getKeyReferenceLabel(key) {
            return `k:${key}`;
        }
        /**
     * @param {string} key
     * @returns {undefined|*} undefined if key not found
     */ async get(key) {
            this.log.debug({
                msg: "acd/storage/redis.get",
                key
            });
            try {
                const value = await this.store.get(key);
                if (!value) {
                    if (!this.invalidation) return;
                    this.clearReferences(key);
                    return;
                }
                return JSON.parse(value);
            } catch (err) {
                this.log.error({
                    msg: "acd/storage/redis.get error",
                    err,
                    key
                });
            }
        }
        /**
     * retrieve the remaining TTL value by key
     * @param {string} key
     * @returns {undefined|*} undefined if key not found or expired
     */ async getTTL(key) {
            this.log.debug({
                msg: "acd/storage/memory.getTTL",
                key
            });
            let pttl = await this.store.pttl(key);
            return pttl < 0 ? 0 : (pttl = Math.ceil(pttl / 1e3), pttl);
        }
        /**
     * set value by key
     * @param {string} key
     * @param {*} value
     * @param {number} ttl - ttl in seconds; zero means key will not be stored
     * @param {?string[]} references
     */ async set(key, value, ttl, references) {
            if (this.log.debug({
                msg: "acd/storage/redis.set key",
                key,
                value,
                ttl,
                references
            }), ttl = Number(ttl), !(!ttl || ttl < 0)) try {
                if (await this.store.set(key, stringify(value), "EX", ttl), !references || references.length < 1) return;
                if (!this.invalidation) {
                    this.log.warn({
                        msg: "acd/storage/redis.set, invalidation is disabled, references are useless",
                        key,
                        references
                    });
                    return;
                }
                const writes = [], currentReferences = await this.store.smembers(this.getKeyReferenceLabel(key));
                if (this.log.debug({
                    msg: "acd/storage/redis.set current references",
                    key,
                    currentReferences
                }), currentReferences.length > 1) {
                    currentReferences.sort(), references.sort();
                    const referencesToRemove = findNotMatching(references, currentReferences);
                    for (const reference of referencesToRemove)writes.push([
                        "srem",
                        this.getReferenceKeyLabel(reference),
                        key
                    ]);
                    writes.push([
                        "del",
                        this.getKeyReferenceLabel(key)
                    ]);
                }
                const referencesToAdd = currentReferences.length > 1 ? findNotMatching(currentReferences, references) : references;
                this.log.debug({
                    msg: "acd/storage/redis.set references to add",
                    key,
                    referencesToAdd
                });
                for(let i = 0; i < referencesToAdd.length; i++){
                    const reference = referencesToAdd[i], referenceKeyLabel = this.getReferenceKeyLabel(reference);
                    writes.push([
                        "sadd",
                        referenceKeyLabel,
                        key
                    ]), writes.push([
                        "expire",
                        referenceKeyLabel,
                        this.referencesTTL
                    ]);
                }
                const keyReferenceLabel = this.getKeyReferenceLabel(key);
                writes.push([
                    "sadd",
                    keyReferenceLabel,
                    references
                ]), writes.push([
                    "expire",
                    keyReferenceLabel,
                    ttl
                ]), this.log.debug({
                    msg: "acd/storage/redis.set references writes",
                    writes
                }), await this.store.pipeline(writes).exec();
            } catch (err) {
                this.log.error({
                    msg: "acd/storage/redis.set error",
                    err,
                    key,
                    ttl,
                    references
                });
            }
        }
        /**
     * remove an entry by key
     * @param {string} key
     * @returns {boolean} indicates if key was removed
     */ async remove(key) {
            this.log.debug({
                msg: "acd/storage/redis.remove",
                key
            });
            try {
                const removed = await this.store.del(key) > 0;
                return removed && this.invalidation && await this.clearReferences(key), removed;
            } catch (err) {
                this.log.error({
                    msg: "acd/storage/redis.remove error",
                    err,
                    key
                });
            }
        }
        /**
     * @param {string|string[]} references
     * @returns {string[]} removed keys
     */ async invalidate(references) {
            if (!this.invalidation) return this.log.warn({
                msg: "acd/storage/redis.invalidate, exit due invalidation is disabled"
            }), [];
            this.log.debug({
                msg: "acd/storage/redis.invalidate",
                references
            });
            try {
                return Array.isArray(references) ? await this._invalidateReferences(references) : await this._invalidateReference(references);
            } catch (err) {
                return this.log.error({
                    msg: "acd/storage/redis.invalidate error",
                    err,
                    references
                }), [];
            }
        }
        /**
     * @param {string[]} references
     * @param {[bool=true]} mapReferences
     * @returns {string[]} removed keys
     */ async _invalidateReferences(references, mapReferences = !0) {
            const reads = references.map((reference)=>[
                    "smembers",
                    mapReferences ? this.getReferenceKeyLabel(reference) : reference
                ]), keys = await this.store.pipeline(reads).exec();
            this.log.debug({
                msg: "acd/storage/redis._invalidateReferences keys",
                keys
            });
            const writes = [], removed = [];
            for(let i = 0; i < keys.length; i++){
                const key0 = keys[i][1];
                if (key0) {
                    this.log.debug({
                        msg: "acd/storage/redis._invalidateReferences got keys to be invalidated",
                        keys: key0
                    });
                    for(let j = 0; j < key0.length; j++){
                        const key1 = key0[j];
                        this.log.debug({
                            msg: "acd/storage/redis._invalidateReferences del key" + key1
                        }), removed.push(key1), writes.push([
                            "del",
                            key1
                        ]);
                    }
                }
            }
            return await this.store.pipeline(writes).exec(), await this.clearReferences(removed), removed;
        }
        /**
     * @param {string} reference
     * @returns {string[]} removed keys
     */ async _invalidateReference(reference) {
            let keys;
            if (reference.includes("*")) {
                const references = await this.store.keys(this.getReferenceKeyLabel(reference));
                return this._invalidateReferences(references, !1);
            } else keys = await this.store.smembers(this.getReferenceKeyLabel(reference));
            this.log.debug({
                msg: "acd/storage/redis._invalidateReference keys",
                keys
            });
            const writes = [], removed = [];
            for(let i = 0; i < keys.length; i++){
                const key0 = keys[i];
                this.log.debug({
                    msg: "acd/storage/redis._invalidateReference del key" + key0
                }), removed.push(key0), writes.push([
                    "del",
                    key0
                ]);
            }
            return await this.store.pipeline(writes).exec(), await this.clearReferences(removed), removed;
        }
        /**
     * @param {string} name
     */ async clear(name) {
            this.log.debug({
                msg: "acd/storage/redis.clear",
                name
            });
            try {
                if (!name) {
                    await this.store.flushall();
                    return;
                }
                const keys = await this.store.keys(`${name}*`);
                this.log.debug({
                    msg: "acd/storage/redis.clear keys",
                    keys
                });
                const removes = keys.map((key)=>[
                        "del",
                        key
                    ]);
                if (await this.store.pipeline(removes).exec(), !this.invalidation) return;
                await this.clearReferences(keys);
            } catch (err) {
                this.log.error({
                    msg: "acd/storage/redis.clear error",
                    err,
                    name
                });
            }
        }
        async refresh() {
            try {
                await this.store.flushall();
            } catch (err) {
                this.log.error({
                    msg: "acd/storage/redis.refresh error",
                    err
                });
            }
        }
        /**
     * note: does not throw on error
     * @param {string|string[]} keys
     */ async clearReferences(keys) {
            try {
                if (!keys) {
                    this.log.warn({
                        msg: "acd/storage/redis.clearReferences invalid call due to empty key"
                    });
                    return;
                }
                Array.isArray(keys) || (keys = [
                    keys
                ]);
                const reads = keys.map((key)=>[
                        "smembers",
                        this.getKeyReferenceLabel(key)
                    ]), referencesKeys = await this.store.pipeline(reads).exec();
                this.log.debug({
                    msg: "acd/storage/redis.clearReferences references",
                    keys,
                    referencesKeys
                });
                const writes = {};
                for(let i = 0; i < keys.length; i++){
                    for(let j = 0; j < referencesKeys[i][1].length; j++){
                        const reference = this.getReferenceKeyLabel(referencesKeys[i][1][j]);
                        writes[reference] || (writes[reference] = [
                            "srem",
                            reference,
                            keys
                        ]);
                    }
                    const key = this.getKeyReferenceLabel(keys[i]);
                    writes[key] = [
                        "del",
                        key
                    ];
                }
                this.log.debug({
                    msg: "acd/storage/redis.clearReferences writes pipeline",
                    writes
                }), await this.store.pipeline(Object.values(writes)).exec();
            } catch (err) {
                this.log.error({
                    msg: "acd/storage/redis.clearReferences error",
                    err
                });
            }
        }
        /**
     * scan references and clean expired/evicted keys
     * @param {?string} [mode=lazy] lazy or strict
     * - in lazy mode, only `options.max` references are scanned every time, picking keys to check randomly
     *   so this operation is lighter while does not ensure references full clean up
     * - in strict mode, all references and keys are checked
     *   this operation scan the whole db and is slow
     * @param {?object} options
     * @param {number} [options.chunk=64] number of references to retrieve at once
     * @param {number|undefined} [options.lazy.cursor] cursor to start the scan; should be last cursor returned by scan; default start from the beginning
     * @param {number} [lazyChunk=64] number of references to check per gc cycle
     * @return {Object} report information of the operation
     *   references scanned/removed, keys scanned/removed, loops, cursor, error if any
     */ async gc(mode = "lazy", options = {}) {
            if (this.log.debug({
                msg: "acd/storage/redis.gc",
                mode,
                options
            }), !this.invalidation) {
                this.log.warn({
                    msg: "acd/storage/redis.gc does not run due to invalidation is disabled"
                });
                return;
            }
            mode !== "strict" && mode !== "lazy" && (mode = "lazy");
            const report = {
                references: {
                    scanned: [],
                    removed: []
                },
                keys: {
                    scanned: /* @__PURE__ */ new Set(),
                    removed: /* @__PURE__ */ new Set()
                },
                loops: 0,
                cursor: 0,
                error: null
            };
            try {
                let cursor = 0, lazyChunk = GC_DEFAULT_LAZY_CHUNK;
                if (options.chunk && (typeof options.chunk != "number" || options.chunk < 1)) return report.error = new Error("chunk must be a positive integer greater than 1"), report;
                if (options.lazy) {
                    if (options.lazy.chunk) {
                        if (typeof options.lazy.chunk != "number" || options.lazy.chunk < 1) return report.error = new Error("lazy.chunk must be a positive integer greater than 1"), report;
                        lazyChunk = options.lazy.chunk;
                    }
                    if (options.lazy.cursor) {
                        if (typeof options.lazy.cursor != "number" || options.lazy.cursor < 0) return report.error = new Error("lazy.cursor must be a positive integer greater than 0"), report;
                        cursor = options.lazy.cursor;
                    }
                }
                const chunk = options.chunk || GC_DEFAULT_CHUNK, scanCount = Math.min(lazyChunk, chunk), startingCursor = cursor;
                let lastScanLength = -1, lastRemoved = -1;
                do {
                    report.loops++;
                    const scan = await this.store.scan(cursor, "match", "r:*", "count", scanCount);
                    cursor = Number(scan[0]), lastScanLength = scan[1].length;
                    const references = mode === "lazy" ? randomSubset(scan[1], lazyChunk) : scan[1];
                    report.references.scanned = report.references.scanned.concat(references);
                    let reads = [];
                    for(let i = 0; i < references.length; i++){
                        const reference = references[i];
                        reads.push([
                            "smembers",
                            reference
                        ]);
                    }
                    const referencesKeys = await this.store.pipeline(reads).exec(), keysMap = {}, referencesKeysMap = {};
                    for(let i = 0; i < referencesKeys.length; i++){
                        const keys2 = referencesKeys[i], reference = references[i];
                        referencesKeysMap[reference] = keys2[1];
                        for(let j = 0; j < keys2[1].length; j++){
                            const key = keys2[1][j];
                            keysMap[key] ? keysMap[key].push(reference) : keysMap[key] = [
                                reference
                            ], report.keys.scanned.add(key);
                        }
                    }
                    const keys = Object.keys(keysMap);
                    reads = keys.map((key)=>[
                            "exists",
                            key
                        ]);
                    const existingKeys = await this.store.pipeline(reads).exec(), removingKeys = {};
                    for(let i = 0; i < keys.length; i++){
                        const key = keys[i];
                        if (existingKeys[i][1] !== 1) for(let j = 0; j < keysMap[key].length; j++){
                            const reference = keysMap[key][j];
                            removingKeys[reference] ? removingKeys[reference].push(key) : removingKeys[reference] = [
                                key
                            ], report.keys.removed.add(key);
                        }
                    }
                    const writeReferences = Object.keys(removingKeys), writes = [];
                    for(let i = 0; i < writeReferences.length; i++){
                        const reference = writeReferences[i];
                        referencesKeysMap[reference].length === removingKeys[reference].length ? (writes.push([
                            "del",
                            reference
                        ]), report.references.removed.push(reference)) : writes.push([
                            "srem",
                            reference,
                            removingKeys[reference]
                        ]);
                    }
                    if (await this.store.pipeline(writes).exec(), lastRemoved = writes.length, mode === "lazy" && report.references.scanned.length >= lazyChunk) break;
                }while (startingCursor !== cursor && lastScanLength > 0 && lastRemoved > 0)
                report.cursor = cursor, report.keys.scanned = Array.from(report.keys.scanned), report.keys.removed = Array.from(report.keys.removed);
            } catch (err) {
                this.log.error({
                    msg: "acd/storage/redis.gc error",
                    err
                }), report.error = err;
            }
            return report;
        }
    }
    return redis = StorageRedis, redis;
}
var iterator, hasRequiredIterator;
function requireIterator() {
    if (hasRequiredIterator) return iterator;
    hasRequiredIterator = 1;
    function Iterator(next) {
        if (typeof next != "function") throw new Error("obliterator/iterator: expecting a function!");
        this.next = next;
    }
    return typeof Symbol < "u" && (Iterator.prototype[Symbol.iterator] = function() {
        return this;
    }), Iterator.of = function() {
        var args = arguments, l = args.length, i = 0;
        return new Iterator(function() {
            return i >= l ? {
                done: !0
            } : {
                done: !1,
                value: args[i++]
            };
        });
    }, Iterator.empty = function() {
        var iterator2 = new Iterator(function() {
            return {
                done: !0
            };
        });
        return iterator2;
    }, Iterator.fromSequence = function(sequence) {
        var i = 0, l = sequence.length;
        return new Iterator(function() {
            return i >= l ? {
                done: !0
            } : {
                done: !1,
                value: sequence[i++]
            };
        });
    }, Iterator.is = function(value) {
        return value instanceof Iterator ? !0 : typeof value == "object" && value !== null && typeof value.next == "function";
    }, iterator = Iterator, iterator;
}
var support = {}, hasRequiredSupport;
function requireSupport() {
    return hasRequiredSupport || (hasRequiredSupport = 1, support.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer < "u", support.SYMBOL_SUPPORT = typeof Symbol < "u"), support;
}
var foreach, hasRequiredForeach;
function requireForeach() {
    if (hasRequiredForeach) return foreach;
    hasRequiredForeach = 1;
    var support2 = requireSupport(), ARRAY_BUFFER_SUPPORT = support2.ARRAY_BUFFER_SUPPORT, SYMBOL_SUPPORT = support2.SYMBOL_SUPPORT;
    return foreach = function(iterable, callback) {
        var iterator2, k, i, l, s;
        if (!iterable) throw new Error("obliterator/forEach: invalid iterable.");
        if (typeof callback != "function") throw new Error("obliterator/forEach: expecting a callback.");
        if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable == "string" || iterable.toString() === "[object Arguments]") {
            for(i = 0, l = iterable.length; i < l; i++)callback(iterable[i], i);
            return;
        }
        if (typeof iterable.forEach == "function") {
            iterable.forEach(callback);
            return;
        }
        if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next != "function" && (iterable = iterable[Symbol.iterator]()), typeof iterable.next == "function") {
            for(iterator2 = iterable, i = 0; s = iterator2.next(), s.done !== !0;)callback(s.value, i), i++;
            return;
        }
        for(k in iterable)iterable.hasOwnProperty(k) && callback(iterable[k], k);
    }, foreach;
}
var typedArrays = {}, hasRequiredTypedArrays;
function requireTypedArrays() {
    return hasRequiredTypedArrays || (hasRequiredTypedArrays = 1, function(exports) {
        var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1, MAX_16BIT_INTEGER = Math.pow(2, 16) - 1, MAX_32BIT_INTEGER = Math.pow(2, 32) - 1, MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1, MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1, MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
        exports.getPointerArray = function(size) {
            var maxIndex = size - 1;
            if (maxIndex <= MAX_8BIT_INTEGER) return Uint8Array;
            if (maxIndex <= MAX_16BIT_INTEGER) return Uint16Array;
            if (maxIndex <= MAX_32BIT_INTEGER) return Uint32Array;
            throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.");
        }, exports.getSignedPointerArray = function(size) {
            var maxIndex = size - 1;
            return maxIndex <= MAX_SIGNED_8BIT_INTEGER ? Int8Array : maxIndex <= MAX_SIGNED_16BIT_INTEGER ? Int16Array : maxIndex <= MAX_SIGNED_32BIT_INTEGER ? Int32Array : Float64Array;
        }, exports.getNumberType = function(value) {
            return value === (value | 0) ? Math.sign(value) === -1 ? value <= 127 && value >= -128 ? Int8Array : value <= 32767 && value >= -32768 ? Int16Array : Int32Array : value <= 255 ? Uint8Array : value <= 65535 ? Uint16Array : Uint32Array : Float64Array;
        };
        var TYPE_PRIORITY = {
            Uint8Array: 1,
            Int8Array: 2,
            Uint16Array: 3,
            Int16Array: 4,
            Uint32Array: 5,
            Int32Array: 6,
            Float32Array: 7,
            Float64Array: 8
        };
        exports.getMinimalRepresentation = function(array, getter) {
            var maxType = null, maxPriority = 0, p, t, v, i, l;
            for(i = 0, l = array.length; i < l; i++)v = getter ? getter(array[i]) : array[i], t = exports.getNumberType(v), p = TYPE_PRIORITY[t.name], p > maxPriority && (maxPriority = p, maxType = t);
            return maxType;
        }, exports.isTypedArray = function(value) {
            return typeof ArrayBuffer < "u" && ArrayBuffer.isView(value);
        }, exports.concat = function() {
            var length = 0, i, o, l;
            for(i = 0, l = arguments.length; i < l; i++)length += arguments[i].length;
            var array = new arguments[0].constructor(length);
            for(i = 0, o = 0; i < l; i++)array.set(arguments[i], o), o += arguments[i].length;
            return array;
        }, exports.indices = function(length) {
            for(var PointerArray = exports.getPointerArray(length), array = new PointerArray(length), i = 0; i < length; i++)array[i] = i;
            return array;
        };
    }(typedArrays)), typedArrays;
}
var iterables = {}, hasRequiredIterables;
function requireIterables() {
    if (hasRequiredIterables) return iterables;
    hasRequiredIterables = 1;
    var forEach = requireForeach(), typed = requireTypedArrays();
    function isArrayLike(target) {
        return Array.isArray(target) || typed.isTypedArray(target);
    }
    function guessLength(target) {
        if (typeof target.length == "number") return target.length;
        if (typeof target.size == "number") return target.size;
    }
    function toArray(target) {
        var l = guessLength(target), array = typeof l == "number" ? new Array(l) : [], i = 0;
        return forEach(target, function(value) {
            array[i++] = value;
        }), array;
    }
    function toArrayWithIndices(target) {
        var l = guessLength(target), IndexArray = typeof l == "number" ? typed.getPointerArray(l) : Array, array = typeof l == "number" ? new Array(l) : [], indices = typeof l == "number" ? new IndexArray(l) : [], i = 0;
        return forEach(target, function(value) {
            array[i] = value, indices[i] = i++;
        }), [
            array,
            indices
        ];
    }
    return iterables.isArrayLike = isArrayLike, iterables.guessLength = guessLength, iterables.toArray = toArray, iterables.toArrayWithIndices = toArrayWithIndices, iterables;
}
var lruCache, hasRequiredLruCache;
function requireLruCache() {
    if (hasRequiredLruCache) return lruCache;
    hasRequiredLruCache = 1;
    var Iterator = requireIterator(), forEach = requireForeach(), typed = requireTypedArrays(), iterables2 = requireIterables();
    function LRUCache(Keys, Values, capacity) {
        if (arguments.length < 2 && (capacity = Keys, Keys = null, Values = null), this.capacity = capacity, typeof this.capacity != "number" || this.capacity <= 0) throw new Error("mnemonist/lru-cache: capacity should be positive number.");
        if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity) throw new Error("mnemonist/lru-cache: capacity should be a finite positive integer.");
        var PointerArray = typed.getPointerArray(capacity);
        this.forward = new PointerArray(capacity), this.backward = new PointerArray(capacity), this.K = typeof Keys == "function" ? new Keys(capacity) : new Array(capacity), this.V = typeof Values == "function" ? new Values(capacity) : new Array(capacity), this.size = 0, this.head = 0, this.tail = 0, this.items = {};
    }
    return LRUCache.prototype.clear = function() {
        this.size = 0, this.head = 0, this.tail = 0, this.items = {};
    }, LRUCache.prototype.splayOnTop = function(pointer) {
        var oldHead = this.head;
        if (this.head === pointer) return this;
        var previous = this.backward[pointer], next = this.forward[pointer];
        return this.tail === pointer ? this.tail = previous : this.backward[next] = previous, this.forward[previous] = next, this.backward[oldHead] = pointer, this.head = pointer, this.forward[pointer] = oldHead, this;
    }, LRUCache.prototype.set = function(key, value) {
        var pointer = this.items[key];
        if (typeof pointer < "u") {
            this.splayOnTop(pointer), this.V[pointer] = value;
            return;
        }
        this.size < this.capacity ? pointer = this.size++ : (pointer = this.tail, this.tail = this.backward[pointer], delete this.items[this.K[pointer]]), this.items[key] = pointer, this.K[pointer] = key, this.V[pointer] = value, this.forward[pointer] = this.head, this.backward[this.head] = pointer, this.head = pointer;
    }, LRUCache.prototype.setpop = function(key, value) {
        var oldValue = null, oldKey = null, pointer = this.items[key];
        return typeof pointer < "u" ? (this.splayOnTop(pointer), oldValue = this.V[pointer], this.V[pointer] = value, {
            evicted: !1,
            key,
            value: oldValue
        }) : (this.size < this.capacity ? pointer = this.size++ : (pointer = this.tail, this.tail = this.backward[pointer], oldValue = this.V[pointer], oldKey = this.K[pointer], delete this.items[oldKey]), this.items[key] = pointer, this.K[pointer] = key, this.V[pointer] = value, this.forward[pointer] = this.head, this.backward[this.head] = pointer, this.head = pointer, oldKey ? {
            evicted: !0,
            key: oldKey,
            value: oldValue
        } : null);
    }, LRUCache.prototype.has = function(key) {
        return key in this.items;
    }, LRUCache.prototype.get = function(key) {
        var pointer = this.items[key];
        if (!(typeof pointer > "u")) return this.splayOnTop(pointer), this.V[pointer];
    }, LRUCache.prototype.peek = function(key) {
        var pointer = this.items[key];
        if (!(typeof pointer > "u")) return this.V[pointer];
    }, LRUCache.prototype.forEach = function(callback, scope) {
        scope = arguments.length > 1 ? scope : this;
        for(var i = 0, l = this.size, pointer = this.head, keys = this.K, values = this.V, forward = this.forward; i < l;)callback.call(scope, values[pointer], keys[pointer], this), pointer = forward[pointer], i++;
    }, LRUCache.prototype.keys = function() {
        var i = 0, l = this.size, pointer = this.head, keys = this.K, forward = this.forward;
        return new Iterator(function() {
            if (i >= l) return {
                done: !0
            };
            var key = keys[pointer];
            return i++, i < l && (pointer = forward[pointer]), {
                done: !1,
                value: key
            };
        });
    }, LRUCache.prototype.values = function() {
        var i = 0, l = this.size, pointer = this.head, values = this.V, forward = this.forward;
        return new Iterator(function() {
            if (i >= l) return {
                done: !0
            };
            var value = values[pointer];
            return i++, i < l && (pointer = forward[pointer]), {
                done: !1,
                value
            };
        });
    }, LRUCache.prototype.entries = function() {
        var i = 0, l = this.size, pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
        return new Iterator(function() {
            if (i >= l) return {
                done: !0
            };
            var key = keys[pointer], value = values[pointer];
            return i++, i < l && (pointer = forward[pointer]), {
                done: !1,
                value: [
                    key,
                    value
                ]
            };
        });
    }, typeof Symbol < "u" && (LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries), LRUCache.prototype.inspect = function() {
        for(var proxy = /* @__PURE__ */ new Map(), iterator2 = this.entries(), step; step = iterator2.next(), !step.done;)proxy.set(step.value[0], step.value[1]);
        return Object.defineProperty(proxy, "constructor", {
            value: LRUCache,
            enumerable: !1
        }), proxy;
    }, typeof Symbol < "u" && (LRUCache.prototype[Symbol.for("nodejs.util.inspect.custom")] = LRUCache.prototype.inspect), LRUCache.from = function(iterable, Keys, Values, capacity) {
        if (arguments.length < 2) {
            if (capacity = iterables2.guessLength(iterable), typeof capacity != "number") throw new Error("mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.");
        } else arguments.length === 2 && (capacity = Keys, Keys = null, Values = null);
        var cache2 = new LRUCache(Keys, Values, capacity);
        return forEach(iterable, function(value, key) {
            cache2.set(key, value);
        }), cache2;
    }, lruCache = LRUCache, lruCache;
}
var memory, hasRequiredMemory;
function requireMemory() {
    if (hasRequiredMemory) return memory;
    hasRequiredMemory = 1;
    const LRUCache = requireLruCache(), { abstractLogging } = requireUtil(), StorageInterface = require_interface(), { findMatchingIndexes, findNotMatching, bsearchIndex, wildcardMatch } = requireUtil(), setImmediate = typeof globalThis.setImmediate < "u" ? globalThis.setImmediate : (fn, ...args)=>setTimeout(fn, 0, ...args), DEFAULT_CACHE_SIZE = 1024;
    class StorageMemory extends StorageInterface {
        /**
     * in-memory storage
     * @param {StorageMemoryOptions} options
     */ constructor(options = {}){
            if (options.size && (typeof options.size != "number" || options.size < 1)) throw new Error("size must be a positive integer greater than 0");
            super(options), this.size = options.size || DEFAULT_CACHE_SIZE, this.log = options.log || abstractLogging(), this.invalidation = options.invalidation || !1, this.init();
        }
        init() {
            this.store = new LRUCache(this.size), this.invalidation && (this.keysReferences = /* @__PURE__ */ new Map(), this.referencesKeys = /* @__PURE__ */ new Map());
        }
        /**
     * retrieve the value by key
     * @param {string} key
     * @returns {undefined|*} undefined if key not found or expired
     */ get(key) {
            this.log.debug({
                msg: "acd/storage/memory.get",
                key
            });
            const entry = this.store.get(key);
            if (entry) {
                if (this.log.debug({
                    msg: "acd/storage/memory.get, entry",
                    entry,
                    now: now()
                }), entry.start + entry.ttl > now()) return this.log.debug({
                    msg: "acd/storage/memory.get, key is NOT expired",
                    key,
                    entry
                }), entry.value;
                this.log.debug({
                    msg: "acd/storage/memory.get, key is EXPIRED",
                    key,
                    entry
                }), setImmediate(()=>this.remove(key));
            }
        }
        /**
     * retrieve the remaining TTL value by key
     * @param {string} key
     * @returns {undefined|*} undefined if key not found or expired
     */ getTTL(key) {
            this.log.debug({
                msg: "acd/storage/memory.getTTL",
                key
            });
            const entry = this.store.peek(key);
            let ttl = 0;
            return entry && (ttl = entry.start + entry.ttl - now(), ttl < 0 && (ttl = 0)), ttl;
        }
        /**
     * set value by key
     * @param {string} key
     * @param {*} value
     * @param {?number} [ttl=0] - ttl in seconds; zero means key will not be stored
     * @param {?string[]} references
     */ set(key, value, ttl, references) {
            if (this.log.debug({
                msg: "acd/storage/memory.set",
                key,
                value,
                ttl,
                references
            }), ttl = Number(ttl), !ttl || ttl < 0) return;
            const existingKey = this.store.has(key), removed = this.store.setpop(key, {
                value,
                ttl,
                start: now()
            });
            if (this.log.debug({
                msg: "acd/storage/memory.set, evicted",
                removed
            }), removed && removed.evicted && (this.log.debug({
                msg: "acd/storage/memory.set, remove evicted key",
                key: removed.key
            }), this._removeReferences([
                removed.key
            ])), !references || references.length < 1) return;
            if (!this.invalidation) {
                this.log.warn({
                    msg: "acd/storage/memory.set, invalidation is disabled, references are useless"
                });
                return;
            }
            references = [
                ...new Set(references)
            ];
            let currentReferences;
            if (existingKey && (currentReferences = this.keysReferences.get(key), this.log.debug({
                msg: "acd/storage/memory.set, current keys-references",
                key,
                references: currentReferences
            }), currentReferences)) {
                currentReferences.sort(), references.sort();
                const referencesToRemove = findNotMatching(references, currentReferences);
                for (const reference of referencesToRemove){
                    const keys = this.referencesKeys.get(reference);
                    if (!keys) continue;
                    const index = bsearchIndex(keys, key);
                    if (!(index < 0)) {
                        if (keys.splice(index, 1), keys.length < 1) {
                            this.referencesKeys.delete(reference);
                            continue;
                        }
                        this.referencesKeys.set(reference, keys);
                    }
                }
            }
            const referencesToAdd = currentReferences ? findNotMatching(currentReferences, references) : references;
            for(let i = 0; i < referencesToAdd.length; i++){
                const reference = referencesToAdd[i];
                let keys = this.referencesKeys.get(reference);
                keys ? (this.log.debug({
                    msg: "acd/storage/memory.set, add reference-key",
                    key,
                    reference
                }), keys.push(key)) : keys = [
                    key
                ], this.log.debug({
                    msg: "acd/storage/memory.set, set reference-keys",
                    keys,
                    reference
                }), this.referencesKeys.set(reference, keys);
            }
            this.keysReferences.set(key, references);
        }
        /**
     * remove an entry by key
     * @param {string} key
     * @returns {boolean} indicates if key was removed
     */ remove(key) {
            this.log.debug({
                msg: "acd/storage/memory.remove",
                key
            });
            const removed = this._removeKey(key);
            return this._removeReferences([
                key
            ]), removed;
        }
        /**
     * @param {string} key
     * @returns {boolean}
     */ _removeKey(key) {
            return this.log.debug({
                msg: "acd/storage/memory._removeKey",
                key
            }), this.store.has(key) ? (this.store.set(key, void 0), !0) : !1;
        }
        /**
     * @param {string[]} keys
     */ _removeReferences(keys) {
            if (!this.invalidation) return;
            this.log.debug({
                msg: "acd/storage/memory._removeReferences",
                keys
            });
            const referencesToRemove = /* @__PURE__ */ new Set();
            for(let i = 0; i < keys.length; i++){
                const key = keys[i], references = this.keysReferences.get(key);
                if (references) {
                    for(let j = 0; j < references.length; j++)referencesToRemove.add(references[j]);
                    this.log.debug({
                        msg: "acd/storage/memory._removeReferences, delete key-references",
                        key
                    }), this.keysReferences.delete(key);
                }
            }
            this._removeReferencesKeys([
                ...referencesToRemove
            ], keys);
        }
        /**
     * @param {!string[]} references
     * @param {string[]} keys
     */ _removeReferencesKeys(references, keys) {
            keys.sort(), this.log.debug({
                msg: "acd/storage/memory._removeReferencesKeys",
                references,
                keys
            });
            for(let i = 0; i < references.length; i++){
                const reference = references[i], referencesKeys = this.referencesKeys.get(reference);
                if (this.log.debug({
                    msg: "acd/storage/memory._removeReferencesKeys, get reference-key",
                    reference,
                    keys,
                    referencesKeys
                }), !referencesKeys) continue;
                const referencesToRemove = findMatchingIndexes(keys, referencesKeys);
                if (this.log.debug({
                    msg: "acd/storage/memory._removeReferencesKeys, removing",
                    reference,
                    referencesToRemove,
                    referencesKeys
                }), referencesToRemove.length === referencesKeys.length) {
                    this.log.debug({
                        msg: "acd/storage/memory._removeReferencesKeys, delete",
                        reference
                    }), this.referencesKeys.delete(reference);
                    continue;
                }
                for(let j = referencesToRemove.length - 1; j >= 0; j--)this.log.debug({
                    msg: "acd/storage/memory._removeReferencesKeys, remove",
                    reference,
                    referencesKeys,
                    at: referencesToRemove[j]
                }), referencesKeys.splice(referencesToRemove[j], 1);
            }
        }
        /**
     * @param {string|string[]} references
     * @returns {string[]} removed keys
     */ invalidate(references) {
            return this.invalidation ? (this.log.debug({
                msg: "acd/storage/memory.invalidate",
                references
            }), Array.isArray(references) ? this._invalidateReferences(references) : this._invalidateReference(references)) : (this.log.warn({
                msg: "acd/storage/memory.invalidate, exit due invalidation is disabled"
            }), []);
        }
        /**
     * @param {string[]} references
     * @returns {string[]} removed keys
     */ _invalidateReferences(references) {
            const removed = [];
            for(let i = 0; i < references.length; i++){
                const reference = references[i], keys = this.referencesKeys.get(reference);
                if (this.log.debug({
                    msg: "acd/storage/memory._invalidateReferences, remove keys on reference",
                    reference,
                    keys
                }), !!keys) {
                    for(let j = 0; j < keys.length; j++){
                        const key = keys[j];
                        this.log.debug({
                            msg: "acd/storage/memory._invalidateReferences, remove key on reference",
                            reference,
                            key
                        }), this._removeKey(key) && removed.push(key);
                    }
                    this.log.debug({
                        msg: "acd/storage/memory._invalidateReferences, remove references of",
                        reference,
                        keys
                    }), this._removeReferences([
                        ...keys
                    ]);
                }
            }
            return removed;
        }
        /**
     * @param {string} reference
     * @returns {string[]} removed keys
     */ _invalidateReference(reference) {
            if (reference.includes("*")) {
                const references = [];
                for (const key of this.referencesKeys.keys())wildcardMatch(reference, key) && references.push(key);
                return this._invalidateReferences(references);
            }
            const keys = this.referencesKeys.get(reference), removed = [];
            if (this.log.debug({
                msg: "acd/storage/memory._invalidateReference, remove keys on reference",
                reference,
                keys
            }), !keys) return removed;
            for(let j = 0; j < keys.length; j++){
                const key = keys[j];
                this.log.debug({
                    msg: "acd/storage/memory._invalidateReference, remove key on reference",
                    reference,
                    key
                }), this._removeKey(key) && removed.push(key);
            }
            return this.log.debug({
                msg: "acd/storage/memory._invalidateReference, remove references of",
                reference,
                keys
            }), this._removeReferences([
                ...keys
            ]), removed;
        }
        /**
     * remove all entries if name is not provided
     * remove entries where key starts with name if provided
     * @param {?string} name
     * @return {string[]} removed keys
     */ clear(name) {
            if (this.log.debug({
                msg: "acd/storage/memory.clear",
                name
            }), !name) {
                if (this.store.clear(), !this.invalidation) return;
                this.referencesKeys.clear(), this.keysReferences.clear();
                return;
            }
            const keys = [];
            this.store.forEach((value, key)=>{
                this.log.debug({
                    msg: "acd/storage/memory.clear, iterate key",
                    key
                }), key.indexOf(name) === 0 && (this.log.debug({
                    msg: "acd/storage/memory.clear, remove key",
                    key
                }), keys.push(key));
            });
            const removed = [];
            for(let i = 0; i < keys.length; i++)this._removeKey(keys[i]) && removed.push(keys[i]);
            return this._removeReferences(removed), removed;
        }
        refresh() {
            this.log.debug({
                msg: "acd/storage/memory.refresh"
            }), this.init();
        }
    }
    let _timer;
    function now() {
        if (_timer !== void 0) return _timer;
        _timer = Math.floor(Date.now() / 1e3);
        const timeout = setTimeout(_clearTimer, 1e3);
        return typeof timeout.unref == "function" && timeout.unref(), _timer;
    }
    function _clearTimer() {
        _timer = void 0;
    }
    return memory = StorageMemory, memory;
}
var storage, hasRequiredStorage;
function requireStorage() {
    if (hasRequiredStorage) return storage;
    hasRequiredStorage = 1;
    const { isServerSide } = requireUtil();
    let StorageRedis;
    isServerSide && (StorageRedis = requireRedis());
    const StorageMemory = requireMemory(), StorageOptionsType = {
        redis: "redis"
    };
    function createStorage(type, options) {
        if (!isServerSide && type === StorageOptionsType.redis) throw new Error("Redis storage is not supported in the browser");
        return type === StorageOptionsType.redis ? new StorageRedis(options) : new StorageMemory(options);
    }
    return storage = createStorage, storage;
}
var hasRequiredCache;
function requireCache() {
    if (hasRequiredCache) return cache;
    hasRequiredCache = 1;
    const { kValues, kStorage, kStorages, kTransfromer, kTTL, kOnDedupe, kOnError, kOnHit, kOnMiss, kStale } = requireSymbol(), stringify = requireSafeStableStringify(), createStorage = requireStorage();
    class Cache {
        /**
     * @param {!Object} opts
     * @param {!Storage} opts.storage - the storage to use
     * @param {?Object} opts.transformer - the transformer to use
     * @param {?number} [opts.ttl=0] - in seconds; default is 0 seconds, so it only does dedupe without cache
     * @param {?function} opts.onDedupe
     * @param {?function} opts.onError
     * @param {?function} opts.onHit
     * @param {?function} opts.onMiss
     */ constructor(options = {}){
            if (!options.storage) throw new Error("storage is required");
            if (options.ttl && typeof options.ttl == "number" && (options.ttl < 0 || !Number.isInteger(options.ttl))) throw new Error("ttl must be a positive integer greater than 0");
            if (options.onDedupe && typeof options.onDedupe != "function") throw new Error("onDedupe must be a function");
            if (options.onError && typeof options.onError != "function") throw new Error("onError must be a function");
            if (options.onHit && typeof options.onHit != "function") throw new Error("onHit must be a function");
            if (options.onMiss && typeof options.onMiss != "function") throw new Error("onMiss must be a function");
            if (typeof options.stale == "number" && !(Math.floor(options.stale) === options.stale && options.stale >= 0)) throw new Error("stale must be an integer greater or equal to 0");
            this[kValues] = {}, this[kStorage] = options.storage, this[kStorages] = /* @__PURE__ */ new Map(), this[kStorages].set("_default", options.storage), this[kTransfromer] = options.transformer, this[kTTL] = options.ttl || 0, this[kOnDedupe] = options.onDedupe || noop, this[kOnError] = options.onError || noop, this[kOnHit] = options.onHit || noop, this[kOnMiss] = options.onMiss || noop, this[kStale] = options.stale || 0;
        }
        /**
     * add a new function to dedupe (and cache)
     * @param {!string} name name of the function
     * @param {?Object} [opts]
     * @param {?Object} [opts.storage] storage to use; default is the main one
     * @param {?Object} opts.transformer - the transformer to use
     * @param {?number} [opts.ttl] ttl for the results; default ttl is the one passed to the constructor
     * @param {?function} [opts.onDedupe] function to call on dedupe; default is the one passed to the constructor
     * @param {?function} [opts.onError] function to call on error; default is the one passed to the constructor
     * @param {?function} [opts.onHit] function to call on hit; default is the one passed to the constructor
     * @param {?function} [opts.onMiss] function to call on miss; default is the one passed to the constructor
     * @param {?function} [opts.serialize] custom function to serialize the arguments of `func`, in order to create the key for deduping and caching
     * @param {?function} [opts.references] function to generate references
     * @param {!function} func the function to dedupe (and cache)
     **/ define(name, opts, func) {
            if (typeof opts == "function" && (func = opts, opts = {}), name && this[name]) throw new Error(`${name} is already defined in the cache or it is a forbidden name`);
            if (opts = opts || {}, typeof func != "function") throw new TypeError(`Missing the function parameter for '${name}'`);
            const serialize = opts.serialize;
            if (serialize && typeof serialize != "function") throw new TypeError("serialize must be a function");
            const references = opts.references;
            if (references && typeof references != "function") throw new TypeError("references must be a function");
            if (typeof opts.ttl != "function" && opts.ttl && (typeof opts.ttl != "number" || opts.ttl < 0 || !Number.isInteger(opts.ttl))) throw new Error("ttl must be a positive integer greater than 0");
            let storage2;
            opts.storage ? (storage2 = createStorage(opts.storage.type, opts.storage.options), this[kStorages].set(name, storage2)) : storage2 = this[kStorage];
            const ttl = opts.ttl !== void 0 ? opts.ttl : this[kTTL], stale = opts.stale !== void 0 ? opts.stale : this[kStale], onDedupe = opts.onDedupe || this[kOnDedupe], onError = opts.onError || this[kOnError], onHit = opts.onHit || this[kOnHit], onMiss = opts.onMiss || this[kOnMiss], transformer = opts.transformer || this[kTransfromer], wrapper = new Wrapper(func, name, serialize, references, storage2, transformer, ttl, onDedupe, onError, onHit, onMiss, stale);
            return this[kValues][name] = wrapper, this[name] = wrapper.add.bind(wrapper), this;
        }
        async clear(name, value) {
            if (name) {
                if (!this[kValues][name]) throw new Error(`${name} is not defined in the cache`);
                await this[kValues][name].clear(value);
                return;
            }
            const clears = [];
            for (const wrapper of Object.values(this[kValues]))clears.push(wrapper.clear());
            await Promise.all(clears);
        }
        async get(name, key) {
            if (!this[kValues][name]) throw new Error(`${name} is not defined in the cache`);
            return this[kValues][name].get(key);
        }
        async set(name, key, value, ttl, references) {
            if (!this[kValues][name]) throw new Error(`${name} is not defined in the cache`);
            return this[kValues][name].set(key, value, ttl, references);
        }
        async invalidate(name, references) {
            if (!this[kValues][name]) throw new Error(`${name} is not defined in the cache`);
            return this[kValues][name].invalidate(references);
        }
        async invalidateAll(references, storage2 = "_default") {
            if (!this[kStorages].has(storage2)) throw new Error(`${storage2} storage is not defined in the cache`);
            await this[kStorages].get(storage2).invalidate(references);
        }
    }
    class Wrapper {
        /**
     * @param {function} func
     * @param {string} name
     * @param {function} serialize
     * @param {function} references
     * @param {Storage} storage
     * @param {Object} transformer
     * @param {number} ttl
     * @param {function} onDedupe
     * @param {function} onError
     * @param {function} onHit
     * @param {function} onMiss
     * @param {stale} ttl
     */ constructor(func, name, serialize, references, storage2, transformer, ttl, onDedupe, onError, onHit, onMiss, stale){
            this.dedupes = /* @__PURE__ */ new Map(), this.func = func, this.name = name, this.serialize = serialize, this.references = references, this.storage = storage2, this.transformer = transformer, this.ttl = ttl, this.onDedupe = onDedupe, this.onError = onError, this.onHit = onHit, this.onMiss = onMiss, this.stale = stale;
        }
        getKey(args) {
            const id = this.serialize ? this.serialize(args) : args;
            return typeof id == "string" ? id : stringify(id);
        }
        getStorageKey(key) {
            return `${this.name}~${key}`;
        }
        getStorageName() {
            return `${this.name}~`;
        }
        add(args) {
            try {
                const key = this.getKey(args);
                let query = this.dedupes.get(key);
                return query ? this.onDedupe(key) : (query = new Query(), this.buildPromise(query, args, key), this.dedupes.set(key, query)), query.promise;
            } catch (err) {
                this.onError(err);
            }
        }
        /**
     * wrap the original func to sync storage
     */ async wrapFunction(args, key) {
            const storageKey = this.getStorageKey(key);
            if (this.ttl > 0 || typeof this.ttl == "function") {
                const data = await this.get(storageKey);
                if (data !== void 0) {
                    this.onHit(key);
                    const stale = typeof this.stale == "function" ? this.stale(data) : this.stale;
                    return stale > 0 && await this.storage.getTTL(storageKey) <= stale && this._wrapFunction(storageKey, args, key).catch(noop), data;
                } else this.onMiss(key);
            }
            return this._wrapFunction(storageKey, args, key);
        }
        async _wrapFunction(storageKey, args, key) {
            const result = await this.func(args, key), stale = typeof this.stale == "function" ? this.stale(result) : this.stale;
            let ttl = typeof this.ttl == "function" ? this.ttl(result) : this.ttl;
            if (ttl == null || typeof ttl != "number" || !Number.isInteger(ttl)) return this.onError(new Error("ttl must be an integer")), result;
            if (ttl += stale, ttl < 1) return result;
            if (!this.references) return await this.set(storageKey, result, ttl), result;
            try {
                let references = this.references(args, key, result), value = result;
                references && typeof references.then == "function" && (references = await references), this.transformer && (value = this.transformer.serialize(result)), await this.storage.set(storageKey, value, ttl, references);
            } catch (err) {
                this.onError(err);
            }
            return result;
        }
        buildPromise(query, args, key) {
            query.promise = this.wrapFunction(args, key), query.promise.then((result)=>(this.dedupes.delete(key), result)).catch((err)=>{
                this.onError(err), this.dedupes.delete(key);
                const r = this.storage.remove(this.getStorageKey(key));
                r && typeof r.catch == "function" && r.catch(noop);
            });
        }
        async clear(value) {
            if (value) {
                const key = this.getKey(value);
                this.dedupes.delete(key), await this.storage.remove(this.getStorageKey(key));
                return;
            }
            await this.storage.clear(this.getStorageName()), this.dedupes.clear();
        }
        async get(key) {
            const data = await this.storage.get(key);
            return this.transformer && data ? await this.transformer.deserialize(data) : data;
        }
        async set(key, value, ttl, references) {
            return this.transformer && (value = this.transformer.serialize(value)), this.storage.set(key, value, ttl, references);
        }
        async invalidate(references) {
            return this.storage.invalidate(references);
        }
    }
    class Query {
        constructor(){
            this.promise = null;
        }
    }
    function noop() {}
    return cache.Cache = Cache, cache;
}
var asyncCacheDedupe, hasRequiredAsyncCacheDedupe;
function requireAsyncCacheDedupe() {
    if (hasRequiredAsyncCacheDedupe) return asyncCacheDedupe;
    hasRequiredAsyncCacheDedupe = 1;
    const { Cache } = requireCache(), createStorage = requireStorage();
    function createCache(options) {
        options ? options.storage || (options.storage = {
            type: "memory"
        }) : options = {
            storage: {
                type: "memory"
            }
        };
        const storage2 = createStorage(options.storage.type, options.storage.options);
        return new Cache({
            ...options,
            storage: storage2
        });
    }
    return asyncCacheDedupe = {
        Cache,
        createCache,
        createStorage
    }, asyncCacheDedupe;
}
var asyncCacheDedupeExports = requireAsyncCacheDedupe();
let tasks = 0, resolves = [];
function startTask() {
    return tasks += 1, ()=>{
        if (tasks -= 1, tasks === 0) {
            let prevResolves = resolves;
            resolves = [];
            for (let i of prevResolves)i();
        }
    };
}
let clean = Symbol("clean"), listenerQueue = [], lqIndex = 0;
const QUEUE_ITEMS_PER_LISTENER = 4;
let atom = (initialValue)=>{
    let listeners = [], $atom = {
        get () {
            return $atom.lc || $atom.listen(()=>{})(), $atom.value;
        },
        lc: 0,
        listen (listener) {
            return $atom.lc = listeners.push(listener), ()=>{
                for(let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length;)listenerQueue[i] === listener ? listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER) : i += QUEUE_ITEMS_PER_LISTENER;
                let index = listeners.indexOf(listener);
                ~index && (listeners.splice(index, 1), --$atom.lc || $atom.off());
            };
        },
        notify (oldValue, changedKey) {
            let runListenerQueue = !listenerQueue.length;
            for (let listener of listeners)listenerQueue.push(listener, $atom.value, oldValue, changedKey);
            if (runListenerQueue) {
                for(lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER)listenerQueue[lqIndex](listenerQueue[lqIndex + 1], listenerQueue[lqIndex + 2], listenerQueue[lqIndex + 3]);
                listenerQueue.length = 0;
            }
        },
        /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */ off () {},
        set (newValue) {
            let oldValue = $atom.value;
            oldValue !== newValue && ($atom.value = newValue, $atom.notify(oldValue));
        },
        subscribe (listener) {
            let unbind = $atom.listen(listener);
            return listener($atom.value), unbind;
        },
        value: initialValue
    };
    return ("TURBOPACK compile-time value", "development") !== "production" && ($atom[clean] = ()=>{
        listeners = [], $atom.lc = 0, $atom.off();
    }), $atom;
};
const MOUNT = 5, UNMOUNT = 6, REVERT_MUTATION = 10;
let on = (object, listener, eventKey, mutateStore)=>(object.events = object.events || {}, object.events[eventKey + REVERT_MUTATION] || (object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps)=>{
        object.events[eventKey].reduceRight((event, l)=>(l(event), event), {
            shared: {},
            ...eventProps
        });
    })), object.events[eventKey] = object.events[eventKey] || [], object.events[eventKey].push(listener), ()=>{
        let currentListeners = object.events[eventKey], index = currentListeners.indexOf(listener);
        currentListeners.splice(index, 1), currentListeners.length || (delete object.events[eventKey], object.events[eventKey + REVERT_MUTATION](), delete object.events[eventKey + REVERT_MUTATION]);
    }), STORE_UNMOUNT_DELAY = 1e3, onMount = ($store, initialize)=>on($store, (payload)=>{
        let destroy = initialize(payload);
        destroy && $store.events[UNMOUNT].push(destroy);
    }, MOUNT, (runListeners)=>{
        let originListen = $store.listen;
        $store.listen = (...args)=>(!$store.lc && !$store.active && ($store.active = !0, runListeners()), originListen(...args));
        let originOff = $store.off;
        if ("TURBOPACK compile-time truthy", 1) {
            let originClean = $store[clean];
            $store[clean] = ()=>{
                for (let destroy of $store.events[UNMOUNT])destroy();
                $store.events[UNMOUNT] = [], $store.active = !1, originClean();
            };
        }
        return ()=>{
            $store.listen = originListen, $store.off = originOff;
        };
    }), map = (initial = {})=>{
    let $map = atom(initial);
    return $map.setKey = function(key, value) {
        let oldMap = $map.value;
        typeof value > "u" && key in $map.value ? ($map.value = {
            ...$map.value
        }, delete $map.value[key], $map.notify(oldMap, key)) : $map.value[key] !== value && ($map.value = {
            ...$map.value,
            [key]: value
        }, $map.notify(oldMap, key));
    }, $map;
};
const runtime = typeof document > "u" ? "server" : "browser", defineEnableLiveMode = (config)=>{
    const { ssr, setFetcher } = config;
    return (options)=>{
        if (runtime === "server") throw new Error("Live mode is not supported in server environments");
        if (ssr && !options.client) throw new Error("The `client` option in `enableLiveMode` is required");
        const client = options.client || config.client || void 0, controller = new AbortController();
        let disableLiveMode;
        return __turbopack_context__.A("[project]/node_modules/@sanity/core-loader/dist/_chunks-es/enableLiveMode.js [app-client] (ecmascript, async loader)").then(({ enableLiveMode })=>{
            controller.signal.aborted || (disableLiveMode = enableLiveMode({
                ...options,
                client,
                setFetcher,
                ssr
            }));
        }), ()=>{
            controller.abort(), disableLiveMode?.();
        };
    };
};
function cloneClientWithConfig(newClient) {
    return newClient.withConfig({
        allowReconfigure: !1
    });
}
const createQueryStore = (options)=>{
    const { ssr = !1, tag = "core-loader" } = options;
    if (ssr && options.client) throw new TypeError("`client` option is not allowed when `ssr: true`, use `setServerClient` from your server entry point instead");
    if (!ssr && options.client === !1) throw new TypeError("You must set `ssr: true` when `client: false` is used");
    if (!ssr && !options.client) throw new TypeError("`client` is required");
    let client = ssr ? void 0 : cloneClientWithConfig(options.client);
    function createDefaultCache(client2) {
        return asyncCacheDedupeExports.createCache().define("fetch", async (key)=>{
            if (!client2) throw new Error("You have to set the Sanity client with `setServerClient` before any data fetching is done");
            const { query, params = {}, perspective, useCdn, stega } = JSON.parse(key), { result, resultSourceMap } = await client2.fetch(query, params, {
                tag,
                filterResponse: !1,
                perspective,
                useCdn,
                stega
            });
            return {
                result,
                resultSourceMap
            };
        });
    }
    function createDefaultFetcher() {
        const initialPerspective = client?.config().perspective || "published";
        return unstable__cache.instance = createDefaultCache(client), {
            hydrate: (_query, _params, initial)=>({
                    loading: initial?.data === void 0 || initial?.sourceMap === void 0,
                    error: void 0,
                    data: initial?.data,
                    sourceMap: initial?.sourceMap,
                    perspective: initialPerspective
                }),
            fetch: (query, params, $fetch, controller)=>{
                if (controller.signal.aborted) return;
                const finishTask = startTask();
                $fetch.setKey("loading", !0), $fetch.setKey("error", void 0), unstable__cache.instance.fetch(JSON.stringify({
                    query,
                    params
                })).then((response)=>{
                    controller.signal.aborted || ($fetch.setKey("data", response.result), $fetch.setKey("sourceMap", response.resultSourceMap), $fetch.setKey("perspective", initialPerspective));
                }).catch((reason)=>{
                    $fetch.setKey("error", reason);
                }).finally(()=>{
                    $fetch.setKey("loading", !1), finishTask();
                });
            }
        };
    }
    const unstable__cache = {
        instance: createDefaultCache(client)
    }, $fetcher = atom(client ? createDefaultFetcher() : void 0), enableLiveMode = defineEnableLiveMode({
        client: client || void 0,
        ssr,
        setFetcher: (fetcher)=>{
            const originalFetcher = $fetcher.get();
            return $fetcher.set(fetcher), ()=>$fetcher.set(originalFetcher);
        }
    }), createFetcherStore = (query, params = {}, initial)=>{
        const fetcher = $fetcher.get(), $fetch = map(fetcher ? fetcher.hydrate(query, params, initial) : {
            loading: !1,
            error: typeof initial?.data > "u" ? new Error("The `initial` option is required when `ssr: true`") : void 0,
            data: initial?.data,
            sourceMap: initial?.sourceMap,
            perspective: initial?.perspective
        });
        return onMount($fetch, ()=>{
            let controller = new AbortController();
            const unsubscribe = $fetcher.subscribe((fetcher2)=>{
                !fetcher2 || controller.signal.aborted || (controller.abort(), controller = new AbortController(), fetcher2.fetch(query, params, $fetch, controller));
            });
            return ()=>{
                controller.abort(), unsubscribe();
            };
        }), $fetch;
    }, unstable__serverClient = {
        instance: void 0,
        canPreviewDrafts: !1
    };
    return {
        createFetcherStore,
        enableLiveMode,
        setServerClient: (newClient)=>{
            if (runtime !== "server") throw new Error("`setServerClient` can only be called in server environments, detected: " + JSON.stringify(runtime));
            if (!ssr) throw new Error("`setServerClient` can only be called when `ssr: true`");
            unstable__serverClient.instance = client = cloneClientWithConfig(newClient), unstable__serverClient.canPreviewDrafts = !!client.config().token, $fetcher.set(createDefaultFetcher());
        },
        unstable__cache,
        unstable__serverClient
    };
};
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/client/dist/_chunks-es/isRecord.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isRecord",
    ()=>isRecord
]);
function isRecord(value) {
    return typeof value == "object" && value !== null && !Array.isArray(value);
}
;
 //# sourceMappingURL=isRecord.js.map
}),
"[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DRAFTS_FOLDER",
    ()=>DRAFTS_FOLDER,
    "VERSION_FOLDER",
    ()=>VERSION_FOLDER,
    "createEditUrl",
    ()=>createEditUrl,
    "get",
    ()=>get,
    "getDraftId",
    ()=>getDraftId,
    "getPublishedId",
    ()=>getPublishedId,
    "getVersionFromId",
    ()=>getVersionFromId,
    "getVersionId",
    ()=>getVersionId,
    "isDraftId",
    ()=>isDraftId,
    "isPublishedId",
    ()=>isPublishedId,
    "isVersionId",
    ()=>isVersionId,
    "jsonPath",
    ()=>jsonPath,
    "jsonPathToStudioPath",
    ()=>jsonPathToStudioPath,
    "parseJsonPath",
    ()=>parseJsonPath,
    "reKeySegment",
    ()=>reKeySegment,
    "resolveEditInfo",
    ()=>resolveEditInfo,
    "resolveMapping",
    ()=>resolveMapping,
    "resolveStudioBaseRoute",
    ()=>resolveStudioBaseRoute,
    "studioPath",
    ()=>studioPath,
    "studioPathToJsonPath",
    ()=>studioPathToJsonPath,
    "toString",
    ()=>toString,
    "walkMap",
    ()=>walkMap
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$isRecord$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/isRecord.js [app-client] (ecmascript)");
;
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if (isIndexSegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if (isKeySegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
function toString(path) {
    if (!Array.isArray(path)) throw new Error("Path is not an array");
    return path.reduce((target, segment, i)=>{
        const segmentType = typeof segment;
        if (segmentType === "number") return `${target}[${segment}]`;
        if (segmentType === "string") return `${target}${i === 0 ? "" : "."}${segment}`;
        if (isKeySegment(segment) && segment._key) return `${target}[_key=="${segment._key}"]`;
        if (Array.isArray(segment)) {
            const [from, to] = segment;
            return `${target}[${from}:${to}]`;
        }
        throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
    }, "");
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(parsePathSegment);
}
function parsePathSegment(segment) {
    return isIndexSegment(segment) ? parseIndexSegment(segment) : isKeySegment(segment) ? parseKeySegment(segment) : isIndexTuple(segment) ? parseIndexTupleSegment(segment) : segment;
}
function parseIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function parseKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function parseIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
var studioPath = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fromString,
    get,
    isIndexSegment,
    isIndexTuple,
    isKeySegment,
    reKeySegment,
    toString
});
const DRAFTS_FOLDER = "drafts", VERSION_FOLDER = "versions", PATH_SEPARATOR = ".", DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`, VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;
function isDraftId(id) {
    return id.startsWith(DRAFTS_PREFIX);
}
function isVersionId(id) {
    return id.startsWith(VERSION_PREFIX);
}
function isPublishedId(id) {
    return !isDraftId(id) && !isVersionId(id);
}
function getDraftId(id) {
    if (isVersionId(id)) {
        const publishedId = getPublishedId(id);
        return DRAFTS_PREFIX + publishedId;
    }
    return isDraftId(id) ? id : DRAFTS_PREFIX + id;
}
function getVersionId(id, version) {
    if (version === "drafts" || version === "published") throw new Error('Version can not be "published" or "drafts"');
    return `${VERSION_PREFIX}${version}${PATH_SEPARATOR}${getPublishedId(id)}`;
}
function getVersionFromId(id) {
    if (!isVersionId(id)) return;
    const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);
    return versionId;
}
function getPublishedId(id) {
    return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;
}
const ESCAPE = {
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "'": "\\'",
    "\\": "\\\\"
}, UNESCAPE = {
    "\\f": "\f",
    "\\n": `
`,
    "\\r": "\r",
    "\\t": "	",
    "\\'": "'",
    "\\\\": "\\"
};
function jsonPath(path) {
    return `$${path.map((segment)=>typeof segment == "string" ? `['${segment.replace(/[\f\n\r\t'\\]/g, (match)=>ESCAPE[match])}']` : typeof segment == "number" ? `[${segment}]` : segment._key !== "" ? `[?(@._key=='${segment._key.replace(/['\\]/g, (match)=>ESCAPE[match])}')]` : `[${segment._index}]`).join("")}`;
}
function jsonPathArray(path) {
    return path.map((segment)=>typeof segment == "string" ? `['${segment.replace(/[\f\n\r\t'\\]/g, (match)=>ESCAPE[match])}']` : typeof segment == "number" ? `[${segment}]` : segment._key !== "" ? `[?(@._key=='${segment._key.replace(/['\\]/g, (match)=>ESCAPE[match])}')]` : `[${segment._index}]`);
}
function parseJsonPath(path) {
    const parsed = [], parseRe = /\['(.*?)'\]|\[(\d+)\]|\[\?\(@\._key=='(.*?)'\)\]/g;
    let match;
    for(; (match = parseRe.exec(path)) !== null;){
        if (match[1] !== void 0) {
            const key = match[1].replace(/\\(\\|f|n|r|t|')/g, (m)=>UNESCAPE[m]);
            parsed.push(key);
            continue;
        }
        if (match[2] !== void 0) {
            parsed.push(parseInt(match[2], 10));
            continue;
        }
        if (match[3] !== void 0) {
            const _key = match[3].replace(/\\(\\')/g, (m)=>UNESCAPE[m]);
            parsed.push({
                _key,
                _index: -1
            });
            continue;
        }
    }
    return parsed;
}
function jsonPathToStudioPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._key !== "") return {
            _key: segment._key
        };
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function studioPathToJsonPath(path) {
    return (typeof path == "string" ? fromString(path) : path).map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (Array.isArray(segment)) throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`);
        if (isContentSourceMapParsedPathKeyedSegment(segment)) return segment;
        if (segment._key) return {
            _key: segment._key,
            _index: -1
        };
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function isContentSourceMapParsedPathKeyedSegment(segment) {
    return typeof segment == "object" && "_key" in segment && "_index" in segment;
}
function jsonPathToMappingPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function resolveMapping(resultPath, csm) {
    if (!csm?.mappings) return;
    const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));
    if (csm.mappings[resultMappingPath] !== void 0) return {
        mapping: csm.mappings[resultMappingPath],
        matchedPath: resultMappingPath,
        pathSuffix: ""
    };
    const resultMappingPathArray = jsonPathArray(jsonPathToMappingPath(resultPath));
    for(let i = resultMappingPathArray.length - 1; i > 0; i--){
        const key = `$${resultMappingPathArray.slice(0, i).join("")}`, mappingFound = csm.mappings[key];
        if (mappingFound) {
            const pathSuffix = resultMappingPath.substring(key.length);
            return {
                mapping: mappingFound,
                matchedPath: key,
                pathSuffix
            };
        }
    }
}
function isArray(value) {
    return value !== null && Array.isArray(value);
}
function walkMap(value, mappingFn, path = []) {
    if (isArray(value)) return value.map((v, idx)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$isRecord$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRecord"])(v)) {
            const _key = v._key;
            if (typeof _key == "string") return walkMap(v, mappingFn, path.concat({
                _key,
                _index: idx
            }));
        }
        return walkMap(v, mappingFn, path.concat(idx));
    });
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$isRecord$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRecord"])(value)) {
        if (value._type === "block" || value._type === "span") {
            const result = {
                ...value
            };
            return value._type === "block" ? result.children = walkMap(value.children, mappingFn, path.concat("children")) : value._type === "span" && (result.text = walkMap(value.text, mappingFn, path.concat("text"))), result;
        }
        return Object.fromEntries(Object.entries(value).map(([k, v])=>[
                k,
                walkMap(v, mappingFn, path.concat(k))
            ]));
    }
    return mappingFn(value, path);
}
function createEditUrl(options) {
    const { baseUrl, workspace: _workspace = "default", tool: _tool = "default", id: _id, type, path, projectId, dataset } = options;
    if (!baseUrl) throw new Error("baseUrl is required");
    if (!path) throw new Error("path is required");
    if (!_id) throw new Error("id is required");
    if (baseUrl !== "/" && baseUrl.endsWith("/")) throw new Error("baseUrl must not end with a slash");
    const workspace = _workspace === "default" ? void 0 : _workspace, tool = _tool === "default" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({
        baseUrl,
        id,
        type,
        path: stringifiedPath
    });
    if (workspace && searchParams.set("workspace", workspace), tool && searchParams.set("tool", tool), projectId && searchParams.set("projectId", projectId), dataset && searchParams.set("dataset", dataset), isPublishedId(_id)) searchParams.set("perspective", "published");
    else if (isVersionId(_id)) {
        const versionId = getVersionFromId(_id);
        searchParams.set("perspective", versionId);
    }
    const segments = [
        baseUrl === "/" ? "" : baseUrl
    ];
    workspace && segments.push(workspace);
    const routerParams = [
        "mode=presentation",
        `id=${id}`,
        `type=${type}`,
        `path=${encodeURIComponent(stringifiedPath)}`
    ];
    return tool && routerParams.push(`tool=${tool}`), segments.push("intent", "edit", `${routerParams.join(";")}?${searchParams}`), segments.join("/");
}
function resolveEditInfo(options) {
    const { resultSourceMap: csm, resultPath } = options, { mapping, pathSuffix } = resolveMapping(resultPath, csm) || {};
    if (!mapping || mapping.source.type === "literal" || mapping.source.type === "unknown") return;
    const sourceDoc = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path];
    if (sourceDoc && sourcePath) {
        const { baseUrl, workspace, tool } = resolveStudioBaseRoute(typeof options.studioUrl == "function" ? options.studioUrl(sourceDoc) : options.studioUrl);
        if (!baseUrl) return;
        const { _id, _type, _projectId, _dataset } = sourceDoc;
        return {
            baseUrl,
            workspace,
            tool,
            id: _id,
            type: _type,
            path: parseJsonPath(sourcePath + pathSuffix),
            projectId: _projectId,
            dataset: _dataset
        };
    }
}
function resolveStudioBaseRoute(studioUrl) {
    let baseUrl = typeof studioUrl == "string" ? studioUrl : studioUrl.baseUrl;
    return baseUrl !== "/" && (baseUrl = baseUrl.replace(/\/$/, "")), typeof studioUrl == "string" ? {
        baseUrl
    } : {
        ...studioUrl,
        baseUrl
    };
}
;
 //# sourceMappingURL=resolveEditInfo.js.map
}),
"[project]/node_modules/valibot/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/storages/globalConfig/globalConfig.ts
__turbopack_context__.s([
    "BASE64_REGEX",
    ()=>BASE64_REGEX,
    "BIC_REGEX",
    ()=>BIC_REGEX,
    "CUID2_REGEX",
    ()=>CUID2_REGEX,
    "DECIMAL_REGEX",
    ()=>DECIMAL_REGEX,
    "DIGITS_REGEX",
    ()=>DIGITS_REGEX,
    "EMAIL_REGEX",
    ()=>EMAIL_REGEX,
    "EMOJI_REGEX",
    ()=>EMOJI_REGEX,
    "HEXADECIMAL_REGEX",
    ()=>HEXADECIMAL_REGEX,
    "HEX_COLOR_REGEX",
    ()=>HEX_COLOR_REGEX,
    "IMEI_REGEX",
    ()=>IMEI_REGEX,
    "IPV4_REGEX",
    ()=>IPV4_REGEX,
    "IPV6_REGEX",
    ()=>IPV6_REGEX,
    "IP_REGEX",
    ()=>IP_REGEX,
    "ISO_DATE_REGEX",
    ()=>ISO_DATE_REGEX,
    "ISO_DATE_TIME_REGEX",
    ()=>ISO_DATE_TIME_REGEX,
    "ISO_TIMESTAMP_REGEX",
    ()=>ISO_TIMESTAMP_REGEX,
    "ISO_TIME_REGEX",
    ()=>ISO_TIME_REGEX,
    "ISO_TIME_SECOND_REGEX",
    ()=>ISO_TIME_SECOND_REGEX,
    "ISO_WEEK_REGEX",
    ()=>ISO_WEEK_REGEX,
    "MAC48_REGEX",
    ()=>MAC48_REGEX,
    "MAC64_REGEX",
    ()=>MAC64_REGEX,
    "MAC_REGEX",
    ()=>MAC_REGEX,
    "NANO_ID_REGEX",
    ()=>NANO_ID_REGEX,
    "OCTAL_REGEX",
    ()=>OCTAL_REGEX,
    "RFC_EMAIL_REGEX",
    ()=>RFC_EMAIL_REGEX,
    "SLUG_REGEX",
    ()=>SLUG_REGEX,
    "ULID_REGEX",
    ()=>ULID_REGEX,
    "UUID_REGEX",
    ()=>UUID_REGEX,
    "ValiError",
    ()=>ValiError,
    "_addIssue",
    ()=>_addIssue,
    "_getByteCount",
    ()=>_getByteCount,
    "_getGraphemeCount",
    ()=>_getGraphemeCount,
    "_getLastMetadata",
    ()=>_getLastMetadata,
    "_getStandardProps",
    ()=>_getStandardProps,
    "_getWordCount",
    ()=>_getWordCount,
    "_isLuhnAlgo",
    ()=>_isLuhnAlgo,
    "_isValidObjectKey",
    ()=>_isValidObjectKey,
    "_joinExpects",
    ()=>_joinExpects,
    "_stringify",
    ()=>_stringify,
    "any",
    ()=>any,
    "args",
    ()=>args,
    "argsAsync",
    ()=>argsAsync,
    "array",
    ()=>array,
    "arrayAsync",
    ()=>arrayAsync,
    "assert",
    ()=>assert,
    "awaitAsync",
    ()=>awaitAsync,
    "base64",
    ()=>base64,
    "bic",
    ()=>bic,
    "bigint",
    ()=>bigint,
    "blob",
    ()=>blob,
    "boolean",
    ()=>boolean,
    "brand",
    ()=>brand,
    "bytes",
    ()=>bytes,
    "check",
    ()=>check,
    "checkAsync",
    ()=>checkAsync,
    "checkItems",
    ()=>checkItems,
    "checkItemsAsync",
    ()=>checkItemsAsync,
    "config",
    ()=>config,
    "creditCard",
    ()=>creditCard,
    "cuid2",
    ()=>cuid2,
    "custom",
    ()=>custom,
    "customAsync",
    ()=>customAsync,
    "date",
    ()=>date,
    "decimal",
    ()=>decimal,
    "deleteGlobalConfig",
    ()=>deleteGlobalConfig,
    "deleteGlobalMessage",
    ()=>deleteGlobalMessage,
    "deleteSchemaMessage",
    ()=>deleteSchemaMessage,
    "deleteSpecificMessage",
    ()=>deleteSpecificMessage,
    "description",
    ()=>description,
    "digits",
    ()=>digits,
    "email",
    ()=>email,
    "emoji",
    ()=>emoji,
    "empty",
    ()=>empty,
    "endsWith",
    ()=>endsWith,
    "entries",
    ()=>entries,
    "entriesFromList",
    ()=>entriesFromList,
    "entriesFromObjects",
    ()=>entriesFromObjects,
    "enum",
    ()=>enum_,
    "enum_",
    ()=>enum_,
    "everyItem",
    ()=>everyItem,
    "exactOptional",
    ()=>exactOptional,
    "exactOptionalAsync",
    ()=>exactOptionalAsync,
    "examples",
    ()=>examples,
    "excludes",
    ()=>excludes,
    "fallback",
    ()=>fallback,
    "fallbackAsync",
    ()=>fallbackAsync,
    "file",
    ()=>file,
    "filterItems",
    ()=>filterItems,
    "findItem",
    ()=>findItem,
    "finite",
    ()=>finite,
    "flatten",
    ()=>flatten,
    "flavor",
    ()=>flavor,
    "forward",
    ()=>forward,
    "forwardAsync",
    ()=>forwardAsync,
    "function",
    ()=>function_,
    "function_",
    ()=>function_,
    "getDefault",
    ()=>getDefault,
    "getDefaults",
    ()=>getDefaults,
    "getDefaultsAsync",
    ()=>getDefaultsAsync,
    "getDescription",
    ()=>getDescription,
    "getDotPath",
    ()=>getDotPath,
    "getExamples",
    ()=>getExamples,
    "getFallback",
    ()=>getFallback,
    "getFallbacks",
    ()=>getFallbacks,
    "getFallbacksAsync",
    ()=>getFallbacksAsync,
    "getGlobalConfig",
    ()=>getGlobalConfig,
    "getGlobalMessage",
    ()=>getGlobalMessage,
    "getMetadata",
    ()=>getMetadata,
    "getSchemaMessage",
    ()=>getSchemaMessage,
    "getSpecificMessage",
    ()=>getSpecificMessage,
    "getTitle",
    ()=>getTitle,
    "graphemes",
    ()=>graphemes,
    "gtValue",
    ()=>gtValue,
    "hash",
    ()=>hash,
    "hexColor",
    ()=>hexColor,
    "hexadecimal",
    ()=>hexadecimal,
    "imei",
    ()=>imei,
    "includes",
    ()=>includes,
    "instance",
    ()=>instance,
    "integer",
    ()=>integer,
    "intersect",
    ()=>intersect,
    "intersectAsync",
    ()=>intersectAsync,
    "ip",
    ()=>ip,
    "ipv4",
    ()=>ipv4,
    "ipv6",
    ()=>ipv6,
    "is",
    ()=>is,
    "isOfKind",
    ()=>isOfKind,
    "isOfType",
    ()=>isOfType,
    "isValiError",
    ()=>isValiError,
    "isoDate",
    ()=>isoDate,
    "isoDateTime",
    ()=>isoDateTime,
    "isoTime",
    ()=>isoTime,
    "isoTimeSecond",
    ()=>isoTimeSecond,
    "isoTimestamp",
    ()=>isoTimestamp,
    "isoWeek",
    ()=>isoWeek,
    "keyof",
    ()=>keyof,
    "lazy",
    ()=>lazy,
    "lazyAsync",
    ()=>lazyAsync,
    "length",
    ()=>length,
    "literal",
    ()=>literal,
    "looseObject",
    ()=>looseObject,
    "looseObjectAsync",
    ()=>looseObjectAsync,
    "looseTuple",
    ()=>looseTuple,
    "looseTupleAsync",
    ()=>looseTupleAsync,
    "ltValue",
    ()=>ltValue,
    "mac",
    ()=>mac,
    "mac48",
    ()=>mac48,
    "mac64",
    ()=>mac64,
    "map",
    ()=>map,
    "mapAsync",
    ()=>mapAsync,
    "mapItems",
    ()=>mapItems,
    "maxBytes",
    ()=>maxBytes,
    "maxEntries",
    ()=>maxEntries,
    "maxGraphemes",
    ()=>maxGraphemes,
    "maxLength",
    ()=>maxLength,
    "maxSize",
    ()=>maxSize,
    "maxValue",
    ()=>maxValue,
    "maxWords",
    ()=>maxWords,
    "message",
    ()=>message,
    "metadata",
    ()=>metadata,
    "mimeType",
    ()=>mimeType,
    "minBytes",
    ()=>minBytes,
    "minEntries",
    ()=>minEntries,
    "minGraphemes",
    ()=>minGraphemes,
    "minLength",
    ()=>minLength,
    "minSize",
    ()=>minSize,
    "minValue",
    ()=>minValue,
    "minWords",
    ()=>minWords,
    "multipleOf",
    ()=>multipleOf,
    "nan",
    ()=>nan,
    "nanoid",
    ()=>nanoid,
    "never",
    ()=>never,
    "nonEmpty",
    ()=>nonEmpty,
    "nonNullable",
    ()=>nonNullable,
    "nonNullableAsync",
    ()=>nonNullableAsync,
    "nonNullish",
    ()=>nonNullish,
    "nonNullishAsync",
    ()=>nonNullishAsync,
    "nonOptional",
    ()=>nonOptional,
    "nonOptionalAsync",
    ()=>nonOptionalAsync,
    "normalize",
    ()=>normalize,
    "notBytes",
    ()=>notBytes,
    "notEntries",
    ()=>notEntries,
    "notGraphemes",
    ()=>notGraphemes,
    "notLength",
    ()=>notLength,
    "notSize",
    ()=>notSize,
    "notValue",
    ()=>notValue,
    "notValues",
    ()=>notValues,
    "notWords",
    ()=>notWords,
    "null",
    ()=>null_,
    "null_",
    ()=>null_,
    "nullable",
    ()=>nullable,
    "nullableAsync",
    ()=>nullableAsync,
    "nullish",
    ()=>nullish,
    "nullishAsync",
    ()=>nullishAsync,
    "number",
    ()=>number,
    "object",
    ()=>object,
    "objectAsync",
    ()=>objectAsync,
    "objectWithRest",
    ()=>objectWithRest,
    "objectWithRestAsync",
    ()=>objectWithRestAsync,
    "octal",
    ()=>octal,
    "omit",
    ()=>omit,
    "optional",
    ()=>optional,
    "optionalAsync",
    ()=>optionalAsync,
    "parse",
    ()=>parse,
    "parseAsync",
    ()=>parseAsync,
    "parseJson",
    ()=>parseJson,
    "parser",
    ()=>parser,
    "parserAsync",
    ()=>parserAsync,
    "partial",
    ()=>partial,
    "partialAsync",
    ()=>partialAsync,
    "partialCheck",
    ()=>partialCheck,
    "partialCheckAsync",
    ()=>partialCheckAsync,
    "pick",
    ()=>pick,
    "picklist",
    ()=>picklist,
    "pipe",
    ()=>pipe,
    "pipeAsync",
    ()=>pipeAsync,
    "promise",
    ()=>promise,
    "rawCheck",
    ()=>rawCheck,
    "rawCheckAsync",
    ()=>rawCheckAsync,
    "rawTransform",
    ()=>rawTransform,
    "rawTransformAsync",
    ()=>rawTransformAsync,
    "readonly",
    ()=>readonly,
    "record",
    ()=>record,
    "recordAsync",
    ()=>recordAsync,
    "reduceItems",
    ()=>reduceItems,
    "regex",
    ()=>regex,
    "required",
    ()=>required,
    "requiredAsync",
    ()=>requiredAsync,
    "returns",
    ()=>returns,
    "returnsAsync",
    ()=>returnsAsync,
    "rfcEmail",
    ()=>rfcEmail,
    "safeInteger",
    ()=>safeInteger,
    "safeParse",
    ()=>safeParse,
    "safeParseAsync",
    ()=>safeParseAsync,
    "safeParser",
    ()=>safeParser,
    "safeParserAsync",
    ()=>safeParserAsync,
    "set",
    ()=>set,
    "setAsync",
    ()=>setAsync,
    "setGlobalConfig",
    ()=>setGlobalConfig,
    "setGlobalMessage",
    ()=>setGlobalMessage,
    "setSchemaMessage",
    ()=>setSchemaMessage,
    "setSpecificMessage",
    ()=>setSpecificMessage,
    "size",
    ()=>size,
    "slug",
    ()=>slug,
    "someItem",
    ()=>someItem,
    "sortItems",
    ()=>sortItems,
    "startsWith",
    ()=>startsWith,
    "strictObject",
    ()=>strictObject,
    "strictObjectAsync",
    ()=>strictObjectAsync,
    "strictTuple",
    ()=>strictTuple,
    "strictTupleAsync",
    ()=>strictTupleAsync,
    "string",
    ()=>string,
    "stringifyJson",
    ()=>stringifyJson,
    "summarize",
    ()=>summarize,
    "symbol",
    ()=>symbol,
    "title",
    ()=>title,
    "toBigint",
    ()=>toBigint,
    "toBoolean",
    ()=>toBoolean,
    "toDate",
    ()=>toDate,
    "toLowerCase",
    ()=>toLowerCase,
    "toMaxValue",
    ()=>toMaxValue,
    "toMinValue",
    ()=>toMinValue,
    "toNumber",
    ()=>toNumber,
    "toString",
    ()=>toString,
    "toUpperCase",
    ()=>toUpperCase,
    "transform",
    ()=>transform,
    "transformAsync",
    ()=>transformAsync,
    "trim",
    ()=>trim,
    "trimEnd",
    ()=>trimEnd,
    "trimStart",
    ()=>trimStart,
    "tuple",
    ()=>tuple,
    "tupleAsync",
    ()=>tupleAsync,
    "tupleWithRest",
    ()=>tupleWithRest,
    "tupleWithRestAsync",
    ()=>tupleWithRestAsync,
    "ulid",
    ()=>ulid,
    "undefined",
    ()=>undefined_,
    "undefined_",
    ()=>undefined_,
    "undefinedable",
    ()=>undefinedable,
    "undefinedableAsync",
    ()=>undefinedableAsync,
    "union",
    ()=>union,
    "unionAsync",
    ()=>unionAsync,
    "unknown",
    ()=>unknown,
    "unwrap",
    ()=>unwrap,
    "url",
    ()=>url,
    "uuid",
    ()=>uuid,
    "value",
    ()=>value,
    "values",
    ()=>values,
    "variant",
    ()=>variant,
    "variantAsync",
    ()=>variantAsync,
    "void",
    ()=>void_,
    "void_",
    ()=>void_,
    "words",
    ()=>words
]);
let store$4;
/**
* Sets the global configuration.
*
* @param config The configuration.
*/ function setGlobalConfig(config$1) {
    store$4 = {
        ...store$4,
        ...config$1
    };
}
/**
* Returns the global configuration.
*
* @param config The config to merge.
*
* @returns The configuration.
*/ /* @__NO_SIDE_EFFECTS__ */ function getGlobalConfig(config$1) {
    return {
        lang: config$1?.lang ?? store$4?.lang,
        message: config$1?.message,
        abortEarly: config$1?.abortEarly ?? store$4?.abortEarly,
        abortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly
    };
}
/**
* Deletes the global configuration.
*/ function deleteGlobalConfig() {
    store$4 = void 0;
}
//#endregion
//#region src/storages/globalMessage/globalMessage.ts
let store$3;
/**
* Sets a global error message.
*
* @param message The error message.
* @param lang The language of the message.
*/ function setGlobalMessage(message$1, lang) {
    if (!store$3) store$3 = /* @__PURE__ */ new Map();
    store$3.set(lang, message$1);
}
/**
* Returns a global error message.
*
* @param lang The language of the message.
*
* @returns The error message.
*/ /* @__NO_SIDE_EFFECTS__ */ function getGlobalMessage(lang) {
    return store$3?.get(lang);
}
/**
* Deletes a global error message.
*
* @param lang The language of the message.
*/ function deleteGlobalMessage(lang) {
    store$3?.delete(lang);
}
//#endregion
//#region src/storages/schemaMessage/schemaMessage.ts
let store$2;
/**
* Sets a schema error message.
*
* @param message The error message.
* @param lang The language of the message.
*/ function setSchemaMessage(message$1, lang) {
    if (!store$2) store$2 = /* @__PURE__ */ new Map();
    store$2.set(lang, message$1);
}
/**
* Returns a schema error message.
*
* @param lang The language of the message.
*
* @returns The error message.
*/ /* @__NO_SIDE_EFFECTS__ */ function getSchemaMessage(lang) {
    return store$2?.get(lang);
}
/**
* Deletes a schema error message.
*
* @param lang The language of the message.
*/ function deleteSchemaMessage(lang) {
    store$2?.delete(lang);
}
//#endregion
//#region src/storages/specificMessage/specificMessage.ts
let store$1;
/**
* Sets a specific error message.
*
* @param reference The identifier reference.
* @param message The error message.
* @param lang The language of the message.
*/ function setSpecificMessage(reference, message$1, lang) {
    if (!store$1) store$1 = /* @__PURE__ */ new Map();
    if (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());
    store$1.get(reference).set(lang, message$1);
}
/**
* Returns a specific error message.
*
* @param reference The identifier reference.
* @param lang The language of the message.
*
* @returns The error message.
*/ /* @__NO_SIDE_EFFECTS__ */ function getSpecificMessage(reference, lang) {
    return store$1?.get(reference)?.get(lang);
}
/**
* Deletes a specific error message.
*
* @param reference The identifier reference.
* @param lang The language of the message.
*/ function deleteSpecificMessage(reference, lang) {
    store$1?.get(reference)?.delete(lang);
}
//#endregion
//#region src/utils/_stringify/_stringify.ts
/**
* Stringifies an unknown input to a literal or type string.
*
* @param input The unknown input.
*
* @returns A literal or type string.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _stringify(input) {
    const type = typeof input;
    if (type === "string") return `"${input}"`;
    if (type === "number" || type === "bigint" || type === "boolean") return `${input}`;
    if (type === "object" || type === "function") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
    return type;
}
//#endregion
//#region src/utils/_addIssue/_addIssue.ts
/**
* Adds an issue to the dataset.
*
* @param context The issue context.
* @param label The issue label.
* @param dataset The input dataset.
* @param config The configuration.
* @param other The optional props.
*
* @internal
*/ function _addIssue(context, label, dataset, config$1, other) {
    const input = other && "input" in other ? other.input : dataset.value;
    const expected = other?.expected ?? context.expects ?? null;
    const received = other?.received ?? /* @__PURE__ */ _stringify(input);
    const issue = {
        kind: context.kind,
        type: context.type,
        input,
        expected,
        received,
        message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
        requirement: context.requirement,
        path: other?.path,
        issues: other?.issues,
        lang: config$1.lang,
        abortEarly: config$1.abortEarly,
        abortPipeEarly: config$1.abortPipeEarly
    };
    const isSchema = context.kind === "schema";
    const message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);
    if (message$1 !== void 0) issue.message = typeof message$1 === "function" ? message$1(issue) : message$1;
    if (isSchema) dataset.typed = false;
    if (dataset.issues) dataset.issues.push(issue);
    else dataset.issues = [
        issue
    ];
}
//#endregion
//#region src/utils/_getByteCount/_getByteCount.ts
let textEncoder;
/**
* Returns the byte count of the input.
*
* @param input The input to be measured.
*
* @returns The byte count.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _getByteCount(input) {
    if (!textEncoder) textEncoder = new TextEncoder();
    return textEncoder.encode(input).length;
}
//#endregion
//#region src/utils/_getGraphemeCount/_getGraphemeCount.ts
let segmenter;
/**
* Returns the grapheme count of the input.
*
* @param input The input to be measured.
*
* @returns The grapheme count.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _getGraphemeCount(input) {
    if (!segmenter) segmenter = new Intl.Segmenter();
    const segments = segmenter.segment(input);
    let count = 0;
    for (const _ of segments)count++;
    return count;
}
//#endregion
//#region src/utils/_getLastMetadata/_getLastMetadata.ts
/**
* Returns the last top-level value of a given metadata type from a schema
* using a breadth-first search that starts with the last item in the pipeline.
*
* @param schema The schema to search.
* @param type The metadata type.
*
* @returns The value, if any.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _getLastMetadata(schema, type) {
    if ("pipe" in schema) {
        const nestedSchemas = [];
        for(let index = schema.pipe.length - 1; index >= 0; index--){
            const item = schema.pipe[index];
            if (item.kind === "schema" && "pipe" in item) nestedSchemas.push(item);
            else if (item.kind === "metadata" && item.type === type) return item[type];
        }
        for (const nestedSchema of nestedSchemas){
            const result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);
            if (result !== void 0) return result;
        }
    }
}
//#endregion
//#region src/utils/_getStandardProps/_getStandardProps.ts
/**
* Returns the Standard Schema properties.
*
* @param context The schema context.
*
* @returns The Standard Schema properties.
*/ /* @__NO_SIDE_EFFECTS__ */ function _getStandardProps(context) {
    return {
        version: 1,
        vendor: "valibot",
        validate (value$1) {
            return context["~run"]({
                value: value$1
            }, /* @__PURE__ */ getGlobalConfig());
        }
    };
}
//#endregion
//#region src/utils/_getWordCount/_getWordCount.ts
let store;
/**
* Returns the word count of the input.
*
* @param locales The locales to be used.
* @param input The input to be measured.
*
* @returns The word count.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _getWordCount(locales, input) {
    if (!store) store = /* @__PURE__ */ new Map();
    if (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, {
        granularity: "word"
    }));
    const segments = store.get(locales).segment(input);
    let count = 0;
    for (const segment of segments)if (segment.isWordLike) count++;
    return count;
}
//#endregion
//#region src/utils/_isLuhnAlgo/_isLuhnAlgo.ts
/**
* Non-digit regex.
*/ const NON_DIGIT_REGEX = /\D/gu;
/**
* Checks whether a string with numbers corresponds to the luhn algorithm.
*
* @param input The input to be checked.
*
* @returns Whether input is valid.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _isLuhnAlgo(input) {
    const number$1 = input.replace(NON_DIGIT_REGEX, "");
    let length$1 = number$1.length;
    let bit = 1;
    let sum = 0;
    while(length$1){
        const value$1 = +number$1[--length$1];
        bit ^= 1;
        sum += bit ? [
            0,
            2,
            4,
            6,
            8,
            1,
            3,
            5,
            7,
            9
        ][value$1] : value$1;
    }
    return sum % 10 === 0;
}
//#endregion
//#region src/utils/_isValidObjectKey/_isValidObjectKey.ts
/**
* Disallows inherited object properties and prevents object prototype
* pollution by disallowing certain keys.
*
* @param object The object to check.
* @param key The key to check.
*
* @returns Whether the key is allowed.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _isValidObjectKey(object$1, key) {
    return Object.hasOwn(object$1, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
//#endregion
//#region src/utils/_joinExpects/_joinExpects.ts
/**
* Joins multiple `expects` values with the given separator.
*
* @param values The `expects` values.
* @param separator The separator.
*
* @returns The joined `expects` property.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _joinExpects(values$1, separator) {
    const list = [
        ...new Set(values$1)
    ];
    if (list.length > 1) return `(${list.join(` ${separator} `)})`;
    return list[0] ?? "never";
}
//#endregion
//#region src/utils/entriesFromList/entriesFromList.ts
/**
* Creates an object entries definition from a list of keys and a schema.
*
* @param list A list of keys.
* @param schema The schema of the keys.
*
* @returns The object entries.
*/ /* @__NO_SIDE_EFFECTS__ */ function entriesFromList(list, schema) {
    const entries$1 = {};
    for (const key of list)entries$1[key] = schema;
    return entries$1;
}
//#endregion
//#region src/utils/entriesFromObjects/entriesFromObjects.ts
/* @__NO_SIDE_EFFECTS__ */ function entriesFromObjects(schemas) {
    const entries$1 = {};
    for (const schema of schemas)Object.assign(entries$1, schema.entries);
    return entries$1;
}
//#endregion
//#region src/utils/getDotPath/getDotPath.ts
/* @__NO_SIDE_EFFECTS__ */ function getDotPath(issue) {
    if (issue.path) {
        let key = "";
        for (const item of issue.path)if (typeof item.key === "string" || typeof item.key === "number") if (key) key += `.${item.key}`;
        else key += item.key;
        else return null;
        return key;
    }
    return null;
}
//#endregion
//#region src/utils/isOfKind/isOfKind.ts
/**
* A generic type guard to check the kind of an object.
*
* @param kind The kind to check for.
* @param object The object to check.
*
* @returns Whether it matches.
*/ /* @__NO_SIDE_EFFECTS__ */ function isOfKind(kind, object$1) {
    return object$1.kind === kind;
}
//#endregion
//#region src/utils/isOfType/isOfType.ts
/**
* A generic type guard to check the type of an object.
*
* @param type The type to check for.
* @param object The object to check.
*
* @returns Whether it matches.
*/ /* @__NO_SIDE_EFFECTS__ */ function isOfType(type, object$1) {
    return object$1.type === type;
}
//#endregion
//#region src/utils/isValiError/isValiError.ts
/**
* A type guard to check if an error is a ValiError.
*
* @param error The error to check.
*
* @returns Whether its a ValiError.
*/ /* @__NO_SIDE_EFFECTS__ */ function isValiError(error) {
    return error instanceof ValiError;
}
//#endregion
//#region src/utils/ValiError/ValiError.ts
/**
* A Valibot error with useful information.
*/ var ValiError = class extends Error {
    /**
	* Creates a Valibot error with useful information.
	*
	* @param issues The error issues.
	*/ constructor(issues){
        super(issues[0].message);
        this.name = "ValiError";
        this.issues = issues;
    }
};
//#endregion
//#region src/actions/args/args.ts
/* @__NO_SIDE_EFFECTS__ */ function args(schema) {
    return {
        kind: "transformation",
        type: "args",
        reference: args,
        async: false,
        schema,
        "~run" (dataset, config$1) {
            const func = dataset.value;
            dataset.value = (...args_)=>{
                const argsDataset = this.schema["~run"]({
                    value: args_
                }, config$1);
                if (argsDataset.issues) throw new ValiError(argsDataset.issues);
                return func(...argsDataset.value);
            };
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/args/argsAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function argsAsync(schema) {
    return {
        kind: "transformation",
        type: "args",
        reference: argsAsync,
        async: false,
        schema,
        "~run" (dataset, config$1) {
            const func = dataset.value;
            dataset.value = async (...args$1)=>{
                const argsDataset = await schema["~run"]({
                    value: args$1
                }, config$1);
                if (argsDataset.issues) throw new ValiError(argsDataset.issues);
                return func(...argsDataset.value);
            };
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/await/awaitAsync.ts
/**
* Creates an await transformation action.
*
* @returns An await action.
*/ /* @__NO_SIDE_EFFECTS__ */ function awaitAsync() {
    return {
        kind: "transformation",
        type: "await",
        reference: awaitAsync,
        async: true,
        async "~run" (dataset) {
            dataset.value = await dataset.value;
            return dataset;
        }
    };
}
//#endregion
//#region src/regex.ts
/**
* [Base64](https://en.wikipedia.org/wiki/Base64) regex.
*/ const BASE64_REGEX = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu;
/**
* [BIC](https://en.wikipedia.org/wiki/ISO_9362) regex.
*/ const BIC_REGEX = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u;
/**
* [Cuid2](https://github.com/paralleldrive/cuid2) regex.
*/ const CUID2_REGEX = /^[a-z][\da-z]*$/u;
/**
* [Decimal](https://en.wikipedia.org/wiki/Decimal) regex.
*/ const DECIMAL_REGEX = /^[+-]?(?:\d*\.)?\d+$/u;
/**
* [Digits](https://en.wikipedia.org/wiki/Numerical_digit) regex.
*/ const DIGITS_REGEX = /^\d+$/u;
/**
* [Email address](https://en.wikipedia.org/wiki/Email_address) regex.
*/ const EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
/**
* Emoji regex from [emoji-regex-xs](https://github.com/slevithan/emoji-regex-xs) v1.0.0 (MIT license).
*
* Hint: We decided against the newer `/^\p{RGI_Emoji}+$/v` regex because it is
* not supported in older runtimes and does not match all emoji.
*/ const EMOJI_REGEX = /^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|(?![\p{Emoji_Modifier_Base}\u{1F1E6}-\u{1F1FF}])\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|(?![\p{Emoji_Modifier_Base}\u{1F1E6}-\u{1F1FF}])\p{Emoji_Presentation}))*)+$/u;
/**
* [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) regex.
*
* Hint: We decided against the `i` flag for better JSON Schema compatibility.
*/ const HEXADECIMAL_REGEX = /^(?:0[hx])?[\da-fA-F]+$/u;
/**
* [Hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) regex.
*
* Hint: We decided against the `i` flag for better JSON Schema compatibility.
*/ const HEX_COLOR_REGEX = /^#(?:[\da-fA-F]{3,4}|[\da-fA-F]{6}|[\da-fA-F]{8})$/u;
/**
* [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) regex.
*/ const IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
/**
* [IPv4](https://en.wikipedia.org/wiki/IPv4) regex.
*/ const IPV4_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u;
/**
* [IPv6](https://en.wikipedia.org/wiki/IPv6) regex.
*/ const IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
/**
* [IP](https://en.wikipedia.org/wiki/IP_address) regex.
*/ const IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
/**
* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date regex.
*/ const ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
/**
* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time regex.
*/ const ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3]):[0-5]\d$/u;
/**
* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time regex.
*/ const ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
/**
* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time with seconds regex.
*/ const ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
/**
* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp regex.
*/ const ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
/**
* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) week regex.
*/ const ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
/**
* [MAC](https://en.wikipedia.org/wiki/MAC_address) 48 bit regex.
*/ const MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
/**
* [MAC](https://en.wikipedia.org/wiki/MAC_address) 64 bit regex.
*/ const MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
/**
* [MAC](https://en.wikipedia.org/wiki/MAC_address) regex.
*/ const MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
/**
* [Nano ID](https://github.com/ai/nanoid) regex.
*/ const NANO_ID_REGEX = /^[\w-]+$/u;
/**
* [Octal](https://en.wikipedia.org/wiki/Octal) regex.
*/ const OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;
/**
* [RFC 5322 email address](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) regex.
*
* Hint: This regex was taken from the [HTML Living Standard Specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) and does not perfectly represent RFC 5322.
*/ const RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
/**
* [Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug) regex.
*/ const SLUG_REGEX = /^[\da-z]+(?:[-_][\da-z]+)*$/u;
/**
* [ULID](https://github.com/ulid/spec) regex.
*
* Hint: We decided against the `i` flag for better JSON Schema compatibility.
*/ const ULID_REGEX = /^[\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;
/**
* [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.
*/ const UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
//#endregion
//#region src/actions/base64/base64.ts
/* @__NO_SIDE_EFFECTS__ */ function base64(message$1) {
    return {
        kind: "validation",
        type: "base64",
        reference: base64,
        async: false,
        expects: null,
        requirement: BASE64_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Base64", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/bic/bic.ts
/* @__NO_SIDE_EFFECTS__ */ function bic(message$1) {
    return {
        kind: "validation",
        type: "bic",
        reference: bic,
        async: false,
        expects: null,
        requirement: BIC_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "BIC", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/brand/brand.ts
/**
* Creates a brand transformation action.
*
* @param name The brand name.
*
* @returns A brand action.
*/ /* @__NO_SIDE_EFFECTS__ */ function brand(name) {
    return {
        kind: "transformation",
        type: "brand",
        reference: brand,
        async: false,
        name,
        "~run" (dataset) {
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/bytes/bytes.ts
/* @__NO_SIDE_EFFECTS__ */ function bytes(requirement, message$1) {
    return {
        kind: "validation",
        type: "bytes",
        reference: bytes,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
                if (length$1 !== this.requirement) _addIssue(this, "bytes", dataset, config$1, {
                    received: `${length$1}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/check/check.ts
/* @__NO_SIDE_EFFECTS__ */ function check(requirement, message$1) {
    return {
        kind: "validation",
        type: "check",
        reference: check,
        async: false,
        expects: null,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/check/checkAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function checkAsync(requirement, message$1) {
    return {
        kind: "validation",
        type: "check",
        reference: checkAsync,
        async: true,
        expects: null,
        requirement,
        message: message$1,
        async "~run" (dataset, config$1) {
            if (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/checkItems/checkItems.ts
/* @__NO_SIDE_EFFECTS__ */ function checkItems(requirement, message$1) {
    return {
        kind: "validation",
        type: "check_items",
        reference: checkItems,
        async: false,
        expects: null,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) for(let index = 0; index < dataset.value.length; index++){
                const item = dataset.value[index];
                if (!this.requirement(item, index, dataset.value)) _addIssue(this, "item", dataset, config$1, {
                    input: item,
                    path: [
                        {
                            type: "array",
                            origin: "value",
                            input: dataset.value,
                            key: index,
                            value: item
                        }
                    ]
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/checkItems/checkItemsAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function checkItemsAsync(requirement, message$1) {
    return {
        kind: "validation",
        type: "check_items",
        reference: checkItemsAsync,
        async: true,
        expects: null,
        requirement,
        message: message$1,
        async "~run" (dataset, config$1) {
            if (dataset.typed) {
                const requirementResults = await Promise.all(dataset.value.map(this.requirement));
                for(let index = 0; index < dataset.value.length; index++)if (!requirementResults[index]) {
                    const item = dataset.value[index];
                    _addIssue(this, "item", dataset, config$1, {
                        input: item,
                        path: [
                            {
                                type: "array",
                                origin: "value",
                                input: dataset.value,
                                key: index,
                                value: item
                            }
                        ]
                    });
                }
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/creditCard/creditCard.ts
/**
* Credit card regex.
*/ const CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
/**
* Sanitize regex.
*/ const SANITIZE_REGEX = /[- ]/gu;
/**
* Provider regex list.
*/ const PROVIDER_REGEX_LIST = [
    /^3[47]\d{13}$/u,
    /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
    /^6(?:011|5\d{2})\d{12,15}$/u,
    /^(?:2131|1800|35\d{3})\d{11}$/u,
    /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
    /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
    /^4\d{12}(?:\d{3,6})?$/u
];
/* @__NO_SIDE_EFFECTS__ */ function creditCard(message$1) {
    return {
        kind: "validation",
        type: "credit_card",
        reference: creditCard,
        async: false,
        expects: null,
        requirement (input) {
            let sanitized;
            return CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, "")) && PROVIDER_REGEX_LIST.some((regex$1)=>regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);
        },
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "credit card", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/cuid2/cuid2.ts
/* @__NO_SIDE_EFFECTS__ */ function cuid2(message$1) {
    return {
        kind: "validation",
        type: "cuid2",
        reference: cuid2,
        async: false,
        expects: null,
        requirement: CUID2_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Cuid2", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/decimal/decimal.ts
/* @__NO_SIDE_EFFECTS__ */ function decimal(message$1) {
    return {
        kind: "validation",
        type: "decimal",
        reference: decimal,
        async: false,
        expects: null,
        requirement: DECIMAL_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "decimal", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/description/description.ts
/**
* Creates a description metadata action.
*
* @param description_ The description text.
*
* @returns A description action.
*/ /* @__NO_SIDE_EFFECTS__ */ function description(description_) {
    return {
        kind: "metadata",
        type: "description",
        reference: description,
        description: description_
    };
}
//#endregion
//#region src/actions/digits/digits.ts
/* @__NO_SIDE_EFFECTS__ */ function digits(message$1) {
    return {
        kind: "validation",
        type: "digits",
        reference: digits,
        async: false,
        expects: null,
        requirement: DIGITS_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "digits", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/email/email.ts
/* @__NO_SIDE_EFFECTS__ */ function email(message$1) {
    return {
        kind: "validation",
        type: "email",
        reference: email,
        expects: null,
        async: false,
        requirement: EMAIL_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/emoji/emoji.ts
/* @__NO_SIDE_EFFECTS__ */ function emoji(message$1) {
    return {
        kind: "validation",
        type: "emoji",
        reference: emoji,
        async: false,
        expects: null,
        requirement: EMOJI_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "emoji", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/empty/empty.ts
/* @__NO_SIDE_EFFECTS__ */ function empty(message$1) {
    return {
        kind: "validation",
        type: "empty",
        reference: empty,
        async: false,
        expects: "0",
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.length > 0) _addIssue(this, "length", dataset, config$1, {
                received: `${dataset.value.length}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/endsWith/endsWith.ts
/* @__NO_SIDE_EFFECTS__ */ function endsWith(requirement, message$1) {
    return {
        kind: "validation",
        type: "ends_with",
        reference: endsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, "end", dataset, config$1, {
                received: `"${dataset.value.slice(-this.requirement.length)}"`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/entries/entries.ts
/* @__NO_SIDE_EFFECTS__ */ function entries(requirement, message$1) {
    return {
        kind: "validation",
        type: "entries",
        reference: entries,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (!dataset.typed) return dataset;
            const count = Object.keys(dataset.value).length;
            if (dataset.typed && count !== this.requirement) _addIssue(this, "entries", dataset, config$1, {
                received: `${count}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/everyItem/everyItem.ts
/* @__NO_SIDE_EFFECTS__ */ function everyItem(requirement, message$1) {
    return {
        kind: "validation",
        type: "every_item",
        reference: everyItem,
        async: false,
        expects: null,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, "item", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/examples/examples.ts
/**
* Creates an examples metadata action.
*
* @param examples_ The examples.
*
* @returns An examples action.
*
* @beta
*/ /* @__NO_SIDE_EFFECTS__ */ function examples(examples_) {
    return {
        kind: "metadata",
        type: "examples",
        reference: examples,
        examples: examples_
    };
}
//#endregion
//#region src/actions/excludes/excludes.ts
/* @__NO_SIDE_EFFECTS__ */ function excludes(requirement, message$1) {
    const received = /* @__PURE__ */ _stringify(requirement);
    return {
        kind: "validation",
        type: "excludes",
        reference: excludes,
        async: false,
        expects: `!${received}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, {
                received
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/filterItems/filterItems.ts
/* @__NO_SIDE_EFFECTS__ */ function filterItems(operation) {
    return {
        kind: "transformation",
        type: "filter_items",
        reference: filterItems,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.filter(this.operation);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/findItem/findItem.ts
/* @__NO_SIDE_EFFECTS__ */ function findItem(operation) {
    return {
        kind: "transformation",
        type: "find_item",
        reference: findItem,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.find(this.operation);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/finite/finite.ts
/* @__NO_SIDE_EFFECTS__ */ function finite(message$1) {
    return {
        kind: "validation",
        type: "finite",
        reference: finite,
        async: false,
        expects: null,
        requirement: Number.isFinite,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "finite", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/flavor/flavor.ts
/**
* Creates a flavor transformation action.
*
* @param name The flavor name.
*
* @returns A flavor action.
*
* @beta
*/ /* @__NO_SIDE_EFFECTS__ */ function flavor(name) {
    return {
        kind: "transformation",
        type: "flavor",
        reference: flavor,
        async: false,
        name,
        "~run" (dataset) {
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/graphemes/graphemes.ts
/* @__NO_SIDE_EFFECTS__ */ function graphemes(requirement, message$1) {
    return {
        kind: "validation",
        type: "graphemes",
        reference: graphemes,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
                if (count !== this.requirement) _addIssue(this, "graphemes", dataset, config$1, {
                    received: `${count}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/gtValue/gtValue.ts
/* @__NO_SIDE_EFFECTS__ */ function gtValue(requirement, message$1) {
    return {
        kind: "validation",
        type: "gt_value",
        reference: gtValue,
        async: false,
        expects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, "value", dataset, config$1, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/hash/hash.ts
/**
* Hash lengths object.
*/ const HASH_LENGTHS = {
    md4: 32,
    md5: 32,
    sha1: 40,
    sha256: 64,
    sha384: 96,
    sha512: 128,
    ripemd128: 32,
    ripemd160: 40,
    tiger128: 32,
    tiger160: 40,
    tiger192: 48,
    crc32: 8,
    crc32b: 8,
    adler32: 8
};
/* @__NO_SIDE_EFFECTS__ */ function hash(types, message$1) {
    return {
        kind: "validation",
        type: "hash",
        reference: hash,
        expects: null,
        async: false,
        requirement: RegExp(types.map((type)=>`^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"), "iu"),
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hash", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/hexadecimal/hexadecimal.ts
/* @__NO_SIDE_EFFECTS__ */ function hexadecimal(message$1) {
    return {
        kind: "validation",
        type: "hexadecimal",
        reference: hexadecimal,
        async: false,
        expects: null,
        requirement: HEXADECIMAL_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hexadecimal", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/hexColor/hexColor.ts
/* @__NO_SIDE_EFFECTS__ */ function hexColor(message$1) {
    return {
        kind: "validation",
        type: "hex_color",
        reference: hexColor,
        async: false,
        expects: null,
        requirement: HEX_COLOR_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hex color", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/imei/imei.ts
/* @__NO_SIDE_EFFECTS__ */ function imei(message$1) {
    return {
        kind: "validation",
        type: "imei",
        reference: imei,
        async: false,
        expects: null,
        requirement (input) {
            return IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);
        },
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "IMEI", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/includes/includes.ts
/* @__NO_SIDE_EFFECTS__ */ function includes(requirement, message$1) {
    const expects = /* @__PURE__ */ _stringify(requirement);
    return {
        kind: "validation",
        type: "includes",
        reference: includes,
        async: false,
        expects,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, {
                received: `!${expects}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/integer/integer.ts
/* @__NO_SIDE_EFFECTS__ */ function integer(message$1) {
    return {
        kind: "validation",
        type: "integer",
        reference: integer,
        async: false,
        expects: null,
        requirement: Number.isInteger,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "integer", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/ip/ip.ts
/* @__NO_SIDE_EFFECTS__ */ function ip(message$1) {
    return {
        kind: "validation",
        type: "ip",
        reference: ip,
        async: false,
        expects: null,
        requirement: IP_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IP", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/ipv4/ipv4.ts
/* @__NO_SIDE_EFFECTS__ */ function ipv4(message$1) {
    return {
        kind: "validation",
        type: "ipv4",
        reference: ipv4,
        async: false,
        expects: null,
        requirement: IPV4_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv4", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/ipv6/ipv6.ts
/* @__NO_SIDE_EFFECTS__ */ function ipv6(message$1) {
    return {
        kind: "validation",
        type: "ipv6",
        reference: ipv6,
        async: false,
        expects: null,
        requirement: IPV6_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv6", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/isoDate/isoDate.ts
/* @__NO_SIDE_EFFECTS__ */ function isoDate(message$1) {
    return {
        kind: "validation",
        type: "iso_date",
        reference: isoDate,
        async: false,
        expects: null,
        requirement: ISO_DATE_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/isoDateTime/isoDateTime.ts
/* @__NO_SIDE_EFFECTS__ */ function isoDateTime(message$1) {
    return {
        kind: "validation",
        type: "iso_date_time",
        reference: isoDateTime,
        async: false,
        expects: null,
        requirement: ISO_DATE_TIME_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date-time", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/isoTime/isoTime.ts
/* @__NO_SIDE_EFFECTS__ */ function isoTime(message$1) {
    return {
        kind: "validation",
        type: "iso_time",
        reference: isoTime,
        async: false,
        expects: null,
        requirement: ISO_TIME_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/isoTimeSecond/isoTimeSecond.ts
/* @__NO_SIDE_EFFECTS__ */ function isoTimeSecond(message$1) {
    return {
        kind: "validation",
        type: "iso_time_second",
        reference: isoTimeSecond,
        async: false,
        expects: null,
        requirement: ISO_TIME_SECOND_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time-second", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/isoTimestamp/isoTimestamp.ts
/* @__NO_SIDE_EFFECTS__ */ function isoTimestamp(message$1) {
    return {
        kind: "validation",
        type: "iso_timestamp",
        reference: isoTimestamp,
        async: false,
        expects: null,
        requirement: ISO_TIMESTAMP_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "timestamp", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/isoWeek/isoWeek.ts
/* @__NO_SIDE_EFFECTS__ */ function isoWeek(message$1) {
    return {
        kind: "validation",
        type: "iso_week",
        reference: isoWeek,
        async: false,
        expects: null,
        requirement: ISO_WEEK_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "week", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/length/length.ts
/* @__NO_SIDE_EFFECTS__ */ function length(requirement, message$1) {
    return {
        kind: "validation",
        type: "length",
        reference: length,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, "length", dataset, config$1, {
                received: `${dataset.value.length}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/ltValue/ltValue.ts
/* @__NO_SIDE_EFFECTS__ */ function ltValue(requirement, message$1) {
    return {
        kind: "validation",
        type: "lt_value",
        reference: ltValue,
        async: false,
        expects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, "value", dataset, config$1, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/mac/mac.ts
/* @__NO_SIDE_EFFECTS__ */ function mac(message$1) {
    return {
        kind: "validation",
        type: "mac",
        reference: mac,
        async: false,
        expects: null,
        requirement: MAC_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "MAC", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/mac48/mac48.ts
/* @__NO_SIDE_EFFECTS__ */ function mac48(message$1) {
    return {
        kind: "validation",
        type: "mac48",
        reference: mac48,
        async: false,
        expects: null,
        requirement: MAC48_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "48-bit MAC", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/mac64/mac64.ts
/* @__NO_SIDE_EFFECTS__ */ function mac64(message$1) {
    return {
        kind: "validation",
        type: "mac64",
        reference: mac64,
        async: false,
        expects: null,
        requirement: MAC64_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "64-bit MAC", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/mapItems/mapItems.ts
/* @__NO_SIDE_EFFECTS__ */ function mapItems(operation) {
    return {
        kind: "transformation",
        type: "map_items",
        reference: mapItems,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.map(this.operation);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/maxBytes/maxBytes.ts
/* @__NO_SIDE_EFFECTS__ */ function maxBytes(requirement, message$1) {
    return {
        kind: "validation",
        type: "max_bytes",
        reference: maxBytes,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
                if (length$1 > this.requirement) _addIssue(this, "bytes", dataset, config$1, {
                    received: `${length$1}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/maxEntries/maxEntries.ts
/* @__NO_SIDE_EFFECTS__ */ function maxEntries(requirement, message$1) {
    return {
        kind: "validation",
        type: "max_entries",
        reference: maxEntries,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (!dataset.typed) return dataset;
            const count = Object.keys(dataset.value).length;
            if (dataset.typed && count > this.requirement) _addIssue(this, "entries", dataset, config$1, {
                received: `${count}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/maxGraphemes/maxGraphemes.ts
/* @__NO_SIDE_EFFECTS__ */ function maxGraphemes(requirement, message$1) {
    return {
        kind: "validation",
        type: "max_graphemes",
        reference: maxGraphemes,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
                if (count > this.requirement) _addIssue(this, "graphemes", dataset, config$1, {
                    received: `${count}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/maxLength/maxLength.ts
/* @__NO_SIDE_EFFECTS__ */ function maxLength(requirement, message$1) {
    return {
        kind: "validation",
        type: "max_length",
        reference: maxLength,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, "length", dataset, config$1, {
                received: `${dataset.value.length}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/maxSize/maxSize.ts
/* @__NO_SIDE_EFFECTS__ */ function maxSize(requirement, message$1) {
    return {
        kind: "validation",
        type: "max_size",
        reference: maxSize,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, "size", dataset, config$1, {
                received: `${dataset.value.size}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/maxValue/maxValue.ts
/* @__NO_SIDE_EFFECTS__ */ function maxValue(requirement, message$1) {
    return {
        kind: "validation",
        type: "max_value",
        reference: maxValue,
        async: false,
        expects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, "value", dataset, config$1, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/maxWords/maxWords.ts
/* @__NO_SIDE_EFFECTS__ */ function maxWords(locales, requirement, message$1) {
    return {
        kind: "validation",
        type: "max_words",
        reference: maxWords,
        async: false,
        expects: `<=${requirement}`,
        locales,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
                if (count > this.requirement) _addIssue(this, "words", dataset, config$1, {
                    received: `${count}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/metadata/metadata.ts
/**
* Creates a custom metadata action.
*
* @param metadata_ The metadata object.
*
* @returns A metadata action.
*/ /* @__NO_SIDE_EFFECTS__ */ function metadata(metadata_) {
    return {
        kind: "metadata",
        type: "metadata",
        reference: metadata,
        metadata: metadata_
    };
}
//#endregion
//#region src/actions/mimeType/mimeType.ts
/* @__NO_SIDE_EFFECTS__ */ function mimeType(requirement, message$1) {
    return {
        kind: "validation",
        type: "mime_type",
        reference: mimeType,
        async: false,
        expects: /* @__PURE__ */ _joinExpects(requirement.map((option)=>`"${option}"`), "|"),
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, "MIME type", dataset, config$1, {
                received: `"${dataset.value.type}"`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/minBytes/minBytes.ts
/* @__NO_SIDE_EFFECTS__ */ function minBytes(requirement, message$1) {
    return {
        kind: "validation",
        type: "min_bytes",
        reference: minBytes,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
                if (length$1 < this.requirement) _addIssue(this, "bytes", dataset, config$1, {
                    received: `${length$1}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/minEntries/minEntries.ts
/* @__NO_SIDE_EFFECTS__ */ function minEntries(requirement, message$1) {
    return {
        kind: "validation",
        type: "min_entries",
        reference: minEntries,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (!dataset.typed) return dataset;
            const count = Object.keys(dataset.value).length;
            if (dataset.typed && count < this.requirement) _addIssue(this, "entries", dataset, config$1, {
                received: `${count}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/minGraphemes/minGraphemes.ts
/* @__NO_SIDE_EFFECTS__ */ function minGraphemes(requirement, message$1) {
    return {
        kind: "validation",
        type: "min_graphemes",
        reference: minGraphemes,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
                if (count < this.requirement) _addIssue(this, "graphemes", dataset, config$1, {
                    received: `${count}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/minLength/minLength.ts
/* @__NO_SIDE_EFFECTS__ */ function minLength(requirement, message$1) {
    return {
        kind: "validation",
        type: "min_length",
        reference: minLength,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, "length", dataset, config$1, {
                received: `${dataset.value.length}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/minSize/minSize.ts
/* @__NO_SIDE_EFFECTS__ */ function minSize(requirement, message$1) {
    return {
        kind: "validation",
        type: "min_size",
        reference: minSize,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, "size", dataset, config$1, {
                received: `${dataset.value.size}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/minValue/minValue.ts
/* @__NO_SIDE_EFFECTS__ */ function minValue(requirement, message$1) {
    return {
        kind: "validation",
        type: "min_value",
        reference: minValue,
        async: false,
        expects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, "value", dataset, config$1, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/minWords/minWords.ts
/* @__NO_SIDE_EFFECTS__ */ function minWords(locales, requirement, message$1) {
    return {
        kind: "validation",
        type: "min_words",
        reference: minWords,
        async: false,
        expects: `>=${requirement}`,
        locales,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
                if (count < this.requirement) _addIssue(this, "words", dataset, config$1, {
                    received: `${count}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/multipleOf/multipleOf.ts
/* @__NO_SIDE_EFFECTS__ */ function multipleOf(requirement, message$1) {
    return {
        kind: "validation",
        type: "multiple_of",
        reference: multipleOf,
        async: false,
        expects: `%${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, "multiple", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/nanoid/nanoid.ts
/* @__NO_SIDE_EFFECTS__ */ function nanoid(message$1) {
    return {
        kind: "validation",
        type: "nanoid",
        reference: nanoid,
        async: false,
        expects: null,
        requirement: NANO_ID_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Nano ID", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/nonEmpty/nonEmpty.ts
/* @__NO_SIDE_EFFECTS__ */ function nonEmpty(message$1) {
    return {
        kind: "validation",
        type: "non_empty",
        reference: nonEmpty,
        async: false,
        expects: "!0",
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.length === 0) _addIssue(this, "length", dataset, config$1, {
                received: "0"
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/normalize/normalize.ts
/* @__NO_SIDE_EFFECTS__ */ function normalize(form) {
    return {
        kind: "transformation",
        type: "normalize",
        reference: normalize,
        async: false,
        form,
        "~run" (dataset) {
            dataset.value = dataset.value.normalize(this.form);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/notBytes/notBytes.ts
/* @__NO_SIDE_EFFECTS__ */ function notBytes(requirement, message$1) {
    return {
        kind: "validation",
        type: "not_bytes",
        reference: notBytes,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
                if (length$1 === this.requirement) _addIssue(this, "bytes", dataset, config$1, {
                    received: `${length$1}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/notEntries/notEntries.ts
/* @__NO_SIDE_EFFECTS__ */ function notEntries(requirement, message$1) {
    return {
        kind: "validation",
        type: "not_entries",
        reference: notEntries,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (!dataset.typed) return dataset;
            const count = Object.keys(dataset.value).length;
            if (dataset.typed && count === this.requirement) _addIssue(this, "entries", dataset, config$1, {
                received: `${count}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/notGraphemes/notGraphemes.ts
/* @__NO_SIDE_EFFECTS__ */ function notGraphemes(requirement, message$1) {
    return {
        kind: "validation",
        type: "not_graphemes",
        reference: notGraphemes,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
                if (count === this.requirement) _addIssue(this, "graphemes", dataset, config$1, {
                    received: `${count}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/notLength/notLength.ts
/* @__NO_SIDE_EFFECTS__ */ function notLength(requirement, message$1) {
    return {
        kind: "validation",
        type: "not_length",
        reference: notLength,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, "length", dataset, config$1, {
                received: `${dataset.value.length}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/notSize/notSize.ts
/* @__NO_SIDE_EFFECTS__ */ function notSize(requirement, message$1) {
    return {
        kind: "validation",
        type: "not_size",
        reference: notSize,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, "size", dataset, config$1, {
                received: `${dataset.value.size}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/notValue/notValue.ts
/* @__NO_SIDE_EFFECTS__ */ function notValue(requirement, message$1) {
    return {
        kind: "validation",
        type: "not_value",
        reference: notValue,
        async: false,
        expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, "value", dataset, config$1, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/notValues/notValues.ts
/* @__NO_SIDE_EFFECTS__ */ function notValues(requirement, message$1) {
    return {
        kind: "validation",
        type: "not_values",
        reference: notValues,
        async: false,
        expects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1)=>value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), "|")}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && this.requirement.some((value$1)=>value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/notWords/notWords.ts
/* @__NO_SIDE_EFFECTS__ */ function notWords(locales, requirement, message$1) {
    return {
        kind: "validation",
        type: "not_words",
        reference: notWords,
        async: false,
        expects: `!${requirement}`,
        locales,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
                if (count === this.requirement) _addIssue(this, "words", dataset, config$1, {
                    received: `${count}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/octal/octal.ts
/* @__NO_SIDE_EFFECTS__ */ function octal(message$1) {
    return {
        kind: "validation",
        type: "octal",
        reference: octal,
        async: false,
        expects: null,
        requirement: OCTAL_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "octal", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/parseJson/parseJson.ts
/* @__NO_SIDE_EFFECTS__ */ function parseJson(config$1, message$1) {
    return {
        kind: "transformation",
        type: "parse_json",
        reference: parseJson,
        config: config$1,
        message: message$1,
        async: false,
        "~run" (dataset, config$2) {
            try {
                dataset.value = JSON.parse(dataset.value, this.config?.reviver);
            } catch (error) {
                if (error instanceof Error) {
                    _addIssue(this, "JSON", dataset, config$2, {
                        received: `"${error.message}"`
                    });
                    dataset.typed = false;
                } else throw error;
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts
/**
* Checks if a dataset is partially typed.
*
* @param dataset The dataset to check.
* @param paths The paths to check.
*
* @returns Whether it is partially typed.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _isPartiallyTyped(dataset, paths) {
    if (dataset.issues) for (const path of paths)for (const issue of dataset.issues){
        let typed = false;
        const bound = Math.min(path.length, issue.path?.length ?? 0);
        for(let index = 0; index < bound; index++)if (path[index] !== issue.path[index].key && (path[index] !== "$" || issue.path[index].type !== "array")) {
            typed = true;
            break;
        }
        if (!typed) return false;
    }
    return true;
}
//#endregion
//#region src/actions/partialCheck/partialCheck.ts
/* @__NO_SIDE_EFFECTS__ */ function partialCheck(paths, requirement, message$1) {
    return {
        kind: "validation",
        type: "partial_check",
        reference: partialCheck,
        async: false,
        expects: null,
        paths,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/partialCheck/partialCheckAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function partialCheckAsync(paths, requirement, message$1) {
    return {
        kind: "validation",
        type: "partial_check",
        reference: partialCheckAsync,
        async: true,
        expects: null,
        paths,
        requirement,
        message: message$1,
        async "~run" (dataset, config$1) {
            if ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/rawCheck/rawCheck.ts
/**
* Creates a raw check validation action.
*
* @param action The validation action.
*
* @returns A raw check action.
*/ /* @__NO_SIDE_EFFECTS__ */ function rawCheck(action) {
    return {
        kind: "validation",
        type: "raw_check",
        reference: rawCheck,
        async: false,
        expects: null,
        "~run" (dataset, config$1) {
            action({
                dataset,
                config: config$1,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config$1, info)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/rawCheck/rawCheckAsync.ts
/**
* Creates a raw check validation action.
*
* @param action The validation action.
*
* @returns A raw check action.
*/ /* @__NO_SIDE_EFFECTS__ */ function rawCheckAsync(action) {
    return {
        kind: "validation",
        type: "raw_check",
        reference: rawCheckAsync,
        async: true,
        expects: null,
        async "~run" (dataset, config$1) {
            await action({
                dataset,
                config: config$1,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config$1, info)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/rawTransform/rawTransform.ts
/**
* Creates a raw transformation action.
*
* @param action The transformation action.
*
* @returns A raw transform action.
*/ /* @__NO_SIDE_EFFECTS__ */ function rawTransform(action) {
    return {
        kind: "transformation",
        type: "raw_transform",
        reference: rawTransform,
        async: false,
        "~run" (dataset, config$1) {
            const output = action({
                dataset,
                config: config$1,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config$1, info),
                NEVER: null
            });
            if (dataset.issues) dataset.typed = false;
            else dataset.value = output;
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/rawTransform/rawTransformAsync.ts
/**
* Creates a raw transformation action.
*
* @param action The transformation action.
*
* @returns A raw transform action.
*/ /* @__NO_SIDE_EFFECTS__ */ function rawTransformAsync(action) {
    return {
        kind: "transformation",
        type: "raw_transform",
        reference: rawTransformAsync,
        async: true,
        async "~run" (dataset, config$1) {
            const output = await action({
                dataset,
                config: config$1,
                addIssue: (info)=>_addIssue(this, info?.label ?? "input", dataset, config$1, info),
                NEVER: null
            });
            if (dataset.issues) dataset.typed = false;
            else dataset.value = output;
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/readonly/readonly.ts
/* @__NO_SIDE_EFFECTS__ */ function readonly() {
    return {
        kind: "transformation",
        type: "readonly",
        reference: readonly,
        async: false,
        "~run" (dataset) {
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/reduceItems/reduceItems.ts
/* @__NO_SIDE_EFFECTS__ */ function reduceItems(operation, initial) {
    return {
        kind: "transformation",
        type: "reduce_items",
        reference: reduceItems,
        async: false,
        operation,
        initial,
        "~run" (dataset) {
            dataset.value = dataset.value.reduce(this.operation, this.initial);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/regex/regex.ts
/* @__NO_SIDE_EFFECTS__ */ function regex(requirement, message$1) {
    return {
        kind: "validation",
        type: "regex",
        reference: regex,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "format", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/returns/returns.ts
/* @__NO_SIDE_EFFECTS__ */ function returns(schema) {
    return {
        kind: "transformation",
        type: "returns",
        reference: returns,
        async: false,
        schema,
        "~run" (dataset, config$1) {
            const func = dataset.value;
            dataset.value = (...args_)=>{
                const returnsDataset = this.schema["~run"]({
                    value: func(...args_)
                }, config$1);
                if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
                return returnsDataset.value;
            };
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/returns/returnsAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function returnsAsync(schema) {
    return {
        kind: "transformation",
        type: "returns",
        reference: returnsAsync,
        async: false,
        schema,
        "~run" (dataset, config$1) {
            const func = dataset.value;
            dataset.value = async (...args_)=>{
                const returnsDataset = await this.schema["~run"]({
                    value: await func(...args_)
                }, config$1);
                if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
                return returnsDataset.value;
            };
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/rfcEmail/rfcEmail.ts
/* @__NO_SIDE_EFFECTS__ */ function rfcEmail(message$1) {
    return {
        kind: "validation",
        type: "rfc_email",
        reference: rfcEmail,
        expects: null,
        async: false,
        requirement: RFC_EMAIL_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/safeInteger/safeInteger.ts
/* @__NO_SIDE_EFFECTS__ */ function safeInteger(message$1) {
    return {
        kind: "validation",
        type: "safe_integer",
        reference: safeInteger,
        async: false,
        expects: null,
        requirement: Number.isSafeInteger,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "safe integer", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/size/size.ts
/* @__NO_SIDE_EFFECTS__ */ function size(requirement, message$1) {
    return {
        kind: "validation",
        type: "size",
        reference: size,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, "size", dataset, config$1, {
                received: `${dataset.value.size}`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/slug/slug.ts
/* @__NO_SIDE_EFFECTS__ */ function slug(message$1) {
    return {
        kind: "validation",
        type: "slug",
        reference: slug,
        async: false,
        expects: null,
        requirement: SLUG_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "slug", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/someItem/someItem.ts
/* @__NO_SIDE_EFFECTS__ */ function someItem(requirement, message$1) {
    return {
        kind: "validation",
        type: "some_item",
        reference: someItem,
        async: false,
        expects: null,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, "item", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/sortItems/sortItems.ts
/* @__NO_SIDE_EFFECTS__ */ function sortItems(operation) {
    return {
        kind: "transformation",
        type: "sort_items",
        reference: sortItems,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = dataset.value.sort(this.operation);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/startsWith/startsWith.ts
/* @__NO_SIDE_EFFECTS__ */ function startsWith(requirement, message$1) {
    return {
        kind: "validation",
        type: "starts_with",
        reference: startsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, "start", dataset, config$1, {
                received: `"${dataset.value.slice(0, this.requirement.length)}"`
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/stringifyJson/stringifyJson.ts
/* @__NO_SIDE_EFFECTS__ */ function stringifyJson(config$1, message$1) {
    return {
        kind: "transformation",
        type: "stringify_json",
        reference: stringifyJson,
        message: message$1,
        config: config$1,
        async: false,
        "~run" (dataset, config$2) {
            try {
                const output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);
                if (output === void 0) {
                    _addIssue(this, "JSON", dataset, config$2);
                    dataset.typed = false;
                }
                dataset.value = output;
            } catch (error) {
                if (error instanceof Error) {
                    _addIssue(this, "JSON", dataset, config$2, {
                        received: `"${error.message}"`
                    });
                    dataset.typed = false;
                } else throw error;
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/title/title.ts
/**
* Creates a title metadata action.
*
* @param title_ The title text.
*
* @returns A title action.
*/ /* @__NO_SIDE_EFFECTS__ */ function title(title_) {
    return {
        kind: "metadata",
        type: "title",
        reference: title,
        title: title_
    };
}
//#endregion
//#region src/actions/toBigint/toBigint.ts
/* @__NO_SIDE_EFFECTS__ */ function toBigint(message$1) {
    return {
        kind: "transformation",
        type: "to_bigint",
        reference: toBigint,
        async: false,
        message: message$1,
        "~run" (dataset, config$1) {
            try {
                dataset.value = BigInt(dataset.value);
            } catch  {
                _addIssue(this, "bigint", dataset, config$1);
                dataset.typed = false;
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/toBoolean/toBoolean.ts
/**
* Creates a to boolean transformation action.
*
* @returns A to boolean action.
*
* @beta
*/ /* @__NO_SIDE_EFFECTS__ */ function toBoolean() {
    return {
        kind: "transformation",
        type: "to_boolean",
        reference: toBoolean,
        async: false,
        "~run" (dataset) {
            dataset.value = Boolean(dataset.value);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/toDate/toDate.ts
/* @__NO_SIDE_EFFECTS__ */ function toDate(message$1) {
    return {
        kind: "transformation",
        type: "to_date",
        reference: toDate,
        async: false,
        message: message$1,
        "~run" (dataset, config$1) {
            try {
                dataset.value = new Date(dataset.value);
                if (isNaN(dataset.value)) {
                    _addIssue(this, "date", dataset, config$1, {
                        received: "\"Invalid Date\""
                    });
                    dataset.typed = false;
                }
            } catch  {
                _addIssue(this, "date", dataset, config$1);
                dataset.typed = false;
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/toLowerCase/toLowerCase.ts
/**
* Creates a to lower case transformation action.
*
* @returns A to lower case action.
*/ /* @__NO_SIDE_EFFECTS__ */ function toLowerCase() {
    return {
        kind: "transformation",
        type: "to_lower_case",
        reference: toLowerCase,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.toLowerCase();
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/toMaxValue/toMaxValue.ts
/**
* Creates a to max value transformation action.
*
* @param requirement The maximum value.
*
* @returns A to max value action.
*/ /* @__NO_SIDE_EFFECTS__ */ function toMaxValue(requirement) {
    return {
        kind: "transformation",
        type: "to_max_value",
        reference: toMaxValue,
        async: false,
        requirement,
        "~run" (dataset) {
            dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/toMinValue/toMinValue.ts
/**
* Creates a to min value transformation action.
*
* @param requirement The minimum value.
*
* @returns A to min value action.
*/ /* @__NO_SIDE_EFFECTS__ */ function toMinValue(requirement) {
    return {
        kind: "transformation",
        type: "to_min_value",
        reference: toMinValue,
        async: false,
        requirement,
        "~run" (dataset) {
            dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/toNumber/toNumber.ts
/* @__NO_SIDE_EFFECTS__ */ function toNumber(message$1) {
    return {
        kind: "transformation",
        type: "to_number",
        reference: toNumber,
        async: false,
        message: message$1,
        "~run" (dataset, config$1) {
            try {
                dataset.value = Number(dataset.value);
                if (isNaN(dataset.value)) {
                    _addIssue(this, "number", dataset, config$1);
                    dataset.typed = false;
                }
            } catch  {
                _addIssue(this, "number", dataset, config$1);
                dataset.typed = false;
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/toString/toString.ts
/* @__NO_SIDE_EFFECTS__ */ function toString(message$1) {
    return {
        kind: "transformation",
        type: "to_string",
        reference: toString,
        async: false,
        message: message$1,
        "~run" (dataset, config$1) {
            try {
                dataset.value = String(dataset.value);
            } catch  {
                _addIssue(this, "string", dataset, config$1);
                dataset.typed = false;
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/toUpperCase/toUpperCase.ts
/**
* Creates a to upper case transformation action.
*
* @returns A to upper case action.
*/ /* @__NO_SIDE_EFFECTS__ */ function toUpperCase() {
    return {
        kind: "transformation",
        type: "to_upper_case",
        reference: toUpperCase,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.toUpperCase();
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/transform/transform.ts
/**
* Creates a custom transformation action.
*
* @param operation The transformation operation.
*
* @returns A transform action.
*/ /* @__NO_SIDE_EFFECTS__ */ function transform(operation) {
    return {
        kind: "transformation",
        type: "transform",
        reference: transform,
        async: false,
        operation,
        "~run" (dataset) {
            dataset.value = this.operation(dataset.value);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/transform/transformAsync.ts
/**
* Creates a custom transformation action.
*
* @param operation The transformation operation.
*
* @returns A transform action.
*/ /* @__NO_SIDE_EFFECTS__ */ function transformAsync(operation) {
    return {
        kind: "transformation",
        type: "transform",
        reference: transformAsync,
        async: true,
        operation,
        async "~run" (dataset) {
            dataset.value = await this.operation(dataset.value);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/trim/trim.ts
/**
* Creates a trim transformation action.
*
* @returns A trim action.
*/ /* @__NO_SIDE_EFFECTS__ */ function trim() {
    return {
        kind: "transformation",
        type: "trim",
        reference: trim,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.trim();
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/trimEnd/trimEnd.ts
/**
* Creates a trim end transformation action.
*
* @returns A trim end action.
*/ /* @__NO_SIDE_EFFECTS__ */ function trimEnd() {
    return {
        kind: "transformation",
        type: "trim_end",
        reference: trimEnd,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.trimEnd();
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/trimStart/trimStart.ts
/**
* Creates a trim start transformation action.
*
* @returns A trim start action.
*/ /* @__NO_SIDE_EFFECTS__ */ function trimStart() {
    return {
        kind: "transformation",
        type: "trim_start",
        reference: trimStart,
        async: false,
        "~run" (dataset) {
            dataset.value = dataset.value.trimStart();
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/ulid/ulid.ts
/* @__NO_SIDE_EFFECTS__ */ function ulid(message$1) {
    return {
        kind: "validation",
        type: "ulid",
        reference: ulid,
        async: false,
        expects: null,
        requirement: ULID_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "ULID", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/url/url.ts
/* @__NO_SIDE_EFFECTS__ */ function url(message$1) {
    return {
        kind: "validation",
        type: "url",
        reference: url,
        async: false,
        expects: null,
        requirement (input) {
            try {
                new URL(input);
                return true;
            } catch  {
                return false;
            }
        },
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "URL", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/uuid/uuid.ts
/* @__NO_SIDE_EFFECTS__ */ function uuid(message$1) {
    return {
        kind: "validation",
        type: "uuid",
        reference: uuid,
        async: false,
        expects: null,
        requirement: UUID_REGEX,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "UUID", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/value/value.ts
/* @__NO_SIDE_EFFECTS__ */ function value(requirement, message$1) {
    return {
        kind: "validation",
        type: "value",
        reference: value,
        async: false,
        expects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, "value", dataset, config$1, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/values/values.ts
/* @__NO_SIDE_EFFECTS__ */ function values(requirement, message$1) {
    return {
        kind: "validation",
        type: "values",
        reference: values,
        async: false,
        expects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1)=>value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), "|")}`,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed && !this.requirement.some((value$1)=>value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, {
                received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/actions/words/words.ts
/* @__NO_SIDE_EFFECTS__ */ function words(locales, requirement, message$1) {
    return {
        kind: "validation",
        type: "words",
        reference: words,
        async: false,
        expects: `${requirement}`,
        locales,
        requirement,
        message: message$1,
        "~run" (dataset, config$1) {
            if (dataset.typed) {
                const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
                if (count !== this.requirement) _addIssue(this, "words", dataset, config$1, {
                    received: `${count}`
                });
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/methods/assert/assert.ts
/**
* Checks if the input matches the schema. As this is an assertion function, it
* can be used as a type guard.
*
* @param schema The schema to be used.
* @param input The input to be tested.
*/ function assert(schema, input) {
    const issues = schema["~run"]({
        value: input
    }, {
        abortEarly: true
    }).issues;
    if (issues) throw new ValiError(issues);
}
//#endregion
//#region src/methods/config/config.ts
/**
* Changes the local configuration of a schema.
*
* @param schema The schema to configure.
* @param config The parse configuration.
*
* @returns The configured schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function config(schema, config$1) {
    return {
        ...schema,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config_) {
            return schema["~run"](dataset, {
                ...config_,
                ...config$1
            });
        }
    };
}
//#endregion
//#region src/methods/getFallback/getFallback.ts
/**
* Returns the fallback value of the schema.
*
* @param schema The schema to get it from.
* @param dataset The output dataset if available.
* @param config The config if available.
*
* @returns The fallback value.
*/ /* @__NO_SIDE_EFFECTS__ */ function getFallback(schema, dataset, config$1) {
    return typeof schema.fallback === "function" ? schema.fallback(dataset, config$1) : schema.fallback;
}
//#endregion
//#region src/methods/fallback/fallback.ts
/**
* Returns a fallback value as output if the input does not match the schema.
*
* @param schema The schema to catch.
* @param fallback The fallback value.
*
* @returns The passed schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function fallback(schema, fallback$1) {
    return {
        ...schema,
        fallback: fallback$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const outputDataset = schema["~run"](dataset, config$1);
            return outputDataset.issues ? {
                typed: true,
                value: /* @__PURE__ */ getFallback(this, outputDataset, config$1)
            } : outputDataset;
        }
    };
}
//#endregion
//#region src/methods/fallback/fallbackAsync.ts
/**
* Returns a fallback value as output if the input does not match the schema.
*
* @param schema The schema to catch.
* @param fallback The fallback value.
*
* @returns The passed schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function fallbackAsync(schema, fallback$1) {
    return {
        ...schema,
        fallback: fallback$1,
        async: true,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const outputDataset = await schema["~run"](dataset, config$1);
            return outputDataset.issues ? {
                typed: true,
                value: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)
            } : outputDataset;
        }
    };
}
//#endregion
//#region src/methods/flatten/flatten.ts
/* @__NO_SIDE_EFFECTS__ */ function flatten(issues) {
    const flatErrors = {};
    for (const issue of issues)if (issue.path) {
        const dotPath = /* @__PURE__ */ getDotPath(issue);
        if (dotPath) {
            if (!flatErrors.nested) flatErrors.nested = {};
            if (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);
            else flatErrors.nested[dotPath] = [
                issue.message
            ];
        } else if (flatErrors.other) flatErrors.other.push(issue.message);
        else flatErrors.other = [
            issue.message
        ];
    } else if (flatErrors.root) flatErrors.root.push(issue.message);
    else flatErrors.root = [
        issue.message
    ];
    return flatErrors;
}
//#endregion
//#region src/methods/forward/forward.ts
/**
* Forwards the issues of the passed validation action.
*
* @param action The validation action.
* @param path The path to forward the issues to.
*
* @returns The modified action.
*/ /* @__NO_SIDE_EFFECTS__ */ function forward(action, path) {
    return {
        ...action,
        "~run" (dataset, config$1) {
            const prevIssues = dataset.issues && [
                ...dataset.issues
            ];
            dataset = action["~run"](dataset, config$1);
            if (dataset.issues) {
                for (const issue of dataset.issues)if (!prevIssues?.includes(issue)) {
                    let pathInput = dataset.value;
                    for (const key of path){
                        const pathValue = pathInput[key];
                        const pathItem = {
                            type: "unknown",
                            origin: "value",
                            input: pathInput,
                            key,
                            value: pathValue
                        };
                        if (issue.path) issue.path.push(pathItem);
                        else issue.path = [
                            pathItem
                        ];
                        if (!pathValue) break;
                        pathInput = pathValue;
                    }
                }
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/methods/forward/forwardAsync.ts
/**
* Forwards the issues of the passed validation action.
*
* @param action The validation action.
* @param path The path to forward the issues to.
*
* @returns The modified action.
*/ /* @__NO_SIDE_EFFECTS__ */ function forwardAsync(action, path) {
    return {
        ...action,
        async: true,
        async "~run" (dataset, config$1) {
            const prevIssues = dataset.issues && [
                ...dataset.issues
            ];
            dataset = await action["~run"](dataset, config$1);
            if (dataset.issues) {
                for (const issue of dataset.issues)if (!prevIssues?.includes(issue)) {
                    let pathInput = dataset.value;
                    for (const key of path){
                        const pathValue = pathInput[key];
                        const pathItem = {
                            type: "unknown",
                            origin: "value",
                            input: pathInput,
                            key,
                            value: pathValue
                        };
                        if (issue.path) issue.path.push(pathItem);
                        else issue.path = [
                            pathItem
                        ];
                        if (!pathValue) break;
                        pathInput = pathValue;
                    }
                }
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/methods/getDefault/getDefault.ts
/**
* Returns the default value of the schema.
*
* @param schema The schema to get it from.
* @param dataset The input dataset if available.
* @param config The config if available.
*
* @returns The default value.
*/ /* @__NO_SIDE_EFFECTS__ */ function getDefault(schema, dataset, config$1) {
    return typeof schema.default === "function" ? schema.default(dataset, config$1) : schema.default;
}
//#endregion
//#region src/methods/getDefaults/getDefaults.ts
/**
* Returns the default values of the schema.
*
* Hint: The difference to `getDefault` is that for object and tuple schemas
* this function recursively returns the default values of the subschemas
* instead of `undefined`.
*
* @param schema The schema to get them from.
*
* @returns The default values.
*/ /* @__NO_SIDE_EFFECTS__ */ function getDefaults(schema) {
    if ("entries" in schema) {
        const object$1 = {};
        for(const key in schema.entries)object$1[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);
        return object$1;
    }
    if ("items" in schema) return schema.items.map(getDefaults);
    return /* @__PURE__ */ getDefault(schema);
}
//#endregion
//#region src/methods/getDefaults/getDefaultsAsync.ts
/**
* Returns the default values of the schema.
*
* Hint: The difference to `getDefault` is that for object and tuple schemas
* this function recursively returns the default values of the subschemas
* instead of `undefined`.
*
* @param schema The schema to get them from.
*
* @returns The default values.
*/ /* @__NO_SIDE_EFFECTS__ */ async function getDefaultsAsync(schema) {
    if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1])=>[
            key,
            await /* @__PURE__ */ getDefaultsAsync(value$1)
        ])));
    if ("items" in schema) return Promise.all(schema.items.map(getDefaultsAsync));
    return /* @__PURE__ */ getDefault(schema);
}
//#endregion
//#region src/methods/getDescription/getDescription.ts
/**
* Returns the description of the schema.
*
* If multiple descriptions are defined, the last one of the highest level is
* returned. If no description is defined, `undefined` is returned.
*
* @param schema The schema to get the description from.
*
* @returns The description, if any.
*
* @beta
*/ /* @__NO_SIDE_EFFECTS__ */ function getDescription(schema) {
    return /* @__PURE__ */ _getLastMetadata(schema, "description");
}
//#endregion
//#region src/methods/getExamples/getExamples.ts
/**
* Returns the examples of a schema.
*
* If multiple examples are defined, it concatenates them using depth-first
* search. If no examples are defined, an empty array is returned.
*
* @param schema The schema to get the examples from.
*
* @returns The examples, if any.
*
* @beta
*/ /* @__NO_SIDE_EFFECTS__ */ function getExamples(schema) {
    const examples$1 = [];
    function depthFirstCollect(schema$1) {
        if ("pipe" in schema$1) {
            for (const item of schema$1.pipe)if (item.kind === "schema" && "pipe" in item) depthFirstCollect(item);
            else if (item.kind === "metadata" && item.type === "examples") examples$1.push(...item.examples);
        }
    }
    depthFirstCollect(schema);
    return examples$1;
}
//#endregion
//#region src/methods/getFallbacks/getFallbacks.ts
/**
* Returns the fallback values of the schema.
*
* Hint: The difference to `getFallback` is that for object and tuple schemas
* this function recursively returns the fallback values of the subschemas
* instead of `undefined`.
*
* @param schema The schema to get them from.
*
* @returns The fallback values.
*/ /* @__NO_SIDE_EFFECTS__ */ function getFallbacks(schema) {
    if ("entries" in schema) {
        const object$1 = {};
        for(const key in schema.entries)object$1[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);
        return object$1;
    }
    if ("items" in schema) return schema.items.map(getFallbacks);
    return /* @__PURE__ */ getFallback(schema);
}
//#endregion
//#region src/methods/getFallbacks/getFallbacksAsync.ts
/**
* Returns the fallback values of the schema.
*
* Hint: The difference to `getFallback` is that for object and tuple schemas
* this function recursively returns the fallback values of the subschemas
* instead of `undefined`.
*
* @param schema The schema to get them from.
*
* @returns The fallback values.
*/ /* @__NO_SIDE_EFFECTS__ */ async function getFallbacksAsync(schema) {
    if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1])=>[
            key,
            await /* @__PURE__ */ getFallbacksAsync(value$1)
        ])));
    if ("items" in schema) return Promise.all(schema.items.map(getFallbacksAsync));
    return /* @__PURE__ */ getFallback(schema);
}
//#endregion
//#region src/methods/getMetadata/getMetadata.ts
/**
* Returns the metadata of a schema.
*
* If multiple metadata are defined, it shallowly merges them using depth-first
* search. If no metadata is defined, an empty object is returned.
*
* @param schema Schema to get the metadata from.
*
* @returns The metadata, if any.
*
* @beta
*/ /* @__NO_SIDE_EFFECTS__ */ function getMetadata(schema) {
    const result = {};
    function depthFirstMerge(schema$1) {
        if ("pipe" in schema$1) {
            for (const item of schema$1.pipe)if (item.kind === "schema" && "pipe" in item) depthFirstMerge(item);
            else if (item.kind === "metadata" && item.type === "metadata") Object.assign(result, item.metadata);
        }
    }
    depthFirstMerge(schema);
    return result;
}
//#endregion
//#region src/methods/getTitle/getTitle.ts
/**
* Returns the title of the schema.
*
* If multiple titles are defined, the last one of the highest level is
* returned. If no title is defined, `undefined` is returned.
*
* @param schema The schema to get the title from.
*
* @returns The title, if any.
*
* @beta
*/ /* @__NO_SIDE_EFFECTS__ */ function getTitle(schema) {
    return /* @__PURE__ */ _getLastMetadata(schema, "title");
}
//#endregion
//#region src/methods/is/is.ts
/**
* Checks if the input matches the schema. By using a type predicate, this
* function can be used as a type guard.
*
* @param schema The schema to be used.
* @param input The input to be tested.
*
* @returns Whether the input matches the schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function is(schema, input) {
    return !schema["~run"]({
        value: input
    }, {
        abortEarly: true
    }).issues;
}
//#endregion
//#region src/schemas/any/any.ts
/**
* Creates an any schema.
*
* Hint: This schema function exists only for completeness and is not
* recommended in practice. Instead, `unknown` should be used to accept
* unknown data.
*
* @returns An any schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function any() {
    return {
        kind: "schema",
        type: "any",
        reference: any,
        expects: "any",
        async: false,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset) {
            dataset.typed = true;
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/array/array.ts
/* @__NO_SIDE_EFFECTS__ */ function array(item, message$1) {
    return {
        kind: "schema",
        type: "array",
        reference: array,
        expects: "Array",
        async: false,
        item,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < input.length; key++){
                    const value$1 = input[key];
                    const itemDataset = this.item["~run"]({
                        value: value$1
                    }, config$1);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/array/arrayAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function arrayAsync(item, message$1) {
    return {
        kind: "schema",
        type: "array",
        reference: arrayAsync,
        expects: "Array",
        async: true,
        item,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(input.map((value$1)=>this.item["~run"]({
                        value: value$1
                    }, config$1)));
                for(let key = 0; key < itemDatasets.length; key++){
                    const itemDataset = itemDatasets[key];
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: input[key]
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/bigint/bigint.ts
/* @__NO_SIDE_EFFECTS__ */ function bigint(message$1) {
    return {
        kind: "schema",
        type: "bigint",
        reference: bigint,
        expects: "bigint",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (typeof dataset.value === "bigint") dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/blob/blob.ts
/* @__NO_SIDE_EFFECTS__ */ function blob(message$1) {
    return {
        kind: "schema",
        type: "blob",
        reference: blob,
        expects: "Blob",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value instanceof Blob) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/boolean/boolean.ts
/* @__NO_SIDE_EFFECTS__ */ function boolean(message$1) {
    return {
        kind: "schema",
        type: "boolean",
        reference: boolean,
        expects: "boolean",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (typeof dataset.value === "boolean") dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/custom/custom.ts
/* @__NO_SIDE_EFFECTS__ */ function custom(check$1, message$1) {
    return {
        kind: "schema",
        type: "custom",
        reference: custom,
        expects: "unknown",
        async: false,
        check: check$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (this.check(dataset.value)) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/custom/customAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function customAsync(check$1, message$1) {
    return {
        kind: "schema",
        type: "custom",
        reference: customAsync,
        expects: "unknown",
        async: true,
        check: check$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            if (await this.check(dataset.value)) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/date/date.ts
/* @__NO_SIDE_EFFECTS__ */ function date(message$1) {
    return {
        kind: "schema",
        type: "date",
        reference: date,
        expects: "Date",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1, {
                received: "\"Invalid Date\""
            });
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/enum/enum.ts
/* @__NO_SIDE_EFFECTS__ */ function enum_(enum__, message$1) {
    const options = [];
    for(const key in enum__)if (`${+key}` !== key || typeof enum__[key] !== "string" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);
    return {
        kind: "schema",
        type: "enum",
        reference: enum_,
        expects: /* @__PURE__ */ _joinExpects(options.map(_stringify), "|"),
        async: false,
        enum: enum__,
        options,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (this.options.includes(dataset.value)) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/exactOptional/exactOptional.ts
/* @__NO_SIDE_EFFECTS__ */ function exactOptional(wrapped, default_) {
    return {
        kind: "schema",
        type: "exact_optional",
        reference: exactOptional,
        expects: wrapped.expects,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/exactOptional/exactOptionalAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function exactOptionalAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "exact_optional",
        reference: exactOptionalAsync,
        expects: wrapped.expects,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/file/file.ts
/* @__NO_SIDE_EFFECTS__ */ function file(message$1) {
    return {
        kind: "schema",
        type: "file",
        reference: file,
        expects: "File",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value instanceof File) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/function/function.ts
/* @__NO_SIDE_EFFECTS__ */ function function_(message$1) {
    return {
        kind: "schema",
        type: "function",
        reference: function_,
        expects: "Function",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (typeof dataset.value === "function") dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/instance/instance.ts
/* @__NO_SIDE_EFFECTS__ */ function instance(class_, message$1) {
    return {
        kind: "schema",
        type: "instance",
        reference: instance,
        expects: class_.name,
        async: false,
        class: class_,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value instanceof this.class) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/intersect/utils/_merge/_merge.ts
/**
* Merges two values into one single output.
*
* @param value1 First value.
* @param value2 Second value.
*
* @returns The merge dataset.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _merge(value1, value2) {
    if (typeof value1 === typeof value2) {
        if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return {
            value: value1
        };
        if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
            for(const key in value2)if (key in value1) {
                const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);
                if (dataset.issue) return dataset;
                value1[key] = dataset.value;
            } else value1[key] = value2[key];
            return {
                value: value1
            };
        }
        if (Array.isArray(value1) && Array.isArray(value2)) {
            if (value1.length === value2.length) {
                for(let index = 0; index < value1.length; index++){
                    const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);
                    if (dataset.issue) return dataset;
                    value1[index] = dataset.value;
                }
                return {
                    value: value1
                };
            }
        }
    }
    return {
        issue: true
    };
}
//#endregion
//#region src/schemas/intersect/intersect.ts
/* @__NO_SIDE_EFFECTS__ */ function intersect(options, message$1) {
    return {
        kind: "schema",
        type: "intersect",
        reference: intersect,
        expects: /* @__PURE__ */ _joinExpects(options.map((option)=>option.expects), "&"),
        async: false,
        options,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (this.options.length) {
                const input = dataset.value;
                let outputs;
                dataset.typed = true;
                for (const schema of this.options){
                    const optionDataset = schema["~run"]({
                        value: input
                    }, config$1);
                    if (optionDataset.issues) {
                        if (dataset.issues) dataset.issues.push(...optionDataset.issues);
                        else dataset.issues = optionDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!optionDataset.typed) dataset.typed = false;
                    if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
                    else outputs = [
                        optionDataset.value
                    ];
                }
                if (dataset.typed) {
                    dataset.value = outputs[0];
                    for(let index = 1; index < outputs.length; index++){
                        const mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);
                        if (mergeDataset.issue) {
                            _addIssue(this, "type", dataset, config$1, {
                                received: "unknown"
                            });
                            break;
                        }
                        dataset.value = mergeDataset.value;
                    }
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/intersect/intersectAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function intersectAsync(options, message$1) {
    return {
        kind: "schema",
        type: "intersect",
        reference: intersectAsync,
        expects: /* @__PURE__ */ _joinExpects(options.map((option)=>option.expects), "&"),
        async: true,
        options,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            if (this.options.length) {
                const input = dataset.value;
                let outputs;
                dataset.typed = true;
                const optionDatasets = await Promise.all(this.options.map((schema)=>schema["~run"]({
                        value: input
                    }, config$1)));
                for (const optionDataset of optionDatasets){
                    if (optionDataset.issues) {
                        if (dataset.issues) dataset.issues.push(...optionDataset.issues);
                        else dataset.issues = optionDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!optionDataset.typed) dataset.typed = false;
                    if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
                    else outputs = [
                        optionDataset.value
                    ];
                }
                if (dataset.typed) {
                    dataset.value = outputs[0];
                    for(let index = 1; index < outputs.length; index++){
                        const mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);
                        if (mergeDataset.issue) {
                            _addIssue(this, "type", dataset, config$1, {
                                received: "unknown"
                            });
                            break;
                        }
                        dataset.value = mergeDataset.value;
                    }
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/lazy/lazy.ts
/**
* Creates a lazy schema.
*
* @param getter The schema getter.
*
* @returns A lazy schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function lazy(getter) {
    return {
        kind: "schema",
        type: "lazy",
        reference: lazy,
        expects: "unknown",
        async: false,
        getter,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            return this.getter(dataset.value)["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/lazy/lazyAsync.ts
/**
* Creates a lazy schema.
*
* @param getter The schema getter.
*
* @returns A lazy schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function lazyAsync(getter) {
    return {
        kind: "schema",
        type: "lazy",
        reference: lazyAsync,
        expects: "unknown",
        async: true,
        getter,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            return (await this.getter(dataset.value))["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/literal/literal.ts
/* @__NO_SIDE_EFFECTS__ */ function literal(literal_, message$1) {
    return {
        kind: "schema",
        type: "literal",
        reference: literal,
        expects: /* @__PURE__ */ _stringify(literal_),
        async: false,
        literal: literal_,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value === this.literal) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/looseObject/looseObject.ts
/* @__NO_SIDE_EFFECTS__ */ function looseObject(entries$1, message$1) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: looseObject,
        expects: "Object",
        async: false,
        entries: entries$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                        const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value$1
                        }, config$1);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value$1
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) issue.path.unshift(pathItem);
                                else issue.path = [
                                    pathItem
                                ];
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) dataset.issues = valueDataset.issues;
                            if (config$1.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) dataset.typed = false;
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
                    else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config$1, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: input[key]
                                }
                            ]
                        });
                        if (config$1.abortEarly) break;
                    }
                }
                if (!dataset.issues || !config$1.abortEarly) {
                    for(const key in input)if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/looseObject/looseObjectAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function looseObjectAsync(entries$1, message$1) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: looseObjectAsync,
        expects: "Object",
        async: true,
        entries: entries$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                        const value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);
                        return [
                            key,
                            value$1,
                            valueSchema,
                            await valueSchema["~run"]({
                                value: value$1
                            }, config$1)
                        ];
                    }
                    return [
                        key,
                        input[key],
                        valueSchema,
                        null
                    ];
                }));
                for (const [key, value$1, valueSchema, valueDataset] of valueDatasets)if (valueDataset) {
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) dataset.typed = false;
                    dataset.value[key] = valueDataset.value;
                } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);
                else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                    _addIssue(this, "key", dataset, config$1, {
                        input: void 0,
                        expected: `"${key}"`,
                        path: [
                            {
                                type: "object",
                                origin: "key",
                                input,
                                key,
                                value: value$1
                            }
                        ]
                    });
                    if (config$1.abortEarly) break;
                }
                if (!dataset.issues || !config$1.abortEarly) {
                    for(const key in input)if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/looseTuple/looseTuple.ts
/* @__NO_SIDE_EFFECTS__ */ function looseTuple(items, message$1) {
    return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTuple,
        expects: "Array",
        async: false,
        items,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value$1 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value$1
                    }, config$1);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config$1.abortEarly) for(let key = this.items.length; key < input.length; key++)dataset.value.push(input[key]);
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/looseTuple/looseTupleAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function looseTupleAsync(items, message$1) {
    return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTupleAsync,
        expects: "Array",
        async: true,
        items,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{
                    const value$1 = input[key];
                    return [
                        key,
                        value$1,
                        await item["~run"]({
                            value: value$1
                        }, config$1)
                    ];
                }));
                for (const [key, value$1, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config$1.abortEarly) for(let key = this.items.length; key < input.length; key++)dataset.value.push(input[key]);
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/map/map.ts
/* @__NO_SIDE_EFFECTS__ */ function map(key, value$1, message$1) {
    return {
        kind: "schema",
        type: "map",
        reference: map,
        expects: "Map",
        async: false,
        key,
        value: value$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input instanceof Map) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Map();
                for (const [inputKey, inputValue] of input){
                    const keyDataset = this.key["~run"]({
                        value: inputKey
                    }, config$1);
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "key",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of keyDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = keyDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    const valueDataset = this.value["~run"]({
                        value: inputValue
                    }, config$1);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "value",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
                    dataset.value.set(keyDataset.value, valueDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/map/mapAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function mapAsync(key, value$1, message$1) {
    return {
        kind: "schema",
        type: "map",
        reference: mapAsync,
        expects: "Map",
        async: true,
        key,
        value: value$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input instanceof Map) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Map();
                const datasets = await Promise.all([
                    ...input
                ].map(([inputKey, inputValue])=>Promise.all([
                        inputKey,
                        inputValue,
                        this.key["~run"]({
                            value: inputKey
                        }, config$1),
                        this.value["~run"]({
                            value: inputValue
                        }, config$1)
                    ])));
                for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets){
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "key",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of keyDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = keyDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "value",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
                    dataset.value.set(keyDataset.value, valueDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/nan/nan.ts
/* @__NO_SIDE_EFFECTS__ */ function nan(message$1) {
    return {
        kind: "schema",
        type: "nan",
        reference: nan,
        expects: "NaN",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (Number.isNaN(dataset.value)) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/never/never.ts
/* @__NO_SIDE_EFFECTS__ */ function never(message$1) {
    return {
        kind: "schema",
        type: "never",
        reference: never,
        expects: "never",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/nonNullable/nonNullable.ts
/* @__NO_SIDE_EFFECTS__ */ function nonNullable(wrapped, message$1) {
    return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullable,
        expects: "!null",
        async: false,
        wrapped,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value !== null) dataset = this.wrapped["~run"](dataset, config$1);
            if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/nonNullable/nonNullableAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function nonNullableAsync(wrapped, message$1) {
    return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullableAsync,
        expects: "!null",
        async: true,
        wrapped,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            if (dataset.value !== null) dataset = await this.wrapped["~run"](dataset, config$1);
            if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/nonNullish/nonNullish.ts
/* @__NO_SIDE_EFFECTS__ */ function nonNullish(wrapped, message$1) {
    return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullish,
        expects: "(!null & !undefined)",
        async: false,
        wrapped,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped["~run"](dataset, config$1);
            if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/nonNullish/nonNullishAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function nonNullishAsync(wrapped, message$1) {
    return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullishAsync,
        expects: "(!null & !undefined)",
        async: true,
        wrapped,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            if (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped["~run"](dataset, config$1);
            if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/nonOptional/nonOptional.ts
/* @__NO_SIDE_EFFECTS__ */ function nonOptional(wrapped, message$1) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptional,
        expects: "!undefined",
        async: false,
        wrapped,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value !== void 0) dataset = this.wrapped["~run"](dataset, config$1);
            if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/nonOptional/nonOptionalAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function nonOptionalAsync(wrapped, message$1) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptionalAsync,
        expects: "!undefined",
        async: true,
        wrapped,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            if (dataset.value !== void 0) dataset = await this.wrapped["~run"](dataset, config$1);
            if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/null/null.ts
/* @__NO_SIDE_EFFECTS__ */ function null_(message$1) {
    return {
        kind: "schema",
        type: "null",
        reference: null_,
        expects: "null",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value === null) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/nullable/nullable.ts
/* @__NO_SIDE_EFFECTS__ */ function nullable(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullable",
        reference: nullable,
        expects: `(${wrapped.expects} | null)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value === null) {
                if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
                if (dataset.value === null) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/nullable/nullableAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function nullableAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullable",
        reference: nullableAsync,
        expects: `(${wrapped.expects} | null)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            if (dataset.value === null) {
                if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
                if (dataset.value === null) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/nullish/nullish.ts
/* @__NO_SIDE_EFFECTS__ */ function nullish(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullish",
        reference: nullish,
        expects: `(${wrapped.expects} | null | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value === null || dataset.value === void 0) {
                if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
                if (dataset.value === null || dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/nullish/nullishAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function nullishAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "nullish",
        reference: nullishAsync,
        expects: `(${wrapped.expects} | null | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            if (dataset.value === null || dataset.value === void 0) {
                if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
                if (dataset.value === null || dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/number/number.ts
/* @__NO_SIDE_EFFECTS__ */ function number(message$1) {
    return {
        kind: "schema",
        type: "number",
        reference: number,
        expects: "number",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (typeof dataset.value === "number" && !isNaN(dataset.value)) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/object/object.ts
/* @__NO_SIDE_EFFECTS__ */ function object(entries$1, message$1) {
    return {
        kind: "schema",
        type: "object",
        reference: object,
        expects: "Object",
        async: false,
        entries: entries$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                        const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value$1
                        }, config$1);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value$1
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) issue.path.unshift(pathItem);
                                else issue.path = [
                                    pathItem
                                ];
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) dataset.issues = valueDataset.issues;
                            if (config$1.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) dataset.typed = false;
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
                    else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config$1, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: input[key]
                                }
                            ]
                        });
                        if (config$1.abortEarly) break;
                    }
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/object/objectAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function objectAsync(entries$1, message$1) {
    return {
        kind: "schema",
        type: "object",
        reference: objectAsync,
        expects: "Object",
        async: true,
        entries: entries$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                        const value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);
                        return [
                            key,
                            value$1,
                            valueSchema,
                            await valueSchema["~run"]({
                                value: value$1
                            }, config$1)
                        ];
                    }
                    return [
                        key,
                        input[key],
                        valueSchema,
                        null
                    ];
                }));
                for (const [key, value$1, valueSchema, valueDataset] of valueDatasets)if (valueDataset) {
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) dataset.typed = false;
                    dataset.value[key] = valueDataset.value;
                } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);
                else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                    _addIssue(this, "key", dataset, config$1, {
                        input: void 0,
                        expected: `"${key}"`,
                        path: [
                            {
                                type: "object",
                                origin: "key",
                                input,
                                key,
                                value: value$1
                            }
                        ]
                    });
                    if (config$1.abortEarly) break;
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/objectWithRest/objectWithRest.ts
/* @__NO_SIDE_EFFECTS__ */ function objectWithRest(entries$1, rest, message$1) {
    return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRest,
        expects: "Object",
        async: false,
        entries: entries$1,
        rest,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                        const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value$1
                        }, config$1);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value$1
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) issue.path.unshift(pathItem);
                                else issue.path = [
                                    pathItem
                                ];
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) dataset.issues = valueDataset.issues;
                            if (config$1.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) dataset.typed = false;
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
                    else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config$1, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: input[key]
                                }
                            ]
                        });
                        if (config$1.abortEarly) break;
                    }
                }
                if (!dataset.issues || !config$1.abortEarly) {
                    for(const key in input)if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) {
                        const valueDataset = this.rest["~run"]({
                            value: input[key]
                        }, config$1);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: input[key]
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) issue.path.unshift(pathItem);
                                else issue.path = [
                                    pathItem
                                ];
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) dataset.issues = valueDataset.issues;
                            if (config$1.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) dataset.typed = false;
                        dataset.value[key] = valueDataset.value;
                    }
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/objectWithRest/objectWithRestAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function objectWithRestAsync(entries$1, rest, message$1) {
    return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRestAsync,
        expects: "Object",
        async: true,
        entries: entries$1,
        rest,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const [normalDatasets, restDatasets] = await Promise.all([
                    Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                        if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                            const value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);
                            return [
                                key,
                                value$1,
                                valueSchema,
                                await valueSchema["~run"]({
                                    value: value$1
                                }, config$1)
                            ];
                        }
                        return [
                            key,
                            input[key],
                            valueSchema,
                            null
                        ];
                    })),
                    Promise.all(Object.entries(input).filter(([key])=>/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1])=>[
                            key,
                            value$1,
                            await this.rest["~run"]({
                                value: value$1
                            }, config$1)
                        ]))
                ]);
                for (const [key, value$1, valueSchema, valueDataset] of normalDatasets)if (valueDataset) {
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) dataset.typed = false;
                    dataset.value[key] = valueDataset.value;
                } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);
                else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                    _addIssue(this, "key", dataset, config$1, {
                        input: void 0,
                        expected: `"${key}"`,
                        path: [
                            {
                                type: "object",
                                origin: "key",
                                input,
                                key,
                                value: value$1
                            }
                        ]
                    });
                    if (config$1.abortEarly) break;
                }
                if (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets){
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) dataset.typed = false;
                    dataset.value[key] = valueDataset.value;
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/optional/optional.ts
/* @__NO_SIDE_EFFECTS__ */ function optional(wrapped, default_) {
    return {
        kind: "schema",
        type: "optional",
        reference: optional,
        expects: `(${wrapped.expects} | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/optional/optionalAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function optionalAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "optional",
        reference: optionalAsync,
        expects: `(${wrapped.expects} | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/picklist/picklist.ts
/* @__NO_SIDE_EFFECTS__ */ function picklist(options, message$1) {
    return {
        kind: "schema",
        type: "picklist",
        reference: picklist,
        expects: /* @__PURE__ */ _joinExpects(options.map(_stringify), "|"),
        async: false,
        options,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (this.options.includes(dataset.value)) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/promise/promise.ts
/* @__NO_SIDE_EFFECTS__ */ function promise(message$1) {
    return {
        kind: "schema",
        type: "promise",
        reference: promise,
        expects: "Promise",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value instanceof Promise) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/record/record.ts
/* @__NO_SIDE_EFFECTS__ */ function record(key, value$1, message$1) {
    return {
        kind: "schema",
        type: "record",
        reference: record,
        expects: "Object",
        async: false,
        key,
        value: value$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const entryKey in input)if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {
                    const entryValue = input[entryKey];
                    const keyDataset = this.key["~run"]({
                        value: entryKey
                    }, config$1);
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "key",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of keyDataset.issues){
                            issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = keyDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    const valueDataset = this.value["~run"]({
                        value: entryValue
                    }, config$1);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
                    if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/record/recordAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function recordAsync(key, value$1, message$1) {
    return {
        kind: "schema",
        type: "record",
        reference: recordAsync,
        expects: "Object",
        async: true,
        key,
        value: value$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const datasets = await Promise.all(Object.entries(input).filter(([key$1])=>/* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue])=>Promise.all([
                        entryKey,
                        entryValue,
                        this.key["~run"]({
                            value: entryKey
                        }, config$1),
                        this.value["~run"]({
                            value: entryValue
                        }, config$1)
                    ])));
                for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets){
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "key",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of keyDataset.issues){
                            issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = keyDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
                    if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/set/set.ts
/* @__NO_SIDE_EFFECTS__ */ function set(value$1, message$1) {
    return {
        kind: "schema",
        type: "set",
        reference: set,
        expects: "Set",
        async: false,
        value: value$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input instanceof Set) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Set();
                for (const inputValue of input){
                    const valueDataset = this.value["~run"]({
                        value: inputValue
                    }, config$1);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "set",
                            origin: "value",
                            input,
                            key: null,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) dataset.typed = false;
                    dataset.value.add(valueDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/set/setAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function setAsync(value$1, message$1) {
    return {
        kind: "schema",
        type: "set",
        reference: setAsync,
        expects: "Set",
        async: true,
        value: value$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input instanceof Set) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Set();
                const valueDatasets = await Promise.all([
                    ...input
                ].map(async (inputValue)=>[
                        inputValue,
                        await this.value["~run"]({
                            value: inputValue
                        }, config$1)
                    ]));
                for (const [inputValue, valueDataset] of valueDatasets){
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "set",
                            origin: "value",
                            input,
                            key: null,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) dataset.typed = false;
                    dataset.value.add(valueDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/strictObject/strictObject.ts
/* @__NO_SIDE_EFFECTS__ */ function strictObject(entries$1, message$1) {
    return {
        kind: "schema",
        type: "strict_object",
        reference: strictObject,
        expects: "Object",
        async: false,
        entries: entries$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const valueSchema = this.entries[key];
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                        const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
                        const valueDataset = valueSchema["~run"]({
                            value: value$1
                        }, config$1);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value$1
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) issue.path.unshift(pathItem);
                                else issue.path = [
                                    pathItem
                                ];
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) dataset.issues = valueDataset.issues;
                            if (config$1.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) dataset.typed = false;
                        dataset.value[key] = valueDataset.value;
                    } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
                    else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                        _addIssue(this, "key", dataset, config$1, {
                            input: void 0,
                            expected: `"${key}"`,
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: input[key]
                                }
                            ]
                        });
                        if (config$1.abortEarly) break;
                    }
                }
                if (!dataset.issues || !config$1.abortEarly) {
                    for(const key in input)if (!(key in this.entries)) {
                        _addIssue(this, "key", dataset, config$1, {
                            input: key,
                            expected: "never",
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: input[key]
                                }
                            ]
                        });
                        break;
                    }
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/strictObject/strictObjectAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function strictObjectAsync(entries$1, message$1) {
    return {
        kind: "schema",
        type: "strict_object",
        reference: strictObjectAsync,
        expects: "Object",
        async: true,
        entries: entries$1,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{
                    if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                        const value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);
                        return [
                            key,
                            value$1,
                            valueSchema,
                            await valueSchema["~run"]({
                                value: value$1
                            }, config$1)
                        ];
                    }
                    return [
                        key,
                        input[key],
                        valueSchema,
                        null
                    ];
                }));
                for (const [key, value$1, valueSchema, valueDataset] of valueDatasets)if (valueDataset) {
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = valueDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) dataset.typed = false;
                    dataset.value[key] = valueDataset.value;
                } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);
                else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                    _addIssue(this, "key", dataset, config$1, {
                        input: void 0,
                        expected: `"${key}"`,
                        path: [
                            {
                                type: "object",
                                origin: "key",
                                input,
                                key,
                                value: value$1
                            }
                        ]
                    });
                    if (config$1.abortEarly) break;
                }
                if (!dataset.issues || !config$1.abortEarly) {
                    for(const key in input)if (!(key in this.entries)) {
                        _addIssue(this, "key", dataset, config$1, {
                            input: key,
                            expected: "never",
                            path: [
                                {
                                    type: "object",
                                    origin: "key",
                                    input,
                                    key,
                                    value: input[key]
                                }
                            ]
                        });
                        break;
                    }
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/strictTuple/strictTuple.ts
/* @__NO_SIDE_EFFECTS__ */ function strictTuple(items, message$1) {
    return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTuple,
        expects: "Array",
        async: false,
        items,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value$1 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value$1
                    }, config$1);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
                if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
                    input: input[this.items.length],
                    expected: "never",
                    path: [
                        {
                            type: "array",
                            origin: "value",
                            input,
                            key: this.items.length,
                            value: input[this.items.length]
                        }
                    ]
                });
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/strictTuple/strictTupleAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function strictTupleAsync(items, message$1) {
    return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTupleAsync,
        expects: "Array",
        async: true,
        items,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{
                    const value$1 = input[key];
                    return [
                        key,
                        value$1,
                        await item["~run"]({
                            value: value$1
                        }, config$1)
                    ];
                }));
                for (const [key, value$1, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
                if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
                    input: input[this.items.length],
                    expected: "never",
                    path: [
                        {
                            type: "array",
                            origin: "value",
                            input,
                            key: this.items.length,
                            value: input[this.items.length]
                        }
                    ]
                });
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/string/string.ts
/* @__NO_SIDE_EFFECTS__ */ function string(message$1) {
    return {
        kind: "schema",
        type: "string",
        reference: string,
        expects: "string",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (typeof dataset.value === "string") dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/symbol/symbol.ts
/* @__NO_SIDE_EFFECTS__ */ function symbol(message$1) {
    return {
        kind: "schema",
        type: "symbol",
        reference: symbol,
        expects: "symbol",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (typeof dataset.value === "symbol") dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/tuple/tuple.ts
/* @__NO_SIDE_EFFECTS__ */ function tuple(items, message$1) {
    return {
        kind: "schema",
        type: "tuple",
        reference: tuple,
        expects: "Array",
        async: false,
        items,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value$1 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value$1
                    }, config$1);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/tuple/tupleAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function tupleAsync(items, message$1) {
    return {
        kind: "schema",
        type: "tuple",
        reference: tupleAsync,
        expects: "Array",
        async: true,
        items,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{
                    const value$1 = input[key];
                    return [
                        key,
                        value$1,
                        await item["~run"]({
                            value: value$1
                        }, config$1)
                    ];
                }));
                for (const [key, value$1, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/tupleWithRest/tupleWithRest.ts
/* @__NO_SIDE_EFFECTS__ */ function tupleWithRest(items, rest, message$1) {
    return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRest,
        expects: "Array",
        async: false,
        items,
        rest,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < this.items.length; key++){
                    const value$1 = input[key];
                    const itemDataset = this.items[key]["~run"]({
                        value: value$1
                    }, config$1);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config$1.abortEarly) for(let key = this.items.length; key < input.length; key++){
                    const value$1 = input[key];
                    const itemDataset = this.rest["~run"]({
                        value: value$1
                    }, config$1);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/tupleWithRest/tupleWithRestAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function tupleWithRestAsync(items, rest, message$1) {
    return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRestAsync,
        expects: "Array",
        async: true,
        items,
        rest,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const [normalDatasets, restDatasets] = await Promise.all([
                    Promise.all(this.items.map(async (item, key)=>{
                        const value$1 = input[key];
                        return [
                            key,
                            value$1,
                            await item["~run"]({
                                value: value$1
                            }, config$1)
                        ];
                    })),
                    Promise.all(input.slice(this.items.length).map(async (value$1, key)=>{
                        return [
                            key + this.items.length,
                            value$1,
                            await this.rest["~run"]({
                                value: value$1
                            }, config$1)
                        ];
                    }))
                ]);
                for (const [key, value$1, itemDataset] of normalDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value$1
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) issue.path.unshift(pathItem);
                            else issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) dataset.issues = itemDataset.issues;
                        if (config$1.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) dataset.typed = false;
                    dataset.value.push(itemDataset.value);
                }
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/undefined/undefined.ts
/* @__NO_SIDE_EFFECTS__ */ function undefined_(message$1) {
    return {
        kind: "schema",
        type: "undefined",
        reference: undefined_,
        expects: "undefined",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value === void 0) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/undefinedable/undefinedable.ts
/* @__NO_SIDE_EFFECTS__ */ function undefinedable(wrapped, default_) {
    return {
        kind: "schema",
        type: "undefinedable",
        reference: undefinedable,
        expects: `(${wrapped.expects} | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/undefinedable/undefinedableAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function undefinedableAsync(wrapped, default_) {
    return {
        kind: "schema",
        type: "undefinedable",
        reference: undefinedableAsync,
        expects: `(${wrapped.expects} | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            if (dataset.value === void 0) {
                if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped["~run"](dataset, config$1);
        }
    };
}
//#endregion
//#region src/schemas/union/utils/_subIssues/_subIssues.ts
/**
* Returns the sub issues of the provided datasets for the union issue.
*
* @param datasets The datasets.
*
* @returns The sub issues.
*
* @internal
*/ /* @__NO_SIDE_EFFECTS__ */ function _subIssues(datasets) {
    let issues;
    if (datasets) for (const dataset of datasets)if (issues) issues.push(...dataset.issues);
    else issues = dataset.issues;
    return issues;
}
//#endregion
//#region src/schemas/union/union.ts
/* @__NO_SIDE_EFFECTS__ */ function union(options, message$1) {
    return {
        kind: "schema",
        type: "union",
        reference: union,
        expects: /* @__PURE__ */ _joinExpects(options.map((option)=>option.expects), "|"),
        async: false,
        options,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options){
                const optionDataset = schema["~run"]({
                    value: dataset.value
                }, config$1);
                if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
                else typedDatasets = [
                    optionDataset
                ];
                else {
                    validDataset = optionDataset;
                    break;
                }
                else if (untypedDatasets) untypedDatasets.push(optionDataset);
                else untypedDatasets = [
                    optionDataset
                ];
            }
            if (validDataset) return validDataset;
            if (typedDatasets) {
                if (typedDatasets.length === 1) return typedDatasets[0];
                _addIssue(this, "type", dataset, config$1, {
                    issues: /* @__PURE__ */ _subIssues(typedDatasets)
                });
                dataset.typed = true;
            } else if (untypedDatasets?.length === 1) return untypedDatasets[0];
            else _addIssue(this, "type", dataset, config$1, {
                issues: /* @__PURE__ */ _subIssues(untypedDatasets)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/union/unionAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function unionAsync(options, message$1) {
    return {
        kind: "schema",
        type: "union",
        reference: unionAsync,
        expects: /* @__PURE__ */ _joinExpects(options.map((option)=>option.expects), "|"),
        async: true,
        options,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options){
                const optionDataset = await schema["~run"]({
                    value: dataset.value
                }, config$1);
                if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
                else typedDatasets = [
                    optionDataset
                ];
                else {
                    validDataset = optionDataset;
                    break;
                }
                else if (untypedDatasets) untypedDatasets.push(optionDataset);
                else untypedDatasets = [
                    optionDataset
                ];
            }
            if (validDataset) return validDataset;
            if (typedDatasets) {
                if (typedDatasets.length === 1) return typedDatasets[0];
                _addIssue(this, "type", dataset, config$1, {
                    issues: /* @__PURE__ */ _subIssues(typedDatasets)
                });
                dataset.typed = true;
            } else if (untypedDatasets?.length === 1) return untypedDatasets[0];
            else _addIssue(this, "type", dataset, config$1, {
                issues: /* @__PURE__ */ _subIssues(untypedDatasets)
            });
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/unknown/unknown.ts
/**
* Creates a unknown schema.
*
* @returns A unknown schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function unknown() {
    return {
        kind: "schema",
        type: "unknown",
        reference: unknown,
        expects: "unknown",
        async: false,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset) {
            dataset.typed = true;
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/variant/variant.ts
/* @__NO_SIDE_EFFECTS__ */ function variant(key, options, message$1) {
    return {
        kind: "schema",
        type: "variant",
        reference: variant,
        expects: "Object",
        async: false,
        key,
        options,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                let outputDataset;
                let maxDiscriminatorPriority = 0;
                let invalidDiscriminatorKey = this.key;
                let expectedDiscriminators = [];
                const parseOptions = (variant$1, allKeys)=>{
                    for (const schema of variant$1.options){
                        if (schema.type === "variant") parseOptions(schema, new Set(allKeys).add(schema.key));
                        else {
                            let keysAreValid = true;
                            let currentPriority = 0;
                            for (const currentKey of allKeys){
                                const discriminatorSchema = schema.entries[currentKey];
                                if (currentKey in input ? discriminatorSchema["~run"]({
                                    typed: false,
                                    value: input[currentKey]
                                }, {
                                    abortEarly: true
                                }).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                                    keysAreValid = false;
                                    if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                                        maxDiscriminatorPriority = currentPriority;
                                        invalidDiscriminatorKey = currentKey;
                                        expectedDiscriminators = [];
                                    }
                                    if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
                                    break;
                                }
                                currentPriority++;
                            }
                            if (keysAreValid) {
                                const optionDataset = schema["~run"]({
                                    value: input
                                }, config$1);
                                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
                            }
                        }
                        if (outputDataset && !outputDataset.issues) break;
                    }
                };
                parseOptions(this, new Set([
                    this.key
                ]));
                if (outputDataset) return outputDataset;
                _addIssue(this, "type", dataset, config$1, {
                    input: input[invalidDiscriminatorKey],
                    expected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, "|"),
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input,
                            key: invalidDiscriminatorKey,
                            value: input[invalidDiscriminatorKey]
                        }
                    ]
                });
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/variant/variantAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function variantAsync(key, options, message$1) {
    return {
        kind: "schema",
        type: "variant",
        reference: variantAsync,
        expects: "Object",
        async: true,
        key,
        options,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                let outputDataset;
                let maxDiscriminatorPriority = 0;
                let invalidDiscriminatorKey = this.key;
                let expectedDiscriminators = [];
                const parseOptions = async (variant$1, allKeys)=>{
                    for (const schema of variant$1.options){
                        if (schema.type === "variant") await parseOptions(schema, new Set(allKeys).add(schema.key));
                        else {
                            let keysAreValid = true;
                            let currentPriority = 0;
                            for (const currentKey of allKeys){
                                const discriminatorSchema = schema.entries[currentKey];
                                if (currentKey in input ? (await discriminatorSchema["~run"]({
                                    typed: false,
                                    value: input[currentKey]
                                }, {
                                    abortEarly: true
                                })).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                                    keysAreValid = false;
                                    if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                                        maxDiscriminatorPriority = currentPriority;
                                        invalidDiscriminatorKey = currentKey;
                                        expectedDiscriminators = [];
                                    }
                                    if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
                                    break;
                                }
                                currentPriority++;
                            }
                            if (keysAreValid) {
                                const optionDataset = await schema["~run"]({
                                    value: input
                                }, config$1);
                                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
                            }
                        }
                        if (outputDataset && !outputDataset.issues) break;
                    }
                };
                await parseOptions(this, new Set([
                    this.key
                ]));
                if (outputDataset) return outputDataset;
                _addIssue(this, "type", dataset, config$1, {
                    input: input[invalidDiscriminatorKey],
                    expected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, "|"),
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input,
                            key: invalidDiscriminatorKey,
                            value: input[invalidDiscriminatorKey]
                        }
                    ]
                });
            } else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/schemas/void/void.ts
/* @__NO_SIDE_EFFECTS__ */ function void_(message$1) {
    return {
        kind: "schema",
        type: "void",
        reference: void_,
        expects: "void",
        async: false,
        message: message$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            if (dataset.value === void 0) dataset.typed = true;
            else _addIssue(this, "type", dataset, config$1);
            return dataset;
        }
    };
}
//#endregion
//#region src/methods/keyof/keyof.ts
/* @__NO_SIDE_EFFECTS__ */ function keyof(schema, message$1) {
    return /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);
}
//#endregion
//#region src/methods/message/message.ts
/**
* Changes the local message configuration of a schema.
*
* @param schema The schema to configure.
* @param message_ The error message.
*
* @returns The configured schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function message(schema, message_) {
    return {
        ...schema,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            return schema["~run"](dataset, {
                ...config$1,
                message: message_
            });
        }
    };
}
//#endregion
//#region src/methods/omit/omit.ts
/**
* Creates a modified copy of an object schema that does not contain the
* selected entries.
*
* @param schema The schema to omit from.
* @param keys The selected entries.
*
* @returns An object schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function omit(schema, keys) {
    const entries$1 = {
        ...schema.entries
    };
    for (const key of keys)delete entries$1[key];
    return {
        ...schema,
        entries: entries$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        }
    };
}
//#endregion
//#region src/methods/parse/parse.ts
/**
* Parses an unknown input based on a schema.
*
* @param schema The schema to be used.
* @param input The input to be parsed.
* @param config The parse configuration.
*
* @returns The parsed input.
*/ function parse(schema, input, config$1) {
    const dataset = schema["~run"]({
        value: input
    }, /* @__PURE__ */ getGlobalConfig(config$1));
    if (dataset.issues) throw new ValiError(dataset.issues);
    return dataset.value;
}
//#endregion
//#region src/methods/parse/parseAsync.ts
/**
* Parses an unknown input based on a schema.
*
* @param schema The schema to be used.
* @param input The input to be parsed.
* @param config The parse configuration.
*
* @returns The parsed input.
*/ async function parseAsync(schema, input, config$1) {
    const dataset = await schema["~run"]({
        value: input
    }, /* @__PURE__ */ getGlobalConfig(config$1));
    if (dataset.issues) throw new ValiError(dataset.issues);
    return dataset.value;
}
//#endregion
//#region src/methods/parser/parser.ts
/* @__NO_SIDE_EFFECTS__ */ function parser(schema, config$1) {
    const func = (input)=>parse(schema, input, config$1);
    func.schema = schema;
    func.config = config$1;
    return func;
}
//#endregion
//#region src/methods/parser/parserAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function parserAsync(schema, config$1) {
    const func = (input)=>parseAsync(schema, input, config$1);
    func.schema = schema;
    func.config = config$1;
    return func;
}
//#endregion
//#region src/methods/partial/partial.ts
/* @__NO_SIDE_EFFECTS__ */ function partial(schema, keys) {
    const entries$1 = {};
    for(const key in schema.entries)entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optional(schema.entries[key]) : schema.entries[key];
    return {
        ...schema,
        entries: entries$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        }
    };
}
//#endregion
//#region src/methods/partial/partialAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function partialAsync(schema, keys) {
    const entries$1 = {};
    for(const key in schema.entries)entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optionalAsync(schema.entries[key]) : schema.entries[key];
    return {
        ...schema,
        entries: entries$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        }
    };
}
//#endregion
//#region src/methods/pick/pick.ts
/**
* Creates a modified copy of an object schema that contains only the selected
* entries.
*
* @param schema The schema to pick from.
* @param keys The selected entries.
*
* @returns An object schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function pick(schema, keys) {
    const entries$1 = {};
    for (const key of keys)entries$1[key] = schema.entries[key];
    return {
        ...schema,
        entries: entries$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        }
    };
}
//#endregion
//#region src/methods/pipe/pipe.ts
/* @__NO_SIDE_EFFECTS__ */ function pipe(...pipe$1) {
    return {
        ...pipe$1[0],
        pipe: pipe$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        "~run" (dataset, config$1) {
            for (const item of pipe$1)if (item.kind !== "metadata") {
                if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                    dataset.typed = false;
                    break;
                }
                if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item["~run"](dataset, config$1);
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/methods/pipe/pipeAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function pipeAsync(...pipe$1) {
    return {
        ...pipe$1[0],
        pipe: pipe$1,
        async: true,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        },
        async "~run" (dataset, config$1) {
            for (const item of pipe$1)if (item.kind !== "metadata") {
                if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                    dataset.typed = false;
                    break;
                }
                if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item["~run"](dataset, config$1);
            }
            return dataset;
        }
    };
}
//#endregion
//#region src/methods/required/required.ts
/* @__NO_SIDE_EFFECTS__ */ function required(schema, arg2, arg3) {
    const keys = Array.isArray(arg2) ? arg2 : void 0;
    const message$1 = Array.isArray(arg2) ? arg3 : arg2;
    const entries$1 = {};
    for(const key in schema.entries)entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptional(schema.entries[key], message$1) : schema.entries[key];
    return {
        ...schema,
        entries: entries$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        }
    };
}
//#endregion
//#region src/methods/required/requiredAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function requiredAsync(schema, arg2, arg3) {
    const keys = Array.isArray(arg2) ? arg2 : void 0;
    const message$1 = Array.isArray(arg2) ? arg3 : arg2;
    const entries$1 = {};
    for(const key in schema.entries)entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];
    return {
        ...schema,
        entries: entries$1,
        get "~standard" () {
            return /* @__PURE__ */ _getStandardProps(this);
        }
    };
}
//#endregion
//#region src/methods/safeParse/safeParse.ts
/**
* Parses an unknown input based on a schema.
*
* @param schema The schema to be used.
* @param input The input to be parsed.
* @param config The parse configuration.
*
* @returns The parse result.
*/ /* @__NO_SIDE_EFFECTS__ */ function safeParse(schema, input, config$1) {
    const dataset = schema["~run"]({
        value: input
    }, /* @__PURE__ */ getGlobalConfig(config$1));
    return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
    };
}
//#endregion
//#region src/methods/safeParse/safeParseAsync.ts
/**
* Parses an unknown input based on a schema.
*
* @param schema The schema to be used.
* @param input The input to be parsed.
* @param config The parse configuration.
*
* @returns The parse result.
*/ /* @__NO_SIDE_EFFECTS__ */ async function safeParseAsync(schema, input, config$1) {
    const dataset = await schema["~run"]({
        value: input
    }, /* @__PURE__ */ getGlobalConfig(config$1));
    return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
    };
}
//#endregion
//#region src/methods/safeParser/safeParser.ts
/* @__NO_SIDE_EFFECTS__ */ function safeParser(schema, config$1) {
    const func = (input)=>/* @__PURE__ */ safeParse(schema, input, config$1);
    func.schema = schema;
    func.config = config$1;
    return func;
}
//#endregion
//#region src/methods/safeParser/safeParserAsync.ts
/* @__NO_SIDE_EFFECTS__ */ function safeParserAsync(schema, config$1) {
    const func = (input)=>/* @__PURE__ */ safeParseAsync(schema, input, config$1);
    func.schema = schema;
    func.config = config$1;
    return func;
}
//#endregion
//#region src/methods/summarize/summarize.ts
/**
* Summarize the error messages of issues in a pretty-printable multi-line string.
*
* @param issues The list of issues.
*
* @returns A summary of the issues.
*
* @beta
*/ /* @__NO_SIDE_EFFECTS__ */ function summarize(issues) {
    let summary = "";
    for (const issue of issues){
        if (summary) summary += "\n";
        summary += `× ${issue.message}`;
        const dotPath = /* @__PURE__ */ getDotPath(issue);
        if (dotPath) summary += `\n  → at ${dotPath}`;
    }
    return summary;
}
//#endregion
//#region src/methods/unwrap/unwrap.ts
/**
* Unwraps the wrapped schema.
*
* @param schema The schema to be unwrapped.
*
* @returns The unwrapped schema.
*/ /* @__NO_SIDE_EFFECTS__ */ function unwrap(schema) {
    return schema.wrapped;
}
;
}),
"[project]/node_modules/@sanity/visual-editing-csm/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createDataAttribute",
    ()=>createDataAttribute,
    "decodeSanityNodeData",
    ()=>decodeSanityNodeData,
    "encodeSanityNodeData",
    ()=>encodeSanityNodeData,
    "pathToUrlString",
    ()=>pathToUrlString,
    "urlStringToPath",
    ()=>urlStringToPath
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/valibot/dist/index.mjs [app-client] (ecmascript)");
;
;
const lengthyStr$1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["minLength"])(1)), optionalLengthyStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optional"])(lengthyStr$1), sanityNodeSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"])({
    baseUrl: lengthyStr$1,
    dataset: optionalLengthyStr,
    id: lengthyStr$1,
    path: lengthyStr$1,
    projectId: optionalLengthyStr,
    tool: optionalLengthyStr,
    type: optionalLengthyStr,
    workspace: optionalLengthyStr,
    perspective: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fallback"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"])(), "drafts")
});
function isValidSanityNode(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["is"])(sanityNodeSchema, node);
}
function isArray(value) {
    return value !== null && Array.isArray(value);
}
function pathToUrlString(path) {
    let str = "";
    for (const segment of path){
        if (typeof segment == "string") {
            str && (str += "."), str += segment;
            continue;
        }
        if (typeof segment == "number") {
            str && (str += ":"), str += `${segment}`;
            continue;
        }
        if (isArray(segment)) {
            str && (str += ":"), str += `${segment.join(",")}}`;
            continue;
        }
        if (segment._key) {
            str && (str += ":"), str += `${segment._key}`;
            continue;
        }
    }
    return str;
}
function encodeSanityNodeData(node) {
    const { id: _id, path, baseUrl, tool, workspace, type } = node;
    return isValidSanityNode(node) ? [
        [
            "id",
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublishedId"])(_id)
        ],
        [
            "type",
            type
        ],
        [
            "path",
            pathToUrlString(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].fromString(path))
        ],
        [
            "base",
            encodeURIComponent(baseUrl)
        ],
        [
            "workspace",
            workspace
        ],
        [
            "tool",
            tool
        ]
    ].filter(([, value])=>!!value).map((part)=>part.join("=")).join(";") : void 0;
}
function createDataAttribute(props) {
    function normalizePath(path) {
        return path ? typeof path == "string" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].fromString(path) : path : [];
    }
    function toString(props2) {
        if (!props2.id) throw new Error("`id` is required to create a data attribute");
        if (!props2.type) throw new Error("`type` is required to create a data attribute");
        if (!props2.path || !props2.path.length) throw new Error("`path` is required to create a data attribute");
        const attrs = {
            baseUrl: props2.baseUrl || "/",
            workspace: props2.workspace,
            tool: props2.tool,
            type: props2.type,
            id: props2.id,
            path: typeof props2.path == "string" ? props2.path : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].toString(props2.path),
            perspective: props2.perspective
        };
        return encodeSanityNodeData(attrs);
    }
    const DataAttribute = (path)=>toString({
            ...props,
            path: [
                ...normalizePath(props.path),
                ...normalizePath(path)
            ]
        });
    return DataAttribute.toString = function() {
        return toString(props);
    }, DataAttribute.combine = function(attrs) {
        return createDataAttribute({
            ...props,
            ...attrs
        });
    }, DataAttribute.scope = function(path) {
        return createDataAttribute({
            ...props,
            path: [
                ...normalizePath(props.path),
                ...normalizePath(path)
            ]
        });
    }, DataAttribute;
}
const RE_SEGMENT_WITH_INDEX = /^([\w-]+):(0|[1-9][0-9]*)$/, RE_SEGMENT_WITH_TUPLE = /^([\w-]+):([0-9]+),([0-9]+)$/, RE_SEGMENT_WITH_KEY = /^([\w-]+):([\w-]+)$/;
function urlStringToPath(str) {
    const path = [];
    for (const segment of str.split(".")){
        const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);
        if (withIndex) {
            path.push(withIndex[1], Number(withIndex[2]));
            continue;
        }
        const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);
        if (withTuple) {
            path.push(withTuple[1], [
                Number(withTuple[2]),
                Number(withTuple[3])
            ]);
            continue;
        }
        const withKey = RE_SEGMENT_WITH_KEY.exec(segment);
        if (withKey) {
            path.push(withKey[1], {
                _key: withKey[2]
            });
            continue;
        }
        path.push(segment);
    }
    return path;
}
const lengthyStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["minLength"])(1)), sanityLegacyNodeSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"])({
    origin: lengthyStr,
    href: lengthyStr,
    data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optional"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["record"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unknown"])()))
});
function decodeSanityString(str) {
    const data = str.split(";").reduce((acc, segment)=>{
        const [key, value] = segment.split("=");
        if (!key || segment.includes("=") && !value) return acc;
        switch(key){
            case "id":
                acc.id = value;
                break;
            case "type":
                acc.type = value;
                break;
            case "path":
                acc.path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].toString(urlStringToPath(value));
                break;
            case "base":
                acc.baseUrl = decodeURIComponent(value);
                break;
            case "perspective":
                acc.perspective = value;
                break;
            case "tool":
                acc.tool = value;
                break;
            case "workspace":
                acc.workspace = value;
                break;
            case "projectId":
                acc.projectId = value;
                break;
            case "dataset":
                acc.dataset = value;
                break;
        }
        return acc;
    }, {});
    if (isValidSanityNode(data)) return data;
}
function decodeSanityObject(data) {
    const sanityNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeParse"])(sanityNodeSchema, data);
    if (sanityNode.success) return sanityNode.output;
    const sanityLegacyNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeParse"])(sanityLegacyNodeSchema, data);
    if (sanityLegacyNode.success) try {
        const url = new URL(sanityLegacyNode.output.href, typeof document > "u" ? "https://example.com" : location.origin);
        return url.searchParams.size > 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(sanityNodeSchema, Object.fromEntries(url.searchParams.entries())) : sanityLegacyNode.output;
    } catch (err) {
        return console.error("Failed to parse sanity node", err), sanityLegacyNode.output;
    }
}
function decodeSanityNodeData(data) {
    if (typeof data == "object" && data !== null) return decodeSanityObject(data);
    try {
        const obj = JSON.parse(data);
        return decodeSanityObject(obj);
    } catch  {
        return decodeSanityString(data);
    }
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/core-loader/dist/encode-data-attribute.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "defineEncodeDataAttribute",
    ()=>defineEncodeDataAttribute,
    "encodeDataAttribute",
    ()=>encodeDataAttribute
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2d$csm$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/visual-editing-csm/dist/index.js [app-client] (ecmascript)");
;
;
const encodeDataAttribute = (result, sourceMap, studioUrl, studioPathLike)=>{
    if (!sourceMap || !studioUrl) return;
    const resultPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPathToJsonPath"])(studioPathLike), editInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEditInfo"])({
        resultPath,
        resultSourceMap: sourceMap,
        studioUrl
    });
    if (editInfo) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2d$csm$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeSanityNodeData"])({
        baseUrl: editInfo.baseUrl,
        workspace: editInfo.workspace,
        tool: editInfo.tool,
        type: editInfo.type,
        id: editInfo.id,
        path: typeof editInfo.path == "string" ? editInfo.path : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].toString((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonPathToStudioPath"])(editInfo.path))
    });
};
function defineEncodeDataAttribute(result, sourceMap, studioUrl, basePath) {
    const parse = (path)=>path ? typeof path == "string" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].fromString(path) : path : [], parsedBasePath = parse(basePath);
    return Object.assign((path)=>encodeDataAttribute(result, sourceMap, studioUrl, [
            ...parsedBasePath,
            ...parse(path)
        ]), // The scope method creates a scoped version of encodeDataAttribute
    {
        scope: (scope)=>defineEncodeDataAttribute(result, sourceMap, studioUrl, [
                ...parsedBasePath,
                ...parse(scope)
            ])
    });
}
;
 //# sourceMappingURL=encode-data-attribute.js.map
}),
"[project]/node_modules/@sanity/react-loader/dist/index.browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createQueryStore",
    ()=>createQueryStore,
    "loadQuery",
    ()=>loadQuery,
    "setServerClient",
    ()=>setServerClient,
    "useEncodeDataAttribute",
    ()=>useEncodeDataAttribute,
    "useLiveMode",
    ()=>useLiveMode,
    "useQuery",
    ()=>useQuery
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$core$2d$loader$2f$dist$2f$_chunks$2d$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/core-loader/dist/_chunks-es/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$core$2d$loader$2f$dist$2f$encode$2d$data$2d$attribute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/core-loader/dist/encode-data-attribute.js [app-client] (ecmascript)");
;
;
;
function defineStudioUrlStore(client) {
    let studioUrl = typeof client == "object" ? client?.config().stega.studioUrl : void 0;
    const serverSnapshot = studioUrl, subscribers = /* @__PURE__ */ new Set();
    return {
        subscribe (callback) {
            return subscribers.add(callback), ()=>subscribers.delete(callback);
        },
        getSnapshot () {
            return studioUrl;
        },
        getServerSnapshot () {
            return serverSnapshot;
        },
        setStudioUrl (nextStudioUrl) {
            studioUrl = nextStudioUrl, subscribers.forEach((callback)=>callback());
        }
    };
}
function defineUseLiveMode({ enableLiveMode, setStudioUrl }) {
    return ({ allowStudioOrigin, client, onConnect, onDisconnect, onPerspective, studioUrl })=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
            "defineUseLiveMode.useEffect": ()=>{
                allowStudioOrigin && console.warn("`allowStudioOrigin` is deprecated and no longer needed");
                const disableLiveMode = enableLiveMode({
                    client,
                    onConnect,
                    onDisconnect,
                    onPerspective
                });
                return ({
                    "defineUseLiveMode.useEffect": ()=>disableLiveMode()
                })["defineUseLiveMode.useEffect"];
            }
        }["defineUseLiveMode.useEffect"], [
            allowStudioOrigin,
            client,
            onConnect,
            onDisconnect,
            onPerspective
        ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
            "defineUseLiveMode.useEffect": ()=>{
                setStudioUrl(studioUrl ?? typeof client == "object" ? client?.config().stega.studioUrl : void 0);
            }
        }["defineUseLiveMode.useEffect"], [
            studioUrl,
            client
        ]);
    };
}
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var fastDeepEqual, hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
    return hasRequiredFastDeepEqual || (hasRequiredFastDeepEqual = 1, fastDeepEqual = function equal(a, b) {
        if (a === b) return !0;
        if (a && b && typeof a == "object" && typeof b == "object") {
            if (a.constructor !== b.constructor) return !1;
            var length, i, keys;
            if (Array.isArray(a)) {
                if (length = a.length, length != b.length) return !1;
                for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return !1;
                return !0;
            }
            if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
            if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
            if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
            if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
            for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
            for(i = length; i-- !== 0;){
                var key = keys[i];
                if (!equal(a[key], b[key])) return !1;
            }
            return !0;
        }
        return a !== a && b !== b;
    }), fastDeepEqual;
}
var fastDeepEqualExports = requireFastDeepEqual(), isEqual = /* @__PURE__ */ getDefaultExportFromCjs(fastDeepEqualExports);
function useEncodeDataAttribute(result, sourceMap, studioUrl) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useEncodeDataAttribute.useMemo": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$core$2d$loader$2f$dist$2f$encode$2d$data$2d$attribute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineEncodeDataAttribute"])(result, sourceMap, studioUrl)
    }["useEncodeDataAttribute.useMemo"], [
        result,
        sourceMap,
        studioUrl
    ]);
}
function defineUseQuery({ createFetcherStore, studioUrlStore }) {
    const DEFAULT_PARAMS = {};
    return (query, params = DEFAULT_PARAMS, options = {})=>{
        const initial = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
            "defineUseQuery.useMemo[initial]": ()=>options.initial ? {
                    perspective: "published",
                    ...options.initial
                } : void 0
        }["defineUseQuery.useMemo[initial]"], [
            options.initial
        ]), $params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
            "defineUseQuery.useMemo[$params]": ()=>JSON.stringify(params)
        }["defineUseQuery.useMemo[$params]"], [
            params
        ]), [snapshot, setSnapshot] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
            "defineUseQuery.useState": ()=>createFetcherStore(query, JSON.parse($params), initial).value
        }["defineUseQuery.useState"]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
            "defineUseQuery.useEffect": ()=>{
                const unlisten = createFetcherStore(query, JSON.parse($params), initial).subscribe({
                    "defineUseQuery.useEffect.unlisten": (snapshot2)=>{
                        setSnapshot({
                            "defineUseQuery.useEffect.unlisten": (prev)=>!isEqual(prev.sourceMap, snapshot2.sourceMap) || !isEqual(prev.data, snapshot2.data) || prev.error !== snapshot2.error || prev.loading !== snapshot2.loading || prev.perspective !== snapshot2.perspective ? snapshot2 : prev
                        }["defineUseQuery.useEffect.unlisten"]);
                    }
                }["defineUseQuery.useEffect.unlisten"]);
                return ({
                    "defineUseQuery.useEffect": ()=>unlisten()
                })["defineUseQuery.useEffect"];
            }
        }["defineUseQuery.useEffect"], [
            $params,
            initial,
            query
        ]);
        const studioUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(studioUrlStore.subscribe, studioUrlStore.getSnapshot, studioUrlStore.getServerSnapshot), encodeDataAttribute = useEncodeDataAttribute(snapshot.data, snapshot.sourceMap, studioUrl);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
            "defineUseQuery.useMemo": ()=>({
                    ...snapshot,
                    encodeDataAttribute
                })
        }["defineUseQuery.useMemo"], [
            snapshot,
            encodeDataAttribute
        ]);
    };
}
const createQueryStore = (options)=>{
    const { createFetcherStore, enableLiveMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$core$2d$loader$2f$dist$2f$_chunks$2d$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createQueryStore"])({
        tag: "react-loader",
        ...options
    }), studioUrlStore = defineStudioUrlStore(options.client), useQuery2 = defineUseQuery({
        createFetcherStore,
        studioUrlStore
    }), useLiveMode2 = defineUseLiveMode({
        enableLiveMode,
        setStudioUrl: studioUrlStore.setStudioUrl
    });
    return {
        loadQuery: ()=>{
            throw new Error("The `loadQuery` function is server only.");
        },
        useQuery: useQuery2,
        setServerClient: ()=>{
            throw new Error("The `setServerClient` function is server only.");
        },
        useLiveMode: useLiveMode2
    };
}, { loadQuery, setServerClient, useLiveMode, useQuery } = createQueryStore({
    client: !1,
    ssr: !0
});
;
 //# sourceMappingURL=index.browser.js.map
}),
]);

//# sourceMappingURL=node_modules_a349f3d2._.js.map